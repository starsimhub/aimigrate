{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AIMigrate AIMigrate helps migrate code to maintain compatability when one of your dependency packackages changes Installation pip install aimigrate Configure LLM Provider AIMigrate is compatabile with openai, gemini, and anthropic models. To use these tools you will need an API key. For Gemini, get your API key from: https://aistudio.google.com/apikey For OpenAI, get your API key from: https://platform.openai.com/settings/organization/api-keys For Anthropic, get your API key from: https://www.anthropic.com/api Once you have these keys, we recommend using python-dotenv for managing your keys. Store them as environment variables GEMINI_API_KEY , OPENAI_API_KEY , or ANTHROPIC_API_KEY respective. Running open weight (i.e., local) models : You can also use ollama to run models locally. To start open a terminal run ollama serve . If it is your first time running the model you'll need to pull it first (e.g., ollama run llama3 ). You will likely need to increase the context window . DO NOT UNDER ANY CIRCUMSTANCE SHARE OR UPLOAD TO GITHUB YOUR API KEY! Usage Let's say we have a project Zombiesim that we want to migrate from Starsim v1 (v1.0.3) to v2 (v2.2.0). Typical usage is to migrate all the files in a folder to a new folder: import starsim as ss import aimigrate as aim aim.migrate( starsim = ss, # can also be the path to the folder, which must be the cloned repo (not from pypi) from_version = 'v1.0.3', # can be any valid git tag or hash to_version = 'v2.2.0', # can be any valid git tag or hash model = 'openai:gpt-4o', # use aisuite provider:model syntax source = '/path/to/your/code/folder', # folder with the code to migrate dest = '/path/to/migrated/folder', # folder to output migrated code into ) Tests uv run --group dev pytest -v test_*.py","title":"Home"},{"location":"#aimigrate","text":"AIMigrate helps migrate code to maintain compatability when one of your dependency packackages changes","title":"AIMigrate"},{"location":"#installation","text":"pip install aimigrate","title":"Installation"},{"location":"#configure-llm-provider","text":"AIMigrate is compatabile with openai, gemini, and anthropic models. To use these tools you will need an API key. For Gemini, get your API key from: https://aistudio.google.com/apikey For OpenAI, get your API key from: https://platform.openai.com/settings/organization/api-keys For Anthropic, get your API key from: https://www.anthropic.com/api Once you have these keys, we recommend using python-dotenv for managing your keys. Store them as environment variables GEMINI_API_KEY , OPENAI_API_KEY , or ANTHROPIC_API_KEY respective. Running open weight (i.e., local) models : You can also use ollama to run models locally. To start open a terminal run ollama serve . If it is your first time running the model you'll need to pull it first (e.g., ollama run llama3 ). You will likely need to increase the context window . DO NOT UNDER ANY CIRCUMSTANCE SHARE OR UPLOAD TO GITHUB YOUR API KEY!","title":"Configure LLM Provider"},{"location":"#usage","text":"Let's say we have a project Zombiesim that we want to migrate from Starsim v1 (v1.0.3) to v2 (v2.2.0). Typical usage is to migrate all the files in a folder to a new folder: import starsim as ss import aimigrate as aim aim.migrate( starsim = ss, # can also be the path to the folder, which must be the cloned repo (not from pypi) from_version = 'v1.0.3', # can be any valid git tag or hash to_version = 'v2.2.0', # can be any valid git tag or hash model = 'openai:gpt-4o', # use aisuite provider:model syntax source = '/path/to/your/code/folder', # folder with the code to migrate dest = '/path/to/migrated/folder', # folder to output migrated code into )","title":"Usage"},{"location":"#tests","text":"uv run --group dev pytest -v test_*.py","title":"Tests"},{"location":"autoapi/summary/","text":"aimigrate Index chat code files migrate_core migrate_diff migrate_oob migrate_repo migration paths utils version","title":"Summary"},{"location":"autoapi/aimigrate/","text":"ClassVisitor Bases: NodeVisitor A visitor class that collects information about class definitions in an AST (Abstract Syntax Tree). Example usage :: script = ''' class MyClass: def method(self): pass ''' tree = ast.parse(script) visitor = ClassVisitor() visitor.visit(tree) print(visitor.classes) # Output: [{'name': 'MyClass', 'bases': [], 'methods': ['method'], 'lineno': 2, 'end_lineno': 4}] Source code in aimigrate/code.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class ClassVisitor ( ast . NodeVisitor ): \"\"\" A visitor class that collects information about class definitions in an AST (Abstract Syntax Tree). **Example usage**:: script = ''' class MyClass: def method(self): pass ''' tree = ast.parse(script) visitor = ClassVisitor() visitor.visit(tree) print(visitor.classes) # Output: [{'name': 'MyClass', 'bases': [], 'methods': ['method'], 'lineno': 2, 'end_lineno': 4}] \"\"\" def __init__ ( self ): self . classes = [] def visit_ClassDef ( self , node ): if isinstance ( node , ast . ClassDef ): # Collect class details class_info = sc . objdict ( { \"name\" : node . name , \"bases\" : [ base . id if isinstance ( base , ast . Name ) else ast . dump ( base ) for base in node . bases ], \"methods\" : [ n . name for n in node . body if isinstance ( n , ast . FunctionDef ) ], \"lineno\" : node . lineno , \"end_lineno\" : getattr ( node , \"end_lineno\" , None ), # Python 3.8+ } ) self . classes . append ( class_info ) self . generic_visit ( node ) # Continue visiting child nodes CoreCodeFile Bases: prettyobj A class to hold the original and migrated code Source code in aimigrate/migrate_core.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class CoreCodeFile ( sc . prettyobj ): \"\"\" A class to hold the original and migrated code \"\"\" def __init__ ( self , source , dest , file , process = True ): self . source = source self . dest = dest self . file = file self . python_code = None self . orig_str = None self . prompt = None self . chatter = None self . n_tokens = None self . response = None self . new_str = None self . error = None self . timer = None self . cost = { \"total\" : 0 , \"prompt\" : 0 , \"completion\" : 0 , \"cost\" : 0 } if process : self . process_code () return def process_code ( self ): \"\"\"Parse the Python file into a string\"\"\" self . python_code = aim . PythonCode ( self . source ) self . orig_str = self . python_code . get_code_string () return def make_prompt ( self , base_prompt , prompt_kwargs , encoder = None ): \"\"\"Create the prompt for the LLM\"\"\" self . prompt = base_prompt . format ( code = self . orig_str , ** prompt_kwargs ) if encoder is not None : self . n_tokens = len ( encoder . encode ( self . prompt ) ) # Not strictly needed, but useful to know else : self . n_tokens = - 1 return def run_query ( self , chatter ): \"\"\"Where everything happens!!\"\"\" with sc . timer ( self . file ) as self . timer : self . response = chatter ( self . prompt ) return self . response def parse_response ( self ): \"\"\"Extract code from the response object\"\"\" result_string = self . response match_patterns = [ r \"```python(.*?)```\" , r \"```(.*?)```\" ] for match_pattern in match_patterns : code_match = re . compile ( match_pattern , re . DOTALL ) . search ( result_string ) if code_match : break if code_match : self . new_str = code_match . group ( 1 ) else : self . new_str = result_string return def run ( self , chatter , save = True ): \"\"\"Run the migration, using the supplied LLM (chatter)\"\"\" self . run_query ( chatter ) self . parse_response () if save : self . save () return self . response def save ( self ): \"\"\"Write to file\"\"\" sc . makefilepath ( self . dest , makedirs = True ) sc . savetext ( self . dest , self . new_str ) return make_prompt ( base_prompt , prompt_kwargs , encoder = None ) Create the prompt for the LLM Source code in aimigrate/migrate_core.py 146 147 148 149 150 151 152 153 154 155 def make_prompt ( self , base_prompt , prompt_kwargs , encoder = None ): \"\"\"Create the prompt for the LLM\"\"\" self . prompt = base_prompt . format ( code = self . orig_str , ** prompt_kwargs ) if encoder is not None : self . n_tokens = len ( encoder . encode ( self . prompt ) ) # Not strictly needed, but useful to know else : self . n_tokens = - 1 return parse_response () Extract code from the response object Source code in aimigrate/migrate_core.py 163 164 165 166 167 168 169 170 171 172 173 174 175 def parse_response ( self ): \"\"\"Extract code from the response object\"\"\" result_string = self . response match_patterns = [ r \"```python(.*?)```\" , r \"```(.*?)```\" ] for match_pattern in match_patterns : code_match = re . compile ( match_pattern , re . DOTALL ) . search ( result_string ) if code_match : break if code_match : self . new_str = code_match . group ( 1 ) else : self . new_str = result_string return process_code () Parse the Python file into a string Source code in aimigrate/migrate_core.py 140 141 142 143 144 def process_code ( self ): \"\"\"Parse the Python file into a string\"\"\" self . python_code = aim . PythonCode ( self . source ) self . orig_str = self . python_code . get_code_string () return run ( chatter , save = True ) Run the migration, using the supplied LLM (chatter) Source code in aimigrate/migrate_core.py 177 178 179 180 181 182 183 def run ( self , chatter , save = True ): \"\"\"Run the migration, using the supplied LLM (chatter)\"\"\" self . run_query ( chatter ) self . parse_response () if save : self . save () return self . response run_query ( chatter ) Where everything happens!! Source code in aimigrate/migrate_core.py 157 158 159 160 161 def run_query ( self , chatter ): \"\"\"Where everything happens!!\"\"\" with sc . timer ( self . file ) as self . timer : self . response = chatter ( self . prompt ) return self . response save () Write to file Source code in aimigrate/migrate_core.py 185 186 187 188 189 def save ( self ): \"\"\"Write to file\"\"\" sc . makefilepath ( self . dest , makedirs = True ) sc . savetext ( self . dest , self . new_str ) return CoreMigrate Bases: prettyobj Source code in aimigrate/migrate_core.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class CoreMigrate ( sc . prettyobj ): def make_code_files ( self ): if self . verbose : self . log ( \"Parsing the files...\" ) if self . files is None : self . files = aim . get_python_files ( self . source_dir ) else : self . files = sc . tolist ( self . files ) if not len ( self . files ): errormsg = ( f \"Could not find any Python files to migrate in { self . source_dir } \" ) raise FileNotFoundError ( errormsg ) for file in self . files : source = self . source_dir / file dest = self . dest_dir / file code_file = aim . CoreCodeFile ( source = source , dest = dest , file = file ) # Actually do the processing self . code_files . append ( code_file ) def log ( self , string , color = \"green\" ): \"\"\"Print if self.verbose is True\"\"\" if self . verbose : printfunc = dict ( default = print , red = sc . printred , green = sc . printgreen , blue = sc . printcyan , yellow = sc . printyellow , )[ color ] printfunc ( string ) return def run_single ( self , code_file ): \"\"\"Where everything happens!!\"\"\" self . log ( f \"Migrating { code_file . file } \" ) try : code_file . run ( self . chatter , save = self . save ) except Exception as E : errormsg = f \"Could not parse { code_file . file } : { E } \" self . errors . append ( errormsg ) raise E if self . die else print ( errormsg ) return def run ( self ): raise NotImplementedError def _run ( self ): \"\"\"Run all steps of the process\"\"\" if self . encoder is None : self . make_encoder () if self . chatter is None : self . make_chatter () self . log ( f \" \\n Starting migration of { self . source_dir } \" , color = \"blue\" ) if self . verbose : self . log ( f \" \\n Migrating { len ( self . files ) } files\" , color = \"blue\" ) self . log ( f \" { sc . newlinejoin ( self . files ) } \" , color = \"default\" ) assert len ( self . code_files ) == len ( self . files ), ( f \"Length of code_files ( { len ( self . code_files ) } ) does not match length of files ( { len ( self . files ) } )\" ) self . timer = sc . timer () if self . parallel : sc . parallelize ( self . run_single , self . code_files , parallelizer = \"thread\" ) else : for code_file in self . code_files : self . run_single ( code_file ) self . timer . toc ( \"Total time\" ) return def make_encoder ( self ): self . log ( \"Creating encoder...\" ) try : self . encoder = tiktoken . encoding_for_model ( self . model ) # encoder (for counting tokens) except KeyError as E : self . log ( f \"Could not create encoder for { self . model } : { E } \" , color = \"yellow\" ) self . encoder = None def make_chatter ( self ): \"\"\"Create the LLM agent\"\"\" self . log ( \"Creating agent...\" ) self . chatter = aim . SimpleQuery ( model = self . model , ** self . model_kw ) return def parse_library ( self ): \"\"\"Extract the right folder for library\"\"\" self . log ( \"Parsing library folder\" ) if isinstance ( self . library , types . ModuleType ): self . library = sc . thispath ( self . library ) . parent self . library = sc . path ( self . library ) if not self . library . is_dir (): errormsg = f \"The library must be supplied as the module or the folder path, not { self . library } \" raise FileNotFoundError ( errormsg ) return _run () Run all steps of the process Source code in aimigrate/migrate_core.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def _run ( self ): \"\"\"Run all steps of the process\"\"\" if self . encoder is None : self . make_encoder () if self . chatter is None : self . make_chatter () self . log ( f \" \\n Starting migration of { self . source_dir } \" , color = \"blue\" ) if self . verbose : self . log ( f \" \\n Migrating { len ( self . files ) } files\" , color = \"blue\" ) self . log ( f \" { sc . newlinejoin ( self . files ) } \" , color = \"default\" ) assert len ( self . code_files ) == len ( self . files ), ( f \"Length of code_files ( { len ( self . code_files ) } ) does not match length of files ( { len ( self . files ) } )\" ) self . timer = sc . timer () if self . parallel : sc . parallelize ( self . run_single , self . code_files , parallelizer = \"thread\" ) else : for code_file in self . code_files : self . run_single ( code_file ) self . timer . toc ( \"Total time\" ) return log ( string , color = 'green' ) Print if self.verbose is True Source code in aimigrate/migrate_core.py 38 39 40 41 42 43 44 45 46 47 48 49 def log ( self , string , color = \"green\" ): \"\"\"Print if self.verbose is True\"\"\" if self . verbose : printfunc = dict ( default = print , red = sc . printred , green = sc . printgreen , blue = sc . printcyan , yellow = sc . printyellow , )[ color ] printfunc ( string ) return make_chatter () Create the LLM agent Source code in aimigrate/migrate_core.py 99 100 101 102 103 def make_chatter ( self ): \"\"\"Create the LLM agent\"\"\" self . log ( \"Creating agent...\" ) self . chatter = aim . SimpleQuery ( model = self . model , ** self . model_kw ) return parse_library () Extract the right folder for library Source code in aimigrate/migrate_core.py 105 106 107 108 109 110 111 112 113 114 def parse_library ( self ): \"\"\"Extract the right folder for library\"\"\" self . log ( \"Parsing library folder\" ) if isinstance ( self . library , types . ModuleType ): self . library = sc . thispath ( self . library ) . parent self . library = sc . path ( self . library ) if not self . library . is_dir (): errormsg = f \"The library must be supplied as the module or the folder path, not { self . library } \" raise FileNotFoundError ( errormsg ) return run_single ( code_file ) Where everything happens!! Source code in aimigrate/migrate_core.py 51 52 53 54 55 56 57 58 59 60 def run_single ( self , code_file ): \"\"\"Where everything happens!!\"\"\" self . log ( f \"Migrating { code_file . file } \" ) try : code_file . run ( self . chatter , save = self . save ) except Exception as E : errormsg = f \"Could not parse { code_file . file } : { E } \" self . errors . append ( errormsg ) raise E if self . die else print ( errormsg ) return GitDiff Bases: prettyobj Parse the git diff Source code in aimigrate/files.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 class GitDiff ( sc . prettyobj ): \"\"\" Parse the git diff \"\"\" def __init__ ( self , file , include_patterns = None , exclude_patterns = None ): self . include_patterns = ( [ \"*.py\" ] if include_patterns is None else include_patterns ) self . exclude_patterns = ( [ \"docs/*\" ] if exclude_patterns is None else exclude_patterns ) self . diffs = self . parse_git_diff ( file , include_patterns = self . include_patterns , exclude_patterns = self . exclude_patterns , ) return def summarize ( self ): \"\"\"Summarize the diffs\"\"\" diffs = self . diffs print ( f \"Number of files found: { len ( diffs ) } \" ) print ( f \"Number of hunks: { sum ([ len ( diff [ 'hunks' ]) for diff in diffs ]) } \" ) print ( f \"Names of files found: { [ diff [ 'file' ] for diff in diffs ] } \" ) return def get_diff_string ( self , file = None ): \"\"\"Get the diff string (optionally for a file)\"\"\" if file is not None : return \"\" . join ( [ \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs if diff [ \"file\" ] == file ] ) else : return \"\" . join ( [ \" \\n File:\" + diff [ \"file\" ] + \" \\n :\" + \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs ] ) def count_all_tokens ( self , model = \"gpt-4o\" ): \"\"\"Count the total number of tokens in the diff (all hunks)\"\"\" try : encoding = tiktoken . encoding_for_model ( model ) return len ( encoding . encode ( self . get_diff_string ())) except KeyError : return - 1 def print_file_hunks ( self , file ): \"\"\" Print all hunks for a file \"\"\" for diff in self . diffs : if diff . file == file : print ( f \"All hunks for { file } \" ) for hunk in diff . hunks : print ( f \" { hunk } \\n \" ) return @staticmethod def parse_git_diff ( file , include_patterns = None , exclude_patterns = None ): \"\"\" Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Args: diff_file_path (str): The path to the diff file. patterns (list of str, optional): A list of patterns to filter the files. Returns: list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. \"\"\" diffs = [] current_file = None current_hunks = [] # If empty string return if file == \"\" : return diffs # In case a filename is provided instead of the file contents if not isinstance ( file , str ) or \" \\n \" not in file : with open ( file , \"r\" ) as f : file = f . readlines () for line in file . splitlines (): # Match lines that indicate a new file's diff starts file_match = re . match ( r \"^diff --git a/(.+?) b/\" , line ) hunk_start_match = re . match ( r \"^@@\" , line ) if file_match : # Save the previous file and hunks if applicable if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks }) ) # Start a new file and check if it matches any pattern current_file = file_match . group ( 1 ) if include_patterns and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in include_patterns ): # Skip files that don't match any include pattern current_file = None current_hunks = [] elif exclude_patterns and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in exclude_patterns ): # Skip files that match any exclude pattern current_file = None current_hunks = [] else : current_hunks = [] # Reset hunks for the new file elif hunk_start_match : # If there's an ongoing hunk, save it as a new entry before starting a new hunk if current_file and current_hunks and current_hunks [ - 1 ]: current_hunks . append ( \"\" . join ( current_hunks . pop ())) # Start a new hunk for the current file current_hunks . append ([ line . rstrip () + \" \\n \" ]) elif current_hunks : # Append line to current hunk if in a hunk current_hunks [ - 1 ] . append ( line . rstrip () + \" \\n \" ) # Save the last file and hunks if present if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks })) return diffs count_all_tokens ( model = 'gpt-4o' ) Count the total number of tokens in the diff (all hunks) Source code in aimigrate/files.py 114 115 116 117 118 119 120 def count_all_tokens ( self , model = \"gpt-4o\" ): \"\"\"Count the total number of tokens in the diff (all hunks)\"\"\" try : encoding = tiktoken . encoding_for_model ( model ) return len ( encoding . encode ( self . get_diff_string ())) except KeyError : return - 1 get_diff_string ( file = None ) Get the diff string (optionally for a file) Source code in aimigrate/files.py 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_diff_string ( self , file = None ): \"\"\"Get the diff string (optionally for a file)\"\"\" if file is not None : return \"\" . join ( [ \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs if diff [ \"file\" ] == file ] ) else : return \"\" . join ( [ \" \\n File:\" + diff [ \"file\" ] + \" \\n :\" + \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs ] ) parse_git_diff ( file , include_patterns = None , exclude_patterns = None ) staticmethod Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Parameters: Name Type Description Default diff_file_path str The path to the diff file. required patterns list of str A list of patterns to filter the files. required Returns: Type Description list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. Source code in aimigrate/files.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 @staticmethod def parse_git_diff ( file , include_patterns = None , exclude_patterns = None ): \"\"\" Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Args: diff_file_path (str): The path to the diff file. patterns (list of str, optional): A list of patterns to filter the files. Returns: list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. \"\"\" diffs = [] current_file = None current_hunks = [] # If empty string return if file == \"\" : return diffs # In case a filename is provided instead of the file contents if not isinstance ( file , str ) or \" \\n \" not in file : with open ( file , \"r\" ) as f : file = f . readlines () for line in file . splitlines (): # Match lines that indicate a new file's diff starts file_match = re . match ( r \"^diff --git a/(.+?) b/\" , line ) hunk_start_match = re . match ( r \"^@@\" , line ) if file_match : # Save the previous file and hunks if applicable if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks }) ) # Start a new file and check if it matches any pattern current_file = file_match . group ( 1 ) if include_patterns and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in include_patterns ): # Skip files that don't match any include pattern current_file = None current_hunks = [] elif exclude_patterns and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in exclude_patterns ): # Skip files that match any exclude pattern current_file = None current_hunks = [] else : current_hunks = [] # Reset hunks for the new file elif hunk_start_match : # If there's an ongoing hunk, save it as a new entry before starting a new hunk if current_file and current_hunks and current_hunks [ - 1 ]: current_hunks . append ( \"\" . join ( current_hunks . pop ())) # Start a new hunk for the current file current_hunks . append ([ line . rstrip () + \" \\n \" ]) elif current_hunks : # Append line to current hunk if in a hunk current_hunks [ - 1 ] . append ( line . rstrip () + \" \\n \" ) # Save the last file and hunks if present if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks })) return diffs print_file_hunks ( file ) Print all hunks for a file Source code in aimigrate/files.py 122 123 124 125 126 127 128 129 130 131 def print_file_hunks ( self , file ): \"\"\" Print all hunks for a file \"\"\" for diff in self . diffs : if diff . file == file : print ( f \"All hunks for { file } \" ) for hunk in diff . hunks : print ( f \" { hunk } \\n \" ) return summarize () Summarize the diffs Source code in aimigrate/files.py 92 93 94 95 96 97 98 def summarize ( self ): \"\"\"Summarize the diffs\"\"\" diffs = self . diffs print ( f \"Number of files found: { len ( diffs ) } \" ) print ( f \"Number of hunks: { sum ([ len ( diff [ 'hunks' ]) for diff in diffs ]) } \" ) print ( f \"Names of files found: { [ diff [ 'file' ] for diff in diffs ] } \" ) return MethodVisitor Bases: NodeVisitor A visitor class that collects information about methods in a specific class within an Abstract Syntax Tree (AST). Example usage :: script = ''' class MyClass: def method1(self): pass def method2(self): return \"Hello\" ''' tree = ast.parse(script) visitor = MethodVisitor('MyClass') visitor.visit(tree) print(visitor.methods) # Output: # [{'name': 'method1', 'lineno': 3, 'end_lineno': 4}, # {'name': 'method2', 'lineno': 6, 'end_lineno': 7}] Source code in aimigrate/code.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class MethodVisitor ( ast . NodeVisitor ): \"\"\" A visitor class that collects information about methods in a specific class within an Abstract Syntax Tree (AST). **Example usage**:: script = ''' class MyClass: def method1(self): pass def method2(self): return \"Hello\" ''' tree = ast.parse(script) visitor = MethodVisitor('MyClass') visitor.visit(tree) print(visitor.methods) # Output: # [{'name': 'method1', 'lineno': 3, 'end_lineno': 4}, # {'name': 'method2', 'lineno': 6, 'end_lineno': 7}] \"\"\" def __init__ ( self ): self . methods = [] def visit_ClassDef ( self , node ): # Visit each method (FunctionDef) in the class body for child in node . body : if isinstance ( child , ast . FunctionDef ): method_info = sc . objdict ( { \"name\" : child . name , \"lineno\" : child . lineno , \"end_lineno\" : getattr ( child , \"end_lineno\" , None ), # Python 3.8+ } ) self . methods . append ( method_info ) # Continue visiting child nodes self . generic_visit ( node ) MigrateDiff Bases: CoreMigrate Handle all steps of code migration Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / path / module the library to base the migration on (i.e., Starsim or the path to it) None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None diff_file str if provided, load this diff file instead of computing it via library/v_from/v_to, i.e. git diff v1.0.3 v2.2.0 > diff_file None diff str if provided, use this diff rather than loading it from file None model str the LLM to use None model_kw dict any keywords to pass to the model None include list the list of files to include from the diff None exclude list the list of files to not include from the diff None base_prompt str the prompt template that will be populated with the diff and file information None diff_speed bool whether to use include/exclude to choose files for diff construction. (default False) False filter list if diff_speed=True, a list of file extensions to include when constructing the diff (default [\".py\"]) None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import starsim as ss import starsim_ai as ssai M = aim.Migrate( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) v_from = 'v1.0.3', # can be any valid git tag or hash v_to = 'v2.2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_diff.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class MigrateDiff ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/path/module): the library to base the migration on (i.e., Starsim or the path to it) v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in diff_file (str): if provided, load this diff file instead of computing it via library/v_from/v_to, i.e. git diff v1.0.3 v2.2.0 > diff_file diff (str): if provided, use this diff rather than loading it from file model (str): the LLM to use model_kw (dict): any keywords to pass to the model include (list): the list of files to include from the diff exclude (list): the list of files to not include from the diff base_prompt (str): the prompt template that will be populated with the diff and file information diff_speed (bool): whether to use include/exclude to choose files for diff construction. (default False) filter (list): if diff_speed=True, a list of file extensions to include when constructing the diff (default [\".py\"]) parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import starsim as ss import starsim_ai as ssai M = aim.Migrate( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) v_from = 'v1.0.3', # can be any valid git tag or hash v_to = 'v2.2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , # Migration settings include = None , exclude = None , diff_file = None , diff = None , patience = None , diff_speed = False , filter = None , # Diff settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run settings # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . include = sc . ifelse ( include , DEFAULT_INCLUDE ) self . exclude = sc . ifelse ( exclude , DEFAULT_EXCLUDE ) self . diff_file = diff_file self . diff = diff self . patience = patience self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . filter = sc . ifelse ( filter , [ \".py\" ]) self . diff_speed = diff_speed self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] # Optionally run if run : self . run () return def make_diff ( self ): self . log ( \"Making the diff\" ) if self . diff : return elif self . diff_file : with open ( self . diff_file , \"r\" ) as f : self . diff = f . readlines () else : self . parse_library () if self . diff_speed : self . diff = \"\" with aim . utils . TemporaryDirectoryChange ( self . library ): # check that the revisions are good assert not sc . runcommand ( f \"git rev-parse --verify { self . v_from } \" ) . startswith ( \"fatal\" ), \"Invalid v_from\" assert not sc . runcommand ( f \"git rev-parse --verify { self . v_to } \" ) . startswith ( \"fatal\" ), \"Invalid v_to\" # get current git commit current_head = sc . runcommand ( \"git rev-parse HEAD\" ) # get the files in the library library_files = aim . files . get_python_files ( self . library , gitignore = True , filter = self . filter ) assert not sc . runcommand ( f \"git checkout { current_head } \" ) . startswith ( \"error\" ), \"Error checking out previous commit\" # get the diff for each file that passes the include/exclude for current_file in library_files : if self . include and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . include ): continue elif self . exclude and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . exclude ): continue else : self . diff += sc . runcommand ( f \"git diff { '--patience ' if self . patience else '' }{ self . v_from } { self . v_to } -- { current_file } \" ) else : with aim . utils . TemporaryDirectoryChange ( self . library ): assert not sc . runcommand ( f \"git rev-parse --verify { self . v_from } \" ) . startswith ( \"fatal\" ), \"Invalid v_from\" assert not sc . runcommand ( f \"git rev-parse --verify { self . v_to } \" ) . startswith ( \"fatal\" ), \"Invalid v_to\" self . diff = sc . runcommand ( f \"git diff { self . v_from } { self . v_to } \" ) def parse_diff ( self ): self . log ( \"Parsing the diff\" ) self . git_diff = aim . GitDiff ( self . diff , include_patterns = self . include , exclude_patterns = self . exclude ) self . git_diff . summarize () # summarize self . n_tokens = self . git_diff . count_all_tokens ( model = self . model ) # NB: not implemented for all models if self . verbose and ( self . n_tokens > - 1 ): print ( f \"Number of tokens in the diff: { self . n_tokens } \" ) def make_prompts ( self ): diff_string = self . git_diff . get_diff_string () for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . stem , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"diff\" : diff_string , }, encoder = self . encoder , ) return def run ( self ): # construct the diff self . make_diff () # parse the diff self . parse_diff () # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run () MigrateOOB Bases: CoreMigrate Handle all steps of code migration using an LLM \"out of the box\". Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / module the library to base the migration on None library_alias str string to use as the alias for the library None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None model str the LLM to use None model_kw dict any keywords to pass to the model None base_prompt str the prompt template that will be populated with the diff and file information None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import aimigrate as aim M = aim.MigrateOOB( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the name of the library as a string (e.g., starsim) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # use a git tag v_to = 'v2.0', # use a git tag model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_oob.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class MigrateOOB ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration using an LLM \"out of the box\". Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/module): the library to base the migration on library_alias (str): string to use as the alias for the library v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in model (str): the LLM to use model_kw (dict): any keywords to pass to the model base_prompt (str): the prompt template that will be populated with the diff and file information parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import aimigrate as aim M = aim.MigrateOOB( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the name of the library as a string (e.g., starsim) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # use a git tag v_to = 'v2.0', # use a git tag model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , # Migration settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run setting # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] assert isinstance ( self . library , ( str , types . ModuleType )), ( \"Library must be a string or module\" ) # Optionally run if run : self . run () return def make_prompts ( self ): self . make_encoder () for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . __name__ if hasattr ( self . library , \"__name__\" ) else self . library , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"v_from\" : self . v_from , \"v_to\" : self . v_to , }, encoder = self . encoder , ) def run ( self ): # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run () MigrateRepo Bases: CoreMigrate Handle all steps of code migration using files (e.g., code) from the target library as context. Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / path / module the library to base the migration on (i.e., the path to a git repository) None library_alias str string to use as the alias for the library None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None model str the LLM to use None model_kw dict any keywords to pass to the model None include list the list of files to include from the diff None exclude list the list of files to not include from the diff None base_prompt str the prompt template that will be populated with the diff and file information None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import aimigrate as aim M = aim.MigrateRepo( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # can be any valid git tag or hash v_to = 'v2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_repo.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class MigrateRepo ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration using files (e.g., code) from the target library as context. Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/path/module): the library to base the migration on (i.e., the path to a git repository) library_alias (str): string to use as the alias for the library v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in model (str): the LLM to use model_kw (dict): any keywords to pass to the model include (list): the list of files to include from the diff exclude (list): the list of files to not include from the diff base_prompt (str): the prompt template that will be populated with the diff and file information parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import aimigrate as aim M = aim.MigrateRepo( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # can be any valid git tag or hash v_to = 'v2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , filter = None , # Migration settings include = None , exclude = None , # Library settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run settings # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . include = sc . ifelse ( include , DEFAULT_INCLUDE ) self . exclude = sc . ifelse ( exclude , DEFAULT_EXCLUDE ) self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . filter = sc . ifelse ( filter , [ \".py\" ]) self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] # Optionally run if run : self . run () return def run ( self ): self . make_encoder () # get the repository files self . get_repo_files () # parse the repository files self . parse_repo_files () # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run () def get_repo_files ( self ): self . log ( \"Getting the repository files\" ) self . parse_library () self . repo_files = [] with aim . utils . TemporaryDirectoryChange ( self . library ): # get current git commit current_head = sc . runcommand ( \"git rev-parse HEAD\" ) assert not sc . runcommand ( f \"git checkout { self . v_to } \" ) . startswith ( \"error\" ), ( \"Invalid v_to\" ) all_repo_files = aim . files . get_python_files ( self . library , gitignore = True , filter = self . filter ) assert not sc . runcommand ( f \"git checkout { current_head } \" ) . startswith ( \"error\" ), \"Error checking out previous commit\" for current_file in all_repo_files : if self . include and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . include ): continue elif self . exclude and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . exclude ): continue else : self . repo_files . append ( current_file ) def parse_repo_files ( self ): self . log ( \"Parsing repository files\" ) self . repo_string = \"\" for current_file in self . repo_files : with open ( self . library / current_file , \"r\" ) as f : self . repo_string += \"\"\"File: {file_name} \\n ''' \\n {code} ''' \\n \"\"\" . format ( file_name = current_file , code = f . read () ) if self . encoder is not None : self . n_tokens = len ( self . encoder . encode ( self . repo_string )) else : self . n_tokens = - 1 if self . verbose and ( self . n_tokens > - 1 ): print ( f \"Number of tokens in repository files: { self . n_tokens } \" ) return def make_prompts ( self ): for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . stem , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"library_code\" : self . repo_string , }, encoder = self . encoder , ) return PythonCode Bases: prettyobj Parse Python code into classes and methods Source code in aimigrate/files.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class PythonCode ( sc . prettyobj ): \"\"\" Parse Python code into classes and methods \"\"\" def __init__ ( self , file_path : str ): self . code_lines = None self . classes = None self . from_file ( file_path ) self . set_classes () return def from_file ( self , file_path ): with open ( file_path , \"r\" ) as file : self . code_lines = file . readlines () return def get_code_string ( self ): return \"\" . join ( self . code_lines ) def set_classes ( self ): tree = ast . parse ( \"\" . join ( self . code_lines )) visitor = aim . ClassVisitor () visitor . visit ( tree ) self . classes = visitor . classes return def get_class_methods ( self , name ): # BUG: how does this work for methods with the same name? for c in self . classes : if c [ \"name\" ] == name : class_code_list = self . code_lines [ c [ \"lineno\" ] - 1 : c [ \"end_lineno\" ] + 1 ] tree = ast . parse ( \"\" . join ( class_code_list )) visitor = aim . MethodVisitor () visitor . visit ( tree ) return class_code_list , visitor raise ValueError ( f \"Class { name } not found\" ) def get_class_string ( self , name , methods_flag = False ): if methods_flag : code_lines , visitor = self . get_class_methods ( name ) res = {} for m in visitor . methods : res [ m [ \"name\" ]] = \"\" . join ( code_lines [ m [ \"lineno\" ] - 1 : m [ \"end_lineno\" ] + 1 ] ) return res else : for c in self . classes : if c [ \"name\" ] == name : return \"\" . join ( self . code_lines [ c [ \"lineno\" ] - 1 : c [ \"end_lineno\" ] + 1 ] ) SimpleQuery A simple query interface to interact with an AI model. Source code in aimigrate/chat.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class SimpleQuery (): \"\"\" A simple query interface to interact with an AI model. \"\"\" def __init__ ( self , model = \"openai:gpt-3.5-turbo\" , ** kwargs ): self . model = model self . client = ai . Client () self . kwargs = { 'temperature' : 0.7 } | kwargs def __call__ ( self , user_input ): return self . chat ( user_input ) def chat ( self , user_input ): messages = [ { \"role\" : \"system\" , \"content\" : \"You are a helpful software engineer.\" }, { \"role\" : \"user\" , \"content\" : user_input }, ] response = self . client . chat . completions . create ( model = self . model , messages = messages , ** self . kwargs ) return response . choices [ 0 ] . message . content get_python_files ( source_dir , gitignore = False , filter = [ '.py' ]) Recursively retrieves all Python files from the specified directory. Parameters: Name Type Description Default source_dir str The root directory to search for Python files. required gitignore bool Whether to use the .gitignore file to filter files. False Returns: Name Type Description list A list of file paths to Python files found within the directory. Source code in aimigrate/files.py 15 16 17 18 19 20 21 22 23 24 25 26 def get_python_files ( source_dir , gitignore = False , filter = [ \".py\" ]): \"\"\" Recursively retrieves all Python files from the specified directory. Args: source_dir (str): The root directory to search for Python files. gitignore (bool, optional): Whether to use the .gitignore file to filter files. Returns: list: A list of file paths to Python files found within the directory. \"\"\" return get_repository_files ( source_dir , gitignore = gitignore , filter = filter ) get_repository_files ( source_dir , gitignore = False , filter = [ '.py' ]) Recursively retrieves all files from the specified directory. Parameters: Name Type Description Default source_dir str The root directory to search for Python files. required gitignore bool Whether to use the .gitignore file to filter files. False filter list of str A list of file suffixes to filter the files ['.py'] Returns: Name Type Description list A list of file paths to files found within the directory. Source code in aimigrate/files.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def get_repository_files ( source_dir , gitignore = False , filter = [ \".py\" ]): \"\"\" Recursively retrieves all files from the specified directory. Args: source_dir (str): The root directory to search for Python files. gitignore (bool, optional): Whether to use the .gitignore file to filter files. filter (list of str, optional): A list of file suffixes to filter the files Returns: list: A list of file paths to files found within the directory. \"\"\" if isinstance ( source_dir , str ): source_dir = sc . path ( source_dir ) python_files = [] if gitignore : with aim . utils . TemporaryDirectoryChange ( source_dir ): files = subprocess . check_output ( \"git ls-files\" , shell = True ) . splitlines () for file in files : decoded = file . decode () if filter is not None : for suffix in filter : if decoded . endswith ( suffix ): python_files . append ( decoded ) break else : python_files . append ( decoded ) python_files = [ sc . path ( files ) for files in python_files ] else : for root , _ , files in os . walk ( source_dir ): for file in files : if filter is not None : for suffix in filter : if file . endswith ( suffix ): python_files . append ( os . path . join ( root , file )) else : python_files . append ( os . path . join ( root , file )) python_files = [ sc . path ( file ) . relative_to ( source_dir ) for file in python_files ] return python_files migrate ( * args , ** kwargs ) Helper function for the Migrate class Source code in aimigrate/migration.py 15 16 17 18 19 def migrate ( * args , ** kwargs ): \"\"\"Helper function for the Migrate class\"\"\" mig = Migrate ( * args , ** kwargs ) mig . run () return mig","title":"Index"},{"location":"autoapi/aimigrate/#aimigrate.ClassVisitor","text":"Bases: NodeVisitor A visitor class that collects information about class definitions in an AST (Abstract Syntax Tree). Example usage :: script = ''' class MyClass: def method(self): pass ''' tree = ast.parse(script) visitor = ClassVisitor() visitor.visit(tree) print(visitor.classes) # Output: [{'name': 'MyClass', 'bases': [], 'methods': ['method'], 'lineno': 2, 'end_lineno': 4}] Source code in aimigrate/code.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class ClassVisitor ( ast . NodeVisitor ): \"\"\" A visitor class that collects information about class definitions in an AST (Abstract Syntax Tree). **Example usage**:: script = ''' class MyClass: def method(self): pass ''' tree = ast.parse(script) visitor = ClassVisitor() visitor.visit(tree) print(visitor.classes) # Output: [{'name': 'MyClass', 'bases': [], 'methods': ['method'], 'lineno': 2, 'end_lineno': 4}] \"\"\" def __init__ ( self ): self . classes = [] def visit_ClassDef ( self , node ): if isinstance ( node , ast . ClassDef ): # Collect class details class_info = sc . objdict ( { \"name\" : node . name , \"bases\" : [ base . id if isinstance ( base , ast . Name ) else ast . dump ( base ) for base in node . bases ], \"methods\" : [ n . name for n in node . body if isinstance ( n , ast . FunctionDef ) ], \"lineno\" : node . lineno , \"end_lineno\" : getattr ( node , \"end_lineno\" , None ), # Python 3.8+ } ) self . classes . append ( class_info ) self . generic_visit ( node ) # Continue visiting child nodes","title":"ClassVisitor"},{"location":"autoapi/aimigrate/#aimigrate.CoreCodeFile","text":"Bases: prettyobj A class to hold the original and migrated code Source code in aimigrate/migrate_core.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class CoreCodeFile ( sc . prettyobj ): \"\"\" A class to hold the original and migrated code \"\"\" def __init__ ( self , source , dest , file , process = True ): self . source = source self . dest = dest self . file = file self . python_code = None self . orig_str = None self . prompt = None self . chatter = None self . n_tokens = None self . response = None self . new_str = None self . error = None self . timer = None self . cost = { \"total\" : 0 , \"prompt\" : 0 , \"completion\" : 0 , \"cost\" : 0 } if process : self . process_code () return def process_code ( self ): \"\"\"Parse the Python file into a string\"\"\" self . python_code = aim . PythonCode ( self . source ) self . orig_str = self . python_code . get_code_string () return def make_prompt ( self , base_prompt , prompt_kwargs , encoder = None ): \"\"\"Create the prompt for the LLM\"\"\" self . prompt = base_prompt . format ( code = self . orig_str , ** prompt_kwargs ) if encoder is not None : self . n_tokens = len ( encoder . encode ( self . prompt ) ) # Not strictly needed, but useful to know else : self . n_tokens = - 1 return def run_query ( self , chatter ): \"\"\"Where everything happens!!\"\"\" with sc . timer ( self . file ) as self . timer : self . response = chatter ( self . prompt ) return self . response def parse_response ( self ): \"\"\"Extract code from the response object\"\"\" result_string = self . response match_patterns = [ r \"```python(.*?)```\" , r \"```(.*?)```\" ] for match_pattern in match_patterns : code_match = re . compile ( match_pattern , re . DOTALL ) . search ( result_string ) if code_match : break if code_match : self . new_str = code_match . group ( 1 ) else : self . new_str = result_string return def run ( self , chatter , save = True ): \"\"\"Run the migration, using the supplied LLM (chatter)\"\"\" self . run_query ( chatter ) self . parse_response () if save : self . save () return self . response def save ( self ): \"\"\"Write to file\"\"\" sc . makefilepath ( self . dest , makedirs = True ) sc . savetext ( self . dest , self . new_str ) return","title":"CoreCodeFile"},{"location":"autoapi/aimigrate/#aimigrate.CoreCodeFile.make_prompt","text":"Create the prompt for the LLM Source code in aimigrate/migrate_core.py 146 147 148 149 150 151 152 153 154 155 def make_prompt ( self , base_prompt , prompt_kwargs , encoder = None ): \"\"\"Create the prompt for the LLM\"\"\" self . prompt = base_prompt . format ( code = self . orig_str , ** prompt_kwargs ) if encoder is not None : self . n_tokens = len ( encoder . encode ( self . prompt ) ) # Not strictly needed, but useful to know else : self . n_tokens = - 1 return","title":"make_prompt"},{"location":"autoapi/aimigrate/#aimigrate.CoreCodeFile.parse_response","text":"Extract code from the response object Source code in aimigrate/migrate_core.py 163 164 165 166 167 168 169 170 171 172 173 174 175 def parse_response ( self ): \"\"\"Extract code from the response object\"\"\" result_string = self . response match_patterns = [ r \"```python(.*?)```\" , r \"```(.*?)```\" ] for match_pattern in match_patterns : code_match = re . compile ( match_pattern , re . DOTALL ) . search ( result_string ) if code_match : break if code_match : self . new_str = code_match . group ( 1 ) else : self . new_str = result_string return","title":"parse_response"},{"location":"autoapi/aimigrate/#aimigrate.CoreCodeFile.process_code","text":"Parse the Python file into a string Source code in aimigrate/migrate_core.py 140 141 142 143 144 def process_code ( self ): \"\"\"Parse the Python file into a string\"\"\" self . python_code = aim . PythonCode ( self . source ) self . orig_str = self . python_code . get_code_string () return","title":"process_code"},{"location":"autoapi/aimigrate/#aimigrate.CoreCodeFile.run","text":"Run the migration, using the supplied LLM (chatter) Source code in aimigrate/migrate_core.py 177 178 179 180 181 182 183 def run ( self , chatter , save = True ): \"\"\"Run the migration, using the supplied LLM (chatter)\"\"\" self . run_query ( chatter ) self . parse_response () if save : self . save () return self . response","title":"run"},{"location":"autoapi/aimigrate/#aimigrate.CoreCodeFile.run_query","text":"Where everything happens!! Source code in aimigrate/migrate_core.py 157 158 159 160 161 def run_query ( self , chatter ): \"\"\"Where everything happens!!\"\"\" with sc . timer ( self . file ) as self . timer : self . response = chatter ( self . prompt ) return self . response","title":"run_query"},{"location":"autoapi/aimigrate/#aimigrate.CoreCodeFile.save","text":"Write to file Source code in aimigrate/migrate_core.py 185 186 187 188 189 def save ( self ): \"\"\"Write to file\"\"\" sc . makefilepath ( self . dest , makedirs = True ) sc . savetext ( self . dest , self . new_str ) return","title":"save"},{"location":"autoapi/aimigrate/#aimigrate.CoreMigrate","text":"Bases: prettyobj Source code in aimigrate/migrate_core.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class CoreMigrate ( sc . prettyobj ): def make_code_files ( self ): if self . verbose : self . log ( \"Parsing the files...\" ) if self . files is None : self . files = aim . get_python_files ( self . source_dir ) else : self . files = sc . tolist ( self . files ) if not len ( self . files ): errormsg = ( f \"Could not find any Python files to migrate in { self . source_dir } \" ) raise FileNotFoundError ( errormsg ) for file in self . files : source = self . source_dir / file dest = self . dest_dir / file code_file = aim . CoreCodeFile ( source = source , dest = dest , file = file ) # Actually do the processing self . code_files . append ( code_file ) def log ( self , string , color = \"green\" ): \"\"\"Print if self.verbose is True\"\"\" if self . verbose : printfunc = dict ( default = print , red = sc . printred , green = sc . printgreen , blue = sc . printcyan , yellow = sc . printyellow , )[ color ] printfunc ( string ) return def run_single ( self , code_file ): \"\"\"Where everything happens!!\"\"\" self . log ( f \"Migrating { code_file . file } \" ) try : code_file . run ( self . chatter , save = self . save ) except Exception as E : errormsg = f \"Could not parse { code_file . file } : { E } \" self . errors . append ( errormsg ) raise E if self . die else print ( errormsg ) return def run ( self ): raise NotImplementedError def _run ( self ): \"\"\"Run all steps of the process\"\"\" if self . encoder is None : self . make_encoder () if self . chatter is None : self . make_chatter () self . log ( f \" \\n Starting migration of { self . source_dir } \" , color = \"blue\" ) if self . verbose : self . log ( f \" \\n Migrating { len ( self . files ) } files\" , color = \"blue\" ) self . log ( f \" { sc . newlinejoin ( self . files ) } \" , color = \"default\" ) assert len ( self . code_files ) == len ( self . files ), ( f \"Length of code_files ( { len ( self . code_files ) } ) does not match length of files ( { len ( self . files ) } )\" ) self . timer = sc . timer () if self . parallel : sc . parallelize ( self . run_single , self . code_files , parallelizer = \"thread\" ) else : for code_file in self . code_files : self . run_single ( code_file ) self . timer . toc ( \"Total time\" ) return def make_encoder ( self ): self . log ( \"Creating encoder...\" ) try : self . encoder = tiktoken . encoding_for_model ( self . model ) # encoder (for counting tokens) except KeyError as E : self . log ( f \"Could not create encoder for { self . model } : { E } \" , color = \"yellow\" ) self . encoder = None def make_chatter ( self ): \"\"\"Create the LLM agent\"\"\" self . log ( \"Creating agent...\" ) self . chatter = aim . SimpleQuery ( model = self . model , ** self . model_kw ) return def parse_library ( self ): \"\"\"Extract the right folder for library\"\"\" self . log ( \"Parsing library folder\" ) if isinstance ( self . library , types . ModuleType ): self . library = sc . thispath ( self . library ) . parent self . library = sc . path ( self . library ) if not self . library . is_dir (): errormsg = f \"The library must be supplied as the module or the folder path, not { self . library } \" raise FileNotFoundError ( errormsg ) return","title":"CoreMigrate"},{"location":"autoapi/aimigrate/#aimigrate.CoreMigrate._run","text":"Run all steps of the process Source code in aimigrate/migrate_core.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def _run ( self ): \"\"\"Run all steps of the process\"\"\" if self . encoder is None : self . make_encoder () if self . chatter is None : self . make_chatter () self . log ( f \" \\n Starting migration of { self . source_dir } \" , color = \"blue\" ) if self . verbose : self . log ( f \" \\n Migrating { len ( self . files ) } files\" , color = \"blue\" ) self . log ( f \" { sc . newlinejoin ( self . files ) } \" , color = \"default\" ) assert len ( self . code_files ) == len ( self . files ), ( f \"Length of code_files ( { len ( self . code_files ) } ) does not match length of files ( { len ( self . files ) } )\" ) self . timer = sc . timer () if self . parallel : sc . parallelize ( self . run_single , self . code_files , parallelizer = \"thread\" ) else : for code_file in self . code_files : self . run_single ( code_file ) self . timer . toc ( \"Total time\" ) return","title":"_run"},{"location":"autoapi/aimigrate/#aimigrate.CoreMigrate.log","text":"Print if self.verbose is True Source code in aimigrate/migrate_core.py 38 39 40 41 42 43 44 45 46 47 48 49 def log ( self , string , color = \"green\" ): \"\"\"Print if self.verbose is True\"\"\" if self . verbose : printfunc = dict ( default = print , red = sc . printred , green = sc . printgreen , blue = sc . printcyan , yellow = sc . printyellow , )[ color ] printfunc ( string ) return","title":"log"},{"location":"autoapi/aimigrate/#aimigrate.CoreMigrate.make_chatter","text":"Create the LLM agent Source code in aimigrate/migrate_core.py 99 100 101 102 103 def make_chatter ( self ): \"\"\"Create the LLM agent\"\"\" self . log ( \"Creating agent...\" ) self . chatter = aim . SimpleQuery ( model = self . model , ** self . model_kw ) return","title":"make_chatter"},{"location":"autoapi/aimigrate/#aimigrate.CoreMigrate.parse_library","text":"Extract the right folder for library Source code in aimigrate/migrate_core.py 105 106 107 108 109 110 111 112 113 114 def parse_library ( self ): \"\"\"Extract the right folder for library\"\"\" self . log ( \"Parsing library folder\" ) if isinstance ( self . library , types . ModuleType ): self . library = sc . thispath ( self . library ) . parent self . library = sc . path ( self . library ) if not self . library . is_dir (): errormsg = f \"The library must be supplied as the module or the folder path, not { self . library } \" raise FileNotFoundError ( errormsg ) return","title":"parse_library"},{"location":"autoapi/aimigrate/#aimigrate.CoreMigrate.run_single","text":"Where everything happens!! Source code in aimigrate/migrate_core.py 51 52 53 54 55 56 57 58 59 60 def run_single ( self , code_file ): \"\"\"Where everything happens!!\"\"\" self . log ( f \"Migrating { code_file . file } \" ) try : code_file . run ( self . chatter , save = self . save ) except Exception as E : errormsg = f \"Could not parse { code_file . file } : { E } \" self . errors . append ( errormsg ) raise E if self . die else print ( errormsg ) return","title":"run_single"},{"location":"autoapi/aimigrate/#aimigrate.GitDiff","text":"Bases: prettyobj Parse the git diff Source code in aimigrate/files.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 class GitDiff ( sc . prettyobj ): \"\"\" Parse the git diff \"\"\" def __init__ ( self , file , include_patterns = None , exclude_patterns = None ): self . include_patterns = ( [ \"*.py\" ] if include_patterns is None else include_patterns ) self . exclude_patterns = ( [ \"docs/*\" ] if exclude_patterns is None else exclude_patterns ) self . diffs = self . parse_git_diff ( file , include_patterns = self . include_patterns , exclude_patterns = self . exclude_patterns , ) return def summarize ( self ): \"\"\"Summarize the diffs\"\"\" diffs = self . diffs print ( f \"Number of files found: { len ( diffs ) } \" ) print ( f \"Number of hunks: { sum ([ len ( diff [ 'hunks' ]) for diff in diffs ]) } \" ) print ( f \"Names of files found: { [ diff [ 'file' ] for diff in diffs ] } \" ) return def get_diff_string ( self , file = None ): \"\"\"Get the diff string (optionally for a file)\"\"\" if file is not None : return \"\" . join ( [ \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs if diff [ \"file\" ] == file ] ) else : return \"\" . join ( [ \" \\n File:\" + diff [ \"file\" ] + \" \\n :\" + \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs ] ) def count_all_tokens ( self , model = \"gpt-4o\" ): \"\"\"Count the total number of tokens in the diff (all hunks)\"\"\" try : encoding = tiktoken . encoding_for_model ( model ) return len ( encoding . encode ( self . get_diff_string ())) except KeyError : return - 1 def print_file_hunks ( self , file ): \"\"\" Print all hunks for a file \"\"\" for diff in self . diffs : if diff . file == file : print ( f \"All hunks for { file } \" ) for hunk in diff . hunks : print ( f \" { hunk } \\n \" ) return @staticmethod def parse_git_diff ( file , include_patterns = None , exclude_patterns = None ): \"\"\" Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Args: diff_file_path (str): The path to the diff file. patterns (list of str, optional): A list of patterns to filter the files. Returns: list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. \"\"\" diffs = [] current_file = None current_hunks = [] # If empty string return if file == \"\" : return diffs # In case a filename is provided instead of the file contents if not isinstance ( file , str ) or \" \\n \" not in file : with open ( file , \"r\" ) as f : file = f . readlines () for line in file . splitlines (): # Match lines that indicate a new file's diff starts file_match = re . match ( r \"^diff --git a/(.+?) b/\" , line ) hunk_start_match = re . match ( r \"^@@\" , line ) if file_match : # Save the previous file and hunks if applicable if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks }) ) # Start a new file and check if it matches any pattern current_file = file_match . group ( 1 ) if include_patterns and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in include_patterns ): # Skip files that don't match any include pattern current_file = None current_hunks = [] elif exclude_patterns and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in exclude_patterns ): # Skip files that match any exclude pattern current_file = None current_hunks = [] else : current_hunks = [] # Reset hunks for the new file elif hunk_start_match : # If there's an ongoing hunk, save it as a new entry before starting a new hunk if current_file and current_hunks and current_hunks [ - 1 ]: current_hunks . append ( \"\" . join ( current_hunks . pop ())) # Start a new hunk for the current file current_hunks . append ([ line . rstrip () + \" \\n \" ]) elif current_hunks : # Append line to current hunk if in a hunk current_hunks [ - 1 ] . append ( line . rstrip () + \" \\n \" ) # Save the last file and hunks if present if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks })) return diffs","title":"GitDiff"},{"location":"autoapi/aimigrate/#aimigrate.GitDiff.count_all_tokens","text":"Count the total number of tokens in the diff (all hunks) Source code in aimigrate/files.py 114 115 116 117 118 119 120 def count_all_tokens ( self , model = \"gpt-4o\" ): \"\"\"Count the total number of tokens in the diff (all hunks)\"\"\" try : encoding = tiktoken . encoding_for_model ( model ) return len ( encoding . encode ( self . get_diff_string ())) except KeyError : return - 1","title":"count_all_tokens"},{"location":"autoapi/aimigrate/#aimigrate.GitDiff.get_diff_string","text":"Get the diff string (optionally for a file) Source code in aimigrate/files.py 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_diff_string ( self , file = None ): \"\"\"Get the diff string (optionally for a file)\"\"\" if file is not None : return \"\" . join ( [ \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs if diff [ \"file\" ] == file ] ) else : return \"\" . join ( [ \" \\n File:\" + diff [ \"file\" ] + \" \\n :\" + \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs ] )","title":"get_diff_string"},{"location":"autoapi/aimigrate/#aimigrate.GitDiff.parse_git_diff","text":"Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Parameters: Name Type Description Default diff_file_path str The path to the diff file. required patterns list of str A list of patterns to filter the files. required Returns: Type Description list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. Source code in aimigrate/files.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 @staticmethod def parse_git_diff ( file , include_patterns = None , exclude_patterns = None ): \"\"\" Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Args: diff_file_path (str): The path to the diff file. patterns (list of str, optional): A list of patterns to filter the files. Returns: list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. \"\"\" diffs = [] current_file = None current_hunks = [] # If empty string return if file == \"\" : return diffs # In case a filename is provided instead of the file contents if not isinstance ( file , str ) or \" \\n \" not in file : with open ( file , \"r\" ) as f : file = f . readlines () for line in file . splitlines (): # Match lines that indicate a new file's diff starts file_match = re . match ( r \"^diff --git a/(.+?) b/\" , line ) hunk_start_match = re . match ( r \"^@@\" , line ) if file_match : # Save the previous file and hunks if applicable if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks }) ) # Start a new file and check if it matches any pattern current_file = file_match . group ( 1 ) if include_patterns and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in include_patterns ): # Skip files that don't match any include pattern current_file = None current_hunks = [] elif exclude_patterns and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in exclude_patterns ): # Skip files that match any exclude pattern current_file = None current_hunks = [] else : current_hunks = [] # Reset hunks for the new file elif hunk_start_match : # If there's an ongoing hunk, save it as a new entry before starting a new hunk if current_file and current_hunks and current_hunks [ - 1 ]: current_hunks . append ( \"\" . join ( current_hunks . pop ())) # Start a new hunk for the current file current_hunks . append ([ line . rstrip () + \" \\n \" ]) elif current_hunks : # Append line to current hunk if in a hunk current_hunks [ - 1 ] . append ( line . rstrip () + \" \\n \" ) # Save the last file and hunks if present if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks })) return diffs","title":"parse_git_diff"},{"location":"autoapi/aimigrate/#aimigrate.GitDiff.print_file_hunks","text":"Print all hunks for a file Source code in aimigrate/files.py 122 123 124 125 126 127 128 129 130 131 def print_file_hunks ( self , file ): \"\"\" Print all hunks for a file \"\"\" for diff in self . diffs : if diff . file == file : print ( f \"All hunks for { file } \" ) for hunk in diff . hunks : print ( f \" { hunk } \\n \" ) return","title":"print_file_hunks"},{"location":"autoapi/aimigrate/#aimigrate.GitDiff.summarize","text":"Summarize the diffs Source code in aimigrate/files.py 92 93 94 95 96 97 98 def summarize ( self ): \"\"\"Summarize the diffs\"\"\" diffs = self . diffs print ( f \"Number of files found: { len ( diffs ) } \" ) print ( f \"Number of hunks: { sum ([ len ( diff [ 'hunks' ]) for diff in diffs ]) } \" ) print ( f \"Names of files found: { [ diff [ 'file' ] for diff in diffs ] } \" ) return","title":"summarize"},{"location":"autoapi/aimigrate/#aimigrate.MethodVisitor","text":"Bases: NodeVisitor A visitor class that collects information about methods in a specific class within an Abstract Syntax Tree (AST). Example usage :: script = ''' class MyClass: def method1(self): pass def method2(self): return \"Hello\" ''' tree = ast.parse(script) visitor = MethodVisitor('MyClass') visitor.visit(tree) print(visitor.methods) # Output: # [{'name': 'method1', 'lineno': 3, 'end_lineno': 4}, # {'name': 'method2', 'lineno': 6, 'end_lineno': 7}] Source code in aimigrate/code.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class MethodVisitor ( ast . NodeVisitor ): \"\"\" A visitor class that collects information about methods in a specific class within an Abstract Syntax Tree (AST). **Example usage**:: script = ''' class MyClass: def method1(self): pass def method2(self): return \"Hello\" ''' tree = ast.parse(script) visitor = MethodVisitor('MyClass') visitor.visit(tree) print(visitor.methods) # Output: # [{'name': 'method1', 'lineno': 3, 'end_lineno': 4}, # {'name': 'method2', 'lineno': 6, 'end_lineno': 7}] \"\"\" def __init__ ( self ): self . methods = [] def visit_ClassDef ( self , node ): # Visit each method (FunctionDef) in the class body for child in node . body : if isinstance ( child , ast . FunctionDef ): method_info = sc . objdict ( { \"name\" : child . name , \"lineno\" : child . lineno , \"end_lineno\" : getattr ( child , \"end_lineno\" , None ), # Python 3.8+ } ) self . methods . append ( method_info ) # Continue visiting child nodes self . generic_visit ( node )","title":"MethodVisitor"},{"location":"autoapi/aimigrate/#aimigrate.MigrateDiff","text":"Bases: CoreMigrate Handle all steps of code migration Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / path / module the library to base the migration on (i.e., Starsim or the path to it) None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None diff_file str if provided, load this diff file instead of computing it via library/v_from/v_to, i.e. git diff v1.0.3 v2.2.0 > diff_file None diff str if provided, use this diff rather than loading it from file None model str the LLM to use None model_kw dict any keywords to pass to the model None include list the list of files to include from the diff None exclude list the list of files to not include from the diff None base_prompt str the prompt template that will be populated with the diff and file information None diff_speed bool whether to use include/exclude to choose files for diff construction. (default False) False filter list if diff_speed=True, a list of file extensions to include when constructing the diff (default [\".py\"]) None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import starsim as ss import starsim_ai as ssai M = aim.Migrate( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) v_from = 'v1.0.3', # can be any valid git tag or hash v_to = 'v2.2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_diff.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class MigrateDiff ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/path/module): the library to base the migration on (i.e., Starsim or the path to it) v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in diff_file (str): if provided, load this diff file instead of computing it via library/v_from/v_to, i.e. git diff v1.0.3 v2.2.0 > diff_file diff (str): if provided, use this diff rather than loading it from file model (str): the LLM to use model_kw (dict): any keywords to pass to the model include (list): the list of files to include from the diff exclude (list): the list of files to not include from the diff base_prompt (str): the prompt template that will be populated with the diff and file information diff_speed (bool): whether to use include/exclude to choose files for diff construction. (default False) filter (list): if diff_speed=True, a list of file extensions to include when constructing the diff (default [\".py\"]) parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import starsim as ss import starsim_ai as ssai M = aim.Migrate( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) v_from = 'v1.0.3', # can be any valid git tag or hash v_to = 'v2.2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , # Migration settings include = None , exclude = None , diff_file = None , diff = None , patience = None , diff_speed = False , filter = None , # Diff settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run settings # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . include = sc . ifelse ( include , DEFAULT_INCLUDE ) self . exclude = sc . ifelse ( exclude , DEFAULT_EXCLUDE ) self . diff_file = diff_file self . diff = diff self . patience = patience self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . filter = sc . ifelse ( filter , [ \".py\" ]) self . diff_speed = diff_speed self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] # Optionally run if run : self . run () return def make_diff ( self ): self . log ( \"Making the diff\" ) if self . diff : return elif self . diff_file : with open ( self . diff_file , \"r\" ) as f : self . diff = f . readlines () else : self . parse_library () if self . diff_speed : self . diff = \"\" with aim . utils . TemporaryDirectoryChange ( self . library ): # check that the revisions are good assert not sc . runcommand ( f \"git rev-parse --verify { self . v_from } \" ) . startswith ( \"fatal\" ), \"Invalid v_from\" assert not sc . runcommand ( f \"git rev-parse --verify { self . v_to } \" ) . startswith ( \"fatal\" ), \"Invalid v_to\" # get current git commit current_head = sc . runcommand ( \"git rev-parse HEAD\" ) # get the files in the library library_files = aim . files . get_python_files ( self . library , gitignore = True , filter = self . filter ) assert not sc . runcommand ( f \"git checkout { current_head } \" ) . startswith ( \"error\" ), \"Error checking out previous commit\" # get the diff for each file that passes the include/exclude for current_file in library_files : if self . include and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . include ): continue elif self . exclude and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . exclude ): continue else : self . diff += sc . runcommand ( f \"git diff { '--patience ' if self . patience else '' }{ self . v_from } { self . v_to } -- { current_file } \" ) else : with aim . utils . TemporaryDirectoryChange ( self . library ): assert not sc . runcommand ( f \"git rev-parse --verify { self . v_from } \" ) . startswith ( \"fatal\" ), \"Invalid v_from\" assert not sc . runcommand ( f \"git rev-parse --verify { self . v_to } \" ) . startswith ( \"fatal\" ), \"Invalid v_to\" self . diff = sc . runcommand ( f \"git diff { self . v_from } { self . v_to } \" ) def parse_diff ( self ): self . log ( \"Parsing the diff\" ) self . git_diff = aim . GitDiff ( self . diff , include_patterns = self . include , exclude_patterns = self . exclude ) self . git_diff . summarize () # summarize self . n_tokens = self . git_diff . count_all_tokens ( model = self . model ) # NB: not implemented for all models if self . verbose and ( self . n_tokens > - 1 ): print ( f \"Number of tokens in the diff: { self . n_tokens } \" ) def make_prompts ( self ): diff_string = self . git_diff . get_diff_string () for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . stem , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"diff\" : diff_string , }, encoder = self . encoder , ) return def run ( self ): # construct the diff self . make_diff () # parse the diff self . parse_diff () # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run ()","title":"MigrateDiff"},{"location":"autoapi/aimigrate/#aimigrate.MigrateOOB","text":"Bases: CoreMigrate Handle all steps of code migration using an LLM \"out of the box\". Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / module the library to base the migration on None library_alias str string to use as the alias for the library None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None model str the LLM to use None model_kw dict any keywords to pass to the model None base_prompt str the prompt template that will be populated with the diff and file information None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import aimigrate as aim M = aim.MigrateOOB( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the name of the library as a string (e.g., starsim) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # use a git tag v_to = 'v2.0', # use a git tag model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_oob.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class MigrateOOB ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration using an LLM \"out of the box\". Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/module): the library to base the migration on library_alias (str): string to use as the alias for the library v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in model (str): the LLM to use model_kw (dict): any keywords to pass to the model base_prompt (str): the prompt template that will be populated with the diff and file information parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import aimigrate as aim M = aim.MigrateOOB( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the name of the library as a string (e.g., starsim) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # use a git tag v_to = 'v2.0', # use a git tag model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , # Migration settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run setting # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] assert isinstance ( self . library , ( str , types . ModuleType )), ( \"Library must be a string or module\" ) # Optionally run if run : self . run () return def make_prompts ( self ): self . make_encoder () for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . __name__ if hasattr ( self . library , \"__name__\" ) else self . library , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"v_from\" : self . v_from , \"v_to\" : self . v_to , }, encoder = self . encoder , ) def run ( self ): # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run ()","title":"MigrateOOB"},{"location":"autoapi/aimigrate/#aimigrate.MigrateRepo","text":"Bases: CoreMigrate Handle all steps of code migration using files (e.g., code) from the target library as context. Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / path / module the library to base the migration on (i.e., the path to a git repository) None library_alias str string to use as the alias for the library None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None model str the LLM to use None model_kw dict any keywords to pass to the model None include list the list of files to include from the diff None exclude list the list of files to not include from the diff None base_prompt str the prompt template that will be populated with the diff and file information None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import aimigrate as aim M = aim.MigrateRepo( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # can be any valid git tag or hash v_to = 'v2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_repo.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class MigrateRepo ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration using files (e.g., code) from the target library as context. Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/path/module): the library to base the migration on (i.e., the path to a git repository) library_alias (str): string to use as the alias for the library v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in model (str): the LLM to use model_kw (dict): any keywords to pass to the model include (list): the list of files to include from the diff exclude (list): the list of files to not include from the diff base_prompt (str): the prompt template that will be populated with the diff and file information parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import aimigrate as aim M = aim.MigrateRepo( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # can be any valid git tag or hash v_to = 'v2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , filter = None , # Migration settings include = None , exclude = None , # Library settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run settings # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . include = sc . ifelse ( include , DEFAULT_INCLUDE ) self . exclude = sc . ifelse ( exclude , DEFAULT_EXCLUDE ) self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . filter = sc . ifelse ( filter , [ \".py\" ]) self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] # Optionally run if run : self . run () return def run ( self ): self . make_encoder () # get the repository files self . get_repo_files () # parse the repository files self . parse_repo_files () # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run () def get_repo_files ( self ): self . log ( \"Getting the repository files\" ) self . parse_library () self . repo_files = [] with aim . utils . TemporaryDirectoryChange ( self . library ): # get current git commit current_head = sc . runcommand ( \"git rev-parse HEAD\" ) assert not sc . runcommand ( f \"git checkout { self . v_to } \" ) . startswith ( \"error\" ), ( \"Invalid v_to\" ) all_repo_files = aim . files . get_python_files ( self . library , gitignore = True , filter = self . filter ) assert not sc . runcommand ( f \"git checkout { current_head } \" ) . startswith ( \"error\" ), \"Error checking out previous commit\" for current_file in all_repo_files : if self . include and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . include ): continue elif self . exclude and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . exclude ): continue else : self . repo_files . append ( current_file ) def parse_repo_files ( self ): self . log ( \"Parsing repository files\" ) self . repo_string = \"\" for current_file in self . repo_files : with open ( self . library / current_file , \"r\" ) as f : self . repo_string += \"\"\"File: {file_name} \\n ''' \\n {code} ''' \\n \"\"\" . format ( file_name = current_file , code = f . read () ) if self . encoder is not None : self . n_tokens = len ( self . encoder . encode ( self . repo_string )) else : self . n_tokens = - 1 if self . verbose and ( self . n_tokens > - 1 ): print ( f \"Number of tokens in repository files: { self . n_tokens } \" ) return def make_prompts ( self ): for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . stem , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"library_code\" : self . repo_string , }, encoder = self . encoder , ) return","title":"MigrateRepo"},{"location":"autoapi/aimigrate/#aimigrate.PythonCode","text":"Bases: prettyobj Parse Python code into classes and methods Source code in aimigrate/files.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class PythonCode ( sc . prettyobj ): \"\"\" Parse Python code into classes and methods \"\"\" def __init__ ( self , file_path : str ): self . code_lines = None self . classes = None self . from_file ( file_path ) self . set_classes () return def from_file ( self , file_path ): with open ( file_path , \"r\" ) as file : self . code_lines = file . readlines () return def get_code_string ( self ): return \"\" . join ( self . code_lines ) def set_classes ( self ): tree = ast . parse ( \"\" . join ( self . code_lines )) visitor = aim . ClassVisitor () visitor . visit ( tree ) self . classes = visitor . classes return def get_class_methods ( self , name ): # BUG: how does this work for methods with the same name? for c in self . classes : if c [ \"name\" ] == name : class_code_list = self . code_lines [ c [ \"lineno\" ] - 1 : c [ \"end_lineno\" ] + 1 ] tree = ast . parse ( \"\" . join ( class_code_list )) visitor = aim . MethodVisitor () visitor . visit ( tree ) return class_code_list , visitor raise ValueError ( f \"Class { name } not found\" ) def get_class_string ( self , name , methods_flag = False ): if methods_flag : code_lines , visitor = self . get_class_methods ( name ) res = {} for m in visitor . methods : res [ m [ \"name\" ]] = \"\" . join ( code_lines [ m [ \"lineno\" ] - 1 : m [ \"end_lineno\" ] + 1 ] ) return res else : for c in self . classes : if c [ \"name\" ] == name : return \"\" . join ( self . code_lines [ c [ \"lineno\" ] - 1 : c [ \"end_lineno\" ] + 1 ] )","title":"PythonCode"},{"location":"autoapi/aimigrate/#aimigrate.SimpleQuery","text":"A simple query interface to interact with an AI model. Source code in aimigrate/chat.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class SimpleQuery (): \"\"\" A simple query interface to interact with an AI model. \"\"\" def __init__ ( self , model = \"openai:gpt-3.5-turbo\" , ** kwargs ): self . model = model self . client = ai . Client () self . kwargs = { 'temperature' : 0.7 } | kwargs def __call__ ( self , user_input ): return self . chat ( user_input ) def chat ( self , user_input ): messages = [ { \"role\" : \"system\" , \"content\" : \"You are a helpful software engineer.\" }, { \"role\" : \"user\" , \"content\" : user_input }, ] response = self . client . chat . completions . create ( model = self . model , messages = messages , ** self . kwargs ) return response . choices [ 0 ] . message . content","title":"SimpleQuery"},{"location":"autoapi/aimigrate/#aimigrate.get_python_files","text":"Recursively retrieves all Python files from the specified directory. Parameters: Name Type Description Default source_dir str The root directory to search for Python files. required gitignore bool Whether to use the .gitignore file to filter files. False Returns: Name Type Description list A list of file paths to Python files found within the directory. Source code in aimigrate/files.py 15 16 17 18 19 20 21 22 23 24 25 26 def get_python_files ( source_dir , gitignore = False , filter = [ \".py\" ]): \"\"\" Recursively retrieves all Python files from the specified directory. Args: source_dir (str): The root directory to search for Python files. gitignore (bool, optional): Whether to use the .gitignore file to filter files. Returns: list: A list of file paths to Python files found within the directory. \"\"\" return get_repository_files ( source_dir , gitignore = gitignore , filter = filter )","title":"get_python_files"},{"location":"autoapi/aimigrate/#aimigrate.get_repository_files","text":"Recursively retrieves all files from the specified directory. Parameters: Name Type Description Default source_dir str The root directory to search for Python files. required gitignore bool Whether to use the .gitignore file to filter files. False filter list of str A list of file suffixes to filter the files ['.py'] Returns: Name Type Description list A list of file paths to files found within the directory. Source code in aimigrate/files.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def get_repository_files ( source_dir , gitignore = False , filter = [ \".py\" ]): \"\"\" Recursively retrieves all files from the specified directory. Args: source_dir (str): The root directory to search for Python files. gitignore (bool, optional): Whether to use the .gitignore file to filter files. filter (list of str, optional): A list of file suffixes to filter the files Returns: list: A list of file paths to files found within the directory. \"\"\" if isinstance ( source_dir , str ): source_dir = sc . path ( source_dir ) python_files = [] if gitignore : with aim . utils . TemporaryDirectoryChange ( source_dir ): files = subprocess . check_output ( \"git ls-files\" , shell = True ) . splitlines () for file in files : decoded = file . decode () if filter is not None : for suffix in filter : if decoded . endswith ( suffix ): python_files . append ( decoded ) break else : python_files . append ( decoded ) python_files = [ sc . path ( files ) for files in python_files ] else : for root , _ , files in os . walk ( source_dir ): for file in files : if filter is not None : for suffix in filter : if file . endswith ( suffix ): python_files . append ( os . path . join ( root , file )) else : python_files . append ( os . path . join ( root , file )) python_files = [ sc . path ( file ) . relative_to ( source_dir ) for file in python_files ] return python_files","title":"get_repository_files"},{"location":"autoapi/aimigrate/#aimigrate.migrate","text":"Helper function for the Migrate class Source code in aimigrate/migration.py 15 16 17 18 19 def migrate ( * args , ** kwargs ): \"\"\"Helper function for the Migrate class\"\"\" mig = Migrate ( * args , ** kwargs ) mig . run () return mig","title":"migrate"},{"location":"autoapi/aimigrate/chat/","text":"SimpleQuery A simple query interface to interact with an AI model. Source code in aimigrate/chat.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class SimpleQuery (): \"\"\" A simple query interface to interact with an AI model. \"\"\" def __init__ ( self , model = \"openai:gpt-3.5-turbo\" , ** kwargs ): self . model = model self . client = ai . Client () self . kwargs = { 'temperature' : 0.7 } | kwargs def __call__ ( self , user_input ): return self . chat ( user_input ) def chat ( self , user_input ): messages = [ { \"role\" : \"system\" , \"content\" : \"You are a helpful software engineer.\" }, { \"role\" : \"user\" , \"content\" : user_input }, ] response = self . client . chat . completions . create ( model = self . model , messages = messages , ** self . kwargs ) return response . choices [ 0 ] . message . content","title":"Chat"},{"location":"autoapi/aimigrate/chat/#aimigrate.chat.SimpleQuery","text":"A simple query interface to interact with an AI model. Source code in aimigrate/chat.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class SimpleQuery (): \"\"\" A simple query interface to interact with an AI model. \"\"\" def __init__ ( self , model = \"openai:gpt-3.5-turbo\" , ** kwargs ): self . model = model self . client = ai . Client () self . kwargs = { 'temperature' : 0.7 } | kwargs def __call__ ( self , user_input ): return self . chat ( user_input ) def chat ( self , user_input ): messages = [ { \"role\" : \"system\" , \"content\" : \"You are a helpful software engineer.\" }, { \"role\" : \"user\" , \"content\" : user_input }, ] response = self . client . chat . completions . create ( model = self . model , messages = messages , ** self . kwargs ) return response . choices [ 0 ] . message . content","title":"SimpleQuery"},{"location":"autoapi/aimigrate/code/","text":"Helper classes for parsing code in a rigorous way. ClassVisitor Bases: NodeVisitor A visitor class that collects information about class definitions in an AST (Abstract Syntax Tree). Example usage :: script = ''' class MyClass: def method(self): pass ''' tree = ast.parse(script) visitor = ClassVisitor() visitor.visit(tree) print(visitor.classes) # Output: [{'name': 'MyClass', 'bases': [], 'methods': ['method'], 'lineno': 2, 'end_lineno': 4}] Source code in aimigrate/code.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class ClassVisitor ( ast . NodeVisitor ): \"\"\" A visitor class that collects information about class definitions in an AST (Abstract Syntax Tree). **Example usage**:: script = ''' class MyClass: def method(self): pass ''' tree = ast.parse(script) visitor = ClassVisitor() visitor.visit(tree) print(visitor.classes) # Output: [{'name': 'MyClass', 'bases': [], 'methods': ['method'], 'lineno': 2, 'end_lineno': 4}] \"\"\" def __init__ ( self ): self . classes = [] def visit_ClassDef ( self , node ): if isinstance ( node , ast . ClassDef ): # Collect class details class_info = sc . objdict ( { \"name\" : node . name , \"bases\" : [ base . id if isinstance ( base , ast . Name ) else ast . dump ( base ) for base in node . bases ], \"methods\" : [ n . name for n in node . body if isinstance ( n , ast . FunctionDef ) ], \"lineno\" : node . lineno , \"end_lineno\" : getattr ( node , \"end_lineno\" , None ), # Python 3.8+ } ) self . classes . append ( class_info ) self . generic_visit ( node ) # Continue visiting child nodes MethodVisitor Bases: NodeVisitor A visitor class that collects information about methods in a specific class within an Abstract Syntax Tree (AST). Example usage :: script = ''' class MyClass: def method1(self): pass def method2(self): return \"Hello\" ''' tree = ast.parse(script) visitor = MethodVisitor('MyClass') visitor.visit(tree) print(visitor.methods) # Output: # [{'name': 'method1', 'lineno': 3, 'end_lineno': 4}, # {'name': 'method2', 'lineno': 6, 'end_lineno': 7}] Source code in aimigrate/code.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class MethodVisitor ( ast . NodeVisitor ): \"\"\" A visitor class that collects information about methods in a specific class within an Abstract Syntax Tree (AST). **Example usage**:: script = ''' class MyClass: def method1(self): pass def method2(self): return \"Hello\" ''' tree = ast.parse(script) visitor = MethodVisitor('MyClass') visitor.visit(tree) print(visitor.methods) # Output: # [{'name': 'method1', 'lineno': 3, 'end_lineno': 4}, # {'name': 'method2', 'lineno': 6, 'end_lineno': 7}] \"\"\" def __init__ ( self ): self . methods = [] def visit_ClassDef ( self , node ): # Visit each method (FunctionDef) in the class body for child in node . body : if isinstance ( child , ast . FunctionDef ): method_info = sc . objdict ( { \"name\" : child . name , \"lineno\" : child . lineno , \"end_lineno\" : getattr ( child , \"end_lineno\" , None ), # Python 3.8+ } ) self . methods . append ( method_info ) # Continue visiting child nodes self . generic_visit ( node )","title":"Code"},{"location":"autoapi/aimigrate/code/#aimigrate.code.ClassVisitor","text":"Bases: NodeVisitor A visitor class that collects information about class definitions in an AST (Abstract Syntax Tree). Example usage :: script = ''' class MyClass: def method(self): pass ''' tree = ast.parse(script) visitor = ClassVisitor() visitor.visit(tree) print(visitor.classes) # Output: [{'name': 'MyClass', 'bases': [], 'methods': ['method'], 'lineno': 2, 'end_lineno': 4}] Source code in aimigrate/code.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class ClassVisitor ( ast . NodeVisitor ): \"\"\" A visitor class that collects information about class definitions in an AST (Abstract Syntax Tree). **Example usage**:: script = ''' class MyClass: def method(self): pass ''' tree = ast.parse(script) visitor = ClassVisitor() visitor.visit(tree) print(visitor.classes) # Output: [{'name': 'MyClass', 'bases': [], 'methods': ['method'], 'lineno': 2, 'end_lineno': 4}] \"\"\" def __init__ ( self ): self . classes = [] def visit_ClassDef ( self , node ): if isinstance ( node , ast . ClassDef ): # Collect class details class_info = sc . objdict ( { \"name\" : node . name , \"bases\" : [ base . id if isinstance ( base , ast . Name ) else ast . dump ( base ) for base in node . bases ], \"methods\" : [ n . name for n in node . body if isinstance ( n , ast . FunctionDef ) ], \"lineno\" : node . lineno , \"end_lineno\" : getattr ( node , \"end_lineno\" , None ), # Python 3.8+ } ) self . classes . append ( class_info ) self . generic_visit ( node ) # Continue visiting child nodes","title":"ClassVisitor"},{"location":"autoapi/aimigrate/code/#aimigrate.code.MethodVisitor","text":"Bases: NodeVisitor A visitor class that collects information about methods in a specific class within an Abstract Syntax Tree (AST). Example usage :: script = ''' class MyClass: def method1(self): pass def method2(self): return \"Hello\" ''' tree = ast.parse(script) visitor = MethodVisitor('MyClass') visitor.visit(tree) print(visitor.methods) # Output: # [{'name': 'method1', 'lineno': 3, 'end_lineno': 4}, # {'name': 'method2', 'lineno': 6, 'end_lineno': 7}] Source code in aimigrate/code.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class MethodVisitor ( ast . NodeVisitor ): \"\"\" A visitor class that collects information about methods in a specific class within an Abstract Syntax Tree (AST). **Example usage**:: script = ''' class MyClass: def method1(self): pass def method2(self): return \"Hello\" ''' tree = ast.parse(script) visitor = MethodVisitor('MyClass') visitor.visit(tree) print(visitor.methods) # Output: # [{'name': 'method1', 'lineno': 3, 'end_lineno': 4}, # {'name': 'method2', 'lineno': 6, 'end_lineno': 7}] \"\"\" def __init__ ( self ): self . methods = [] def visit_ClassDef ( self , node ): # Visit each method (FunctionDef) in the class body for child in node . body : if isinstance ( child , ast . FunctionDef ): method_info = sc . objdict ( { \"name\" : child . name , \"lineno\" : child . lineno , \"end_lineno\" : getattr ( child , \"end_lineno\" , None ), # Python 3.8+ } ) self . methods . append ( method_info ) # Continue visiting child nodes self . generic_visit ( node )","title":"MethodVisitor"},{"location":"autoapi/aimigrate/files/","text":"Parse the files and folders, including the git diff GitDiff Bases: prettyobj Parse the git diff Source code in aimigrate/files.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 class GitDiff ( sc . prettyobj ): \"\"\" Parse the git diff \"\"\" def __init__ ( self , file , include_patterns = None , exclude_patterns = None ): self . include_patterns = ( [ \"*.py\" ] if include_patterns is None else include_patterns ) self . exclude_patterns = ( [ \"docs/*\" ] if exclude_patterns is None else exclude_patterns ) self . diffs = self . parse_git_diff ( file , include_patterns = self . include_patterns , exclude_patterns = self . exclude_patterns , ) return def summarize ( self ): \"\"\"Summarize the diffs\"\"\" diffs = self . diffs print ( f \"Number of files found: { len ( diffs ) } \" ) print ( f \"Number of hunks: { sum ([ len ( diff [ 'hunks' ]) for diff in diffs ]) } \" ) print ( f \"Names of files found: { [ diff [ 'file' ] for diff in diffs ] } \" ) return def get_diff_string ( self , file = None ): \"\"\"Get the diff string (optionally for a file)\"\"\" if file is not None : return \"\" . join ( [ \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs if diff [ \"file\" ] == file ] ) else : return \"\" . join ( [ \" \\n File:\" + diff [ \"file\" ] + \" \\n :\" + \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs ] ) def count_all_tokens ( self , model = \"gpt-4o\" ): \"\"\"Count the total number of tokens in the diff (all hunks)\"\"\" try : encoding = tiktoken . encoding_for_model ( model ) return len ( encoding . encode ( self . get_diff_string ())) except KeyError : return - 1 def print_file_hunks ( self , file ): \"\"\" Print all hunks for a file \"\"\" for diff in self . diffs : if diff . file == file : print ( f \"All hunks for { file } \" ) for hunk in diff . hunks : print ( f \" { hunk } \\n \" ) return @staticmethod def parse_git_diff ( file , include_patterns = None , exclude_patterns = None ): \"\"\" Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Args: diff_file_path (str): The path to the diff file. patterns (list of str, optional): A list of patterns to filter the files. Returns: list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. \"\"\" diffs = [] current_file = None current_hunks = [] # If empty string return if file == \"\" : return diffs # In case a filename is provided instead of the file contents if not isinstance ( file , str ) or \" \\n \" not in file : with open ( file , \"r\" ) as f : file = f . readlines () for line in file . splitlines (): # Match lines that indicate a new file's diff starts file_match = re . match ( r \"^diff --git a/(.+?) b/\" , line ) hunk_start_match = re . match ( r \"^@@\" , line ) if file_match : # Save the previous file and hunks if applicable if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks }) ) # Start a new file and check if it matches any pattern current_file = file_match . group ( 1 ) if include_patterns and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in include_patterns ): # Skip files that don't match any include pattern current_file = None current_hunks = [] elif exclude_patterns and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in exclude_patterns ): # Skip files that match any exclude pattern current_file = None current_hunks = [] else : current_hunks = [] # Reset hunks for the new file elif hunk_start_match : # If there's an ongoing hunk, save it as a new entry before starting a new hunk if current_file and current_hunks and current_hunks [ - 1 ]: current_hunks . append ( \"\" . join ( current_hunks . pop ())) # Start a new hunk for the current file current_hunks . append ([ line . rstrip () + \" \\n \" ]) elif current_hunks : # Append line to current hunk if in a hunk current_hunks [ - 1 ] . append ( line . rstrip () + \" \\n \" ) # Save the last file and hunks if present if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks })) return diffs count_all_tokens ( model = 'gpt-4o' ) Count the total number of tokens in the diff (all hunks) Source code in aimigrate/files.py 114 115 116 117 118 119 120 def count_all_tokens ( self , model = \"gpt-4o\" ): \"\"\"Count the total number of tokens in the diff (all hunks)\"\"\" try : encoding = tiktoken . encoding_for_model ( model ) return len ( encoding . encode ( self . get_diff_string ())) except KeyError : return - 1 get_diff_string ( file = None ) Get the diff string (optionally for a file) Source code in aimigrate/files.py 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_diff_string ( self , file = None ): \"\"\"Get the diff string (optionally for a file)\"\"\" if file is not None : return \"\" . join ( [ \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs if diff [ \"file\" ] == file ] ) else : return \"\" . join ( [ \" \\n File:\" + diff [ \"file\" ] + \" \\n :\" + \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs ] ) parse_git_diff ( file , include_patterns = None , exclude_patterns = None ) staticmethod Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Parameters: Name Type Description Default diff_file_path str The path to the diff file. required patterns list of str A list of patterns to filter the files. required Returns: Type Description list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. Source code in aimigrate/files.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 @staticmethod def parse_git_diff ( file , include_patterns = None , exclude_patterns = None ): \"\"\" Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Args: diff_file_path (str): The path to the diff file. patterns (list of str, optional): A list of patterns to filter the files. Returns: list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. \"\"\" diffs = [] current_file = None current_hunks = [] # If empty string return if file == \"\" : return diffs # In case a filename is provided instead of the file contents if not isinstance ( file , str ) or \" \\n \" not in file : with open ( file , \"r\" ) as f : file = f . readlines () for line in file . splitlines (): # Match lines that indicate a new file's diff starts file_match = re . match ( r \"^diff --git a/(.+?) b/\" , line ) hunk_start_match = re . match ( r \"^@@\" , line ) if file_match : # Save the previous file and hunks if applicable if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks }) ) # Start a new file and check if it matches any pattern current_file = file_match . group ( 1 ) if include_patterns and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in include_patterns ): # Skip files that don't match any include pattern current_file = None current_hunks = [] elif exclude_patterns and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in exclude_patterns ): # Skip files that match any exclude pattern current_file = None current_hunks = [] else : current_hunks = [] # Reset hunks for the new file elif hunk_start_match : # If there's an ongoing hunk, save it as a new entry before starting a new hunk if current_file and current_hunks and current_hunks [ - 1 ]: current_hunks . append ( \"\" . join ( current_hunks . pop ())) # Start a new hunk for the current file current_hunks . append ([ line . rstrip () + \" \\n \" ]) elif current_hunks : # Append line to current hunk if in a hunk current_hunks [ - 1 ] . append ( line . rstrip () + \" \\n \" ) # Save the last file and hunks if present if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks })) return diffs print_file_hunks ( file ) Print all hunks for a file Source code in aimigrate/files.py 122 123 124 125 126 127 128 129 130 131 def print_file_hunks ( self , file ): \"\"\" Print all hunks for a file \"\"\" for diff in self . diffs : if diff . file == file : print ( f \"All hunks for { file } \" ) for hunk in diff . hunks : print ( f \" { hunk } \\n \" ) return summarize () Summarize the diffs Source code in aimigrate/files.py 92 93 94 95 96 97 98 def summarize ( self ): \"\"\"Summarize the diffs\"\"\" diffs = self . diffs print ( f \"Number of files found: { len ( diffs ) } \" ) print ( f \"Number of hunks: { sum ([ len ( diff [ 'hunks' ]) for diff in diffs ]) } \" ) print ( f \"Names of files found: { [ diff [ 'file' ] for diff in diffs ] } \" ) return PythonCode Bases: prettyobj Parse Python code into classes and methods Source code in aimigrate/files.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class PythonCode ( sc . prettyobj ): \"\"\" Parse Python code into classes and methods \"\"\" def __init__ ( self , file_path : str ): self . code_lines = None self . classes = None self . from_file ( file_path ) self . set_classes () return def from_file ( self , file_path ): with open ( file_path , \"r\" ) as file : self . code_lines = file . readlines () return def get_code_string ( self ): return \"\" . join ( self . code_lines ) def set_classes ( self ): tree = ast . parse ( \"\" . join ( self . code_lines )) visitor = aim . ClassVisitor () visitor . visit ( tree ) self . classes = visitor . classes return def get_class_methods ( self , name ): # BUG: how does this work for methods with the same name? for c in self . classes : if c [ \"name\" ] == name : class_code_list = self . code_lines [ c [ \"lineno\" ] - 1 : c [ \"end_lineno\" ] + 1 ] tree = ast . parse ( \"\" . join ( class_code_list )) visitor = aim . MethodVisitor () visitor . visit ( tree ) return class_code_list , visitor raise ValueError ( f \"Class { name } not found\" ) def get_class_string ( self , name , methods_flag = False ): if methods_flag : code_lines , visitor = self . get_class_methods ( name ) res = {} for m in visitor . methods : res [ m [ \"name\" ]] = \"\" . join ( code_lines [ m [ \"lineno\" ] - 1 : m [ \"end_lineno\" ] + 1 ] ) return res else : for c in self . classes : if c [ \"name\" ] == name : return \"\" . join ( self . code_lines [ c [ \"lineno\" ] - 1 : c [ \"end_lineno\" ] + 1 ] ) get_python_files ( source_dir , gitignore = False , filter = [ '.py' ]) Recursively retrieves all Python files from the specified directory. Parameters: Name Type Description Default source_dir str The root directory to search for Python files. required gitignore bool Whether to use the .gitignore file to filter files. False Returns: Name Type Description list A list of file paths to Python files found within the directory. Source code in aimigrate/files.py 15 16 17 18 19 20 21 22 23 24 25 26 def get_python_files ( source_dir , gitignore = False , filter = [ \".py\" ]): \"\"\" Recursively retrieves all Python files from the specified directory. Args: source_dir (str): The root directory to search for Python files. gitignore (bool, optional): Whether to use the .gitignore file to filter files. Returns: list: A list of file paths to Python files found within the directory. \"\"\" return get_repository_files ( source_dir , gitignore = gitignore , filter = filter ) get_repository_files ( source_dir , gitignore = False , filter = [ '.py' ]) Recursively retrieves all files from the specified directory. Parameters: Name Type Description Default source_dir str The root directory to search for Python files. required gitignore bool Whether to use the .gitignore file to filter files. False filter list of str A list of file suffixes to filter the files ['.py'] Returns: Name Type Description list A list of file paths to files found within the directory. Source code in aimigrate/files.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def get_repository_files ( source_dir , gitignore = False , filter = [ \".py\" ]): \"\"\" Recursively retrieves all files from the specified directory. Args: source_dir (str): The root directory to search for Python files. gitignore (bool, optional): Whether to use the .gitignore file to filter files. filter (list of str, optional): A list of file suffixes to filter the files Returns: list: A list of file paths to files found within the directory. \"\"\" if isinstance ( source_dir , str ): source_dir = sc . path ( source_dir ) python_files = [] if gitignore : with aim . utils . TemporaryDirectoryChange ( source_dir ): files = subprocess . check_output ( \"git ls-files\" , shell = True ) . splitlines () for file in files : decoded = file . decode () if filter is not None : for suffix in filter : if decoded . endswith ( suffix ): python_files . append ( decoded ) break else : python_files . append ( decoded ) python_files = [ sc . path ( files ) for files in python_files ] else : for root , _ , files in os . walk ( source_dir ): for file in files : if filter is not None : for suffix in filter : if file . endswith ( suffix ): python_files . append ( os . path . join ( root , file )) else : python_files . append ( os . path . join ( root , file )) python_files = [ sc . path ( file ) . relative_to ( source_dir ) for file in python_files ] return python_files","title":"Files"},{"location":"autoapi/aimigrate/files/#aimigrate.files.GitDiff","text":"Bases: prettyobj Parse the git diff Source code in aimigrate/files.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 class GitDiff ( sc . prettyobj ): \"\"\" Parse the git diff \"\"\" def __init__ ( self , file , include_patterns = None , exclude_patterns = None ): self . include_patterns = ( [ \"*.py\" ] if include_patterns is None else include_patterns ) self . exclude_patterns = ( [ \"docs/*\" ] if exclude_patterns is None else exclude_patterns ) self . diffs = self . parse_git_diff ( file , include_patterns = self . include_patterns , exclude_patterns = self . exclude_patterns , ) return def summarize ( self ): \"\"\"Summarize the diffs\"\"\" diffs = self . diffs print ( f \"Number of files found: { len ( diffs ) } \" ) print ( f \"Number of hunks: { sum ([ len ( diff [ 'hunks' ]) for diff in diffs ]) } \" ) print ( f \"Names of files found: { [ diff [ 'file' ] for diff in diffs ] } \" ) return def get_diff_string ( self , file = None ): \"\"\"Get the diff string (optionally for a file)\"\"\" if file is not None : return \"\" . join ( [ \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs if diff [ \"file\" ] == file ] ) else : return \"\" . join ( [ \" \\n File:\" + diff [ \"file\" ] + \" \\n :\" + \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs ] ) def count_all_tokens ( self , model = \"gpt-4o\" ): \"\"\"Count the total number of tokens in the diff (all hunks)\"\"\" try : encoding = tiktoken . encoding_for_model ( model ) return len ( encoding . encode ( self . get_diff_string ())) except KeyError : return - 1 def print_file_hunks ( self , file ): \"\"\" Print all hunks for a file \"\"\" for diff in self . diffs : if diff . file == file : print ( f \"All hunks for { file } \" ) for hunk in diff . hunks : print ( f \" { hunk } \\n \" ) return @staticmethod def parse_git_diff ( file , include_patterns = None , exclude_patterns = None ): \"\"\" Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Args: diff_file_path (str): The path to the diff file. patterns (list of str, optional): A list of patterns to filter the files. Returns: list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. \"\"\" diffs = [] current_file = None current_hunks = [] # If empty string return if file == \"\" : return diffs # In case a filename is provided instead of the file contents if not isinstance ( file , str ) or \" \\n \" not in file : with open ( file , \"r\" ) as f : file = f . readlines () for line in file . splitlines (): # Match lines that indicate a new file's diff starts file_match = re . match ( r \"^diff --git a/(.+?) b/\" , line ) hunk_start_match = re . match ( r \"^@@\" , line ) if file_match : # Save the previous file and hunks if applicable if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks }) ) # Start a new file and check if it matches any pattern current_file = file_match . group ( 1 ) if include_patterns and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in include_patterns ): # Skip files that don't match any include pattern current_file = None current_hunks = [] elif exclude_patterns and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in exclude_patterns ): # Skip files that match any exclude pattern current_file = None current_hunks = [] else : current_hunks = [] # Reset hunks for the new file elif hunk_start_match : # If there's an ongoing hunk, save it as a new entry before starting a new hunk if current_file and current_hunks and current_hunks [ - 1 ]: current_hunks . append ( \"\" . join ( current_hunks . pop ())) # Start a new hunk for the current file current_hunks . append ([ line . rstrip () + \" \\n \" ]) elif current_hunks : # Append line to current hunk if in a hunk current_hunks [ - 1 ] . append ( line . rstrip () + \" \\n \" ) # Save the last file and hunks if present if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks })) return diffs","title":"GitDiff"},{"location":"autoapi/aimigrate/files/#aimigrate.files.GitDiff.count_all_tokens","text":"Count the total number of tokens in the diff (all hunks) Source code in aimigrate/files.py 114 115 116 117 118 119 120 def count_all_tokens ( self , model = \"gpt-4o\" ): \"\"\"Count the total number of tokens in the diff (all hunks)\"\"\" try : encoding = tiktoken . encoding_for_model ( model ) return len ( encoding . encode ( self . get_diff_string ())) except KeyError : return - 1","title":"count_all_tokens"},{"location":"autoapi/aimigrate/files/#aimigrate.files.GitDiff.get_diff_string","text":"Get the diff string (optionally for a file) Source code in aimigrate/files.py 100 101 102 103 104 105 106 107 108 109 110 111 112 def get_diff_string ( self , file = None ): \"\"\"Get the diff string (optionally for a file)\"\"\" if file is not None : return \"\" . join ( [ \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs if diff [ \"file\" ] == file ] ) else : return \"\" . join ( [ \" \\n File:\" + diff [ \"file\" ] + \" \\n :\" + \"\" . join ( diff [ \"hunks\" ]) for diff in self . diffs ] )","title":"get_diff_string"},{"location":"autoapi/aimigrate/files/#aimigrate.files.GitDiff.parse_git_diff","text":"Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Parameters: Name Type Description Default diff_file_path str The path to the diff file. required patterns list of str A list of patterns to filter the files. required Returns: Type Description list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. Source code in aimigrate/files.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 @staticmethod def parse_git_diff ( file , include_patterns = None , exclude_patterns = None ): \"\"\" Parses a git diff file and extracts diffs for specified files, splitting hunks by '@@'. Args: diff_file_path (str): The path to the diff file. patterns (list of str, optional): A list of patterns to filter the files. Returns: list of dict: A list of dictionaries, each containing the file name and its corresponding diff hunks. \"\"\" diffs = [] current_file = None current_hunks = [] # If empty string return if file == \"\" : return diffs # In case a filename is provided instead of the file contents if not isinstance ( file , str ) or \" \\n \" not in file : with open ( file , \"r\" ) as f : file = f . readlines () for line in file . splitlines (): # Match lines that indicate a new file's diff starts file_match = re . match ( r \"^diff --git a/(.+?) b/\" , line ) hunk_start_match = re . match ( r \"^@@\" , line ) if file_match : # Save the previous file and hunks if applicable if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks }) ) # Start a new file and check if it matches any pattern current_file = file_match . group ( 1 ) if include_patterns and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in include_patterns ): # Skip files that don't match any include pattern current_file = None current_hunks = [] elif exclude_patterns and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in exclude_patterns ): # Skip files that match any exclude pattern current_file = None current_hunks = [] else : current_hunks = [] # Reset hunks for the new file elif hunk_start_match : # If there's an ongoing hunk, save it as a new entry before starting a new hunk if current_file and current_hunks and current_hunks [ - 1 ]: current_hunks . append ( \"\" . join ( current_hunks . pop ())) # Start a new hunk for the current file current_hunks . append ([ line . rstrip () + \" \\n \" ]) elif current_hunks : # Append line to current hunk if in a hunk current_hunks [ - 1 ] . append ( line . rstrip () + \" \\n \" ) # Save the last file and hunks if present if current_file and current_hunks : current_hunks . append ( \"\" . join ( current_hunks . pop ())) diffs . append ( sc . objdict ({ \"file\" : current_file , \"hunks\" : current_hunks })) return diffs","title":"parse_git_diff"},{"location":"autoapi/aimigrate/files/#aimigrate.files.GitDiff.print_file_hunks","text":"Print all hunks for a file Source code in aimigrate/files.py 122 123 124 125 126 127 128 129 130 131 def print_file_hunks ( self , file ): \"\"\" Print all hunks for a file \"\"\" for diff in self . diffs : if diff . file == file : print ( f \"All hunks for { file } \" ) for hunk in diff . hunks : print ( f \" { hunk } \\n \" ) return","title":"print_file_hunks"},{"location":"autoapi/aimigrate/files/#aimigrate.files.GitDiff.summarize","text":"Summarize the diffs Source code in aimigrate/files.py 92 93 94 95 96 97 98 def summarize ( self ): \"\"\"Summarize the diffs\"\"\" diffs = self . diffs print ( f \"Number of files found: { len ( diffs ) } \" ) print ( f \"Number of hunks: { sum ([ len ( diff [ 'hunks' ]) for diff in diffs ]) } \" ) print ( f \"Names of files found: { [ diff [ 'file' ] for diff in diffs ] } \" ) return","title":"summarize"},{"location":"autoapi/aimigrate/files/#aimigrate.files.PythonCode","text":"Bases: prettyobj Parse Python code into classes and methods Source code in aimigrate/files.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class PythonCode ( sc . prettyobj ): \"\"\" Parse Python code into classes and methods \"\"\" def __init__ ( self , file_path : str ): self . code_lines = None self . classes = None self . from_file ( file_path ) self . set_classes () return def from_file ( self , file_path ): with open ( file_path , \"r\" ) as file : self . code_lines = file . readlines () return def get_code_string ( self ): return \"\" . join ( self . code_lines ) def set_classes ( self ): tree = ast . parse ( \"\" . join ( self . code_lines )) visitor = aim . ClassVisitor () visitor . visit ( tree ) self . classes = visitor . classes return def get_class_methods ( self , name ): # BUG: how does this work for methods with the same name? for c in self . classes : if c [ \"name\" ] == name : class_code_list = self . code_lines [ c [ \"lineno\" ] - 1 : c [ \"end_lineno\" ] + 1 ] tree = ast . parse ( \"\" . join ( class_code_list )) visitor = aim . MethodVisitor () visitor . visit ( tree ) return class_code_list , visitor raise ValueError ( f \"Class { name } not found\" ) def get_class_string ( self , name , methods_flag = False ): if methods_flag : code_lines , visitor = self . get_class_methods ( name ) res = {} for m in visitor . methods : res [ m [ \"name\" ]] = \"\" . join ( code_lines [ m [ \"lineno\" ] - 1 : m [ \"end_lineno\" ] + 1 ] ) return res else : for c in self . classes : if c [ \"name\" ] == name : return \"\" . join ( self . code_lines [ c [ \"lineno\" ] - 1 : c [ \"end_lineno\" ] + 1 ] )","title":"PythonCode"},{"location":"autoapi/aimigrate/files/#aimigrate.files.get_python_files","text":"Recursively retrieves all Python files from the specified directory. Parameters: Name Type Description Default source_dir str The root directory to search for Python files. required gitignore bool Whether to use the .gitignore file to filter files. False Returns: Name Type Description list A list of file paths to Python files found within the directory. Source code in aimigrate/files.py 15 16 17 18 19 20 21 22 23 24 25 26 def get_python_files ( source_dir , gitignore = False , filter = [ \".py\" ]): \"\"\" Recursively retrieves all Python files from the specified directory. Args: source_dir (str): The root directory to search for Python files. gitignore (bool, optional): Whether to use the .gitignore file to filter files. Returns: list: A list of file paths to Python files found within the directory. \"\"\" return get_repository_files ( source_dir , gitignore = gitignore , filter = filter )","title":"get_python_files"},{"location":"autoapi/aimigrate/files/#aimigrate.files.get_repository_files","text":"Recursively retrieves all files from the specified directory. Parameters: Name Type Description Default source_dir str The root directory to search for Python files. required gitignore bool Whether to use the .gitignore file to filter files. False filter list of str A list of file suffixes to filter the files ['.py'] Returns: Name Type Description list A list of file paths to files found within the directory. Source code in aimigrate/files.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def get_repository_files ( source_dir , gitignore = False , filter = [ \".py\" ]): \"\"\" Recursively retrieves all files from the specified directory. Args: source_dir (str): The root directory to search for Python files. gitignore (bool, optional): Whether to use the .gitignore file to filter files. filter (list of str, optional): A list of file suffixes to filter the files Returns: list: A list of file paths to files found within the directory. \"\"\" if isinstance ( source_dir , str ): source_dir = sc . path ( source_dir ) python_files = [] if gitignore : with aim . utils . TemporaryDirectoryChange ( source_dir ): files = subprocess . check_output ( \"git ls-files\" , shell = True ) . splitlines () for file in files : decoded = file . decode () if filter is not None : for suffix in filter : if decoded . endswith ( suffix ): python_files . append ( decoded ) break else : python_files . append ( decoded ) python_files = [ sc . path ( files ) for files in python_files ] else : for root , _ , files in os . walk ( source_dir ): for file in files : if filter is not None : for suffix in filter : if file . endswith ( suffix ): python_files . append ( os . path . join ( root , file )) else : python_files . append ( os . path . join ( root , file )) python_files = [ sc . path ( file ) . relative_to ( source_dir ) for file in python_files ] return python_files","title":"get_repository_files"},{"location":"autoapi/aimigrate/migrate_core/","text":"CoreCodeFile Bases: prettyobj A class to hold the original and migrated code Source code in aimigrate/migrate_core.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class CoreCodeFile ( sc . prettyobj ): \"\"\" A class to hold the original and migrated code \"\"\" def __init__ ( self , source , dest , file , process = True ): self . source = source self . dest = dest self . file = file self . python_code = None self . orig_str = None self . prompt = None self . chatter = None self . n_tokens = None self . response = None self . new_str = None self . error = None self . timer = None self . cost = { \"total\" : 0 , \"prompt\" : 0 , \"completion\" : 0 , \"cost\" : 0 } if process : self . process_code () return def process_code ( self ): \"\"\"Parse the Python file into a string\"\"\" self . python_code = aim . PythonCode ( self . source ) self . orig_str = self . python_code . get_code_string () return def make_prompt ( self , base_prompt , prompt_kwargs , encoder = None ): \"\"\"Create the prompt for the LLM\"\"\" self . prompt = base_prompt . format ( code = self . orig_str , ** prompt_kwargs ) if encoder is not None : self . n_tokens = len ( encoder . encode ( self . prompt ) ) # Not strictly needed, but useful to know else : self . n_tokens = - 1 return def run_query ( self , chatter ): \"\"\"Where everything happens!!\"\"\" with sc . timer ( self . file ) as self . timer : self . response = chatter ( self . prompt ) return self . response def parse_response ( self ): \"\"\"Extract code from the response object\"\"\" result_string = self . response match_patterns = [ r \"```python(.*?)```\" , r \"```(.*?)```\" ] for match_pattern in match_patterns : code_match = re . compile ( match_pattern , re . DOTALL ) . search ( result_string ) if code_match : break if code_match : self . new_str = code_match . group ( 1 ) else : self . new_str = result_string return def run ( self , chatter , save = True ): \"\"\"Run the migration, using the supplied LLM (chatter)\"\"\" self . run_query ( chatter ) self . parse_response () if save : self . save () return self . response def save ( self ): \"\"\"Write to file\"\"\" sc . makefilepath ( self . dest , makedirs = True ) sc . savetext ( self . dest , self . new_str ) return make_prompt ( base_prompt , prompt_kwargs , encoder = None ) Create the prompt for the LLM Source code in aimigrate/migrate_core.py 146 147 148 149 150 151 152 153 154 155 def make_prompt ( self , base_prompt , prompt_kwargs , encoder = None ): \"\"\"Create the prompt for the LLM\"\"\" self . prompt = base_prompt . format ( code = self . orig_str , ** prompt_kwargs ) if encoder is not None : self . n_tokens = len ( encoder . encode ( self . prompt ) ) # Not strictly needed, but useful to know else : self . n_tokens = - 1 return parse_response () Extract code from the response object Source code in aimigrate/migrate_core.py 163 164 165 166 167 168 169 170 171 172 173 174 175 def parse_response ( self ): \"\"\"Extract code from the response object\"\"\" result_string = self . response match_patterns = [ r \"```python(.*?)```\" , r \"```(.*?)```\" ] for match_pattern in match_patterns : code_match = re . compile ( match_pattern , re . DOTALL ) . search ( result_string ) if code_match : break if code_match : self . new_str = code_match . group ( 1 ) else : self . new_str = result_string return process_code () Parse the Python file into a string Source code in aimigrate/migrate_core.py 140 141 142 143 144 def process_code ( self ): \"\"\"Parse the Python file into a string\"\"\" self . python_code = aim . PythonCode ( self . source ) self . orig_str = self . python_code . get_code_string () return run ( chatter , save = True ) Run the migration, using the supplied LLM (chatter) Source code in aimigrate/migrate_core.py 177 178 179 180 181 182 183 def run ( self , chatter , save = True ): \"\"\"Run the migration, using the supplied LLM (chatter)\"\"\" self . run_query ( chatter ) self . parse_response () if save : self . save () return self . response run_query ( chatter ) Where everything happens!! Source code in aimigrate/migrate_core.py 157 158 159 160 161 def run_query ( self , chatter ): \"\"\"Where everything happens!!\"\"\" with sc . timer ( self . file ) as self . timer : self . response = chatter ( self . prompt ) return self . response save () Write to file Source code in aimigrate/migrate_core.py 185 186 187 188 189 def save ( self ): \"\"\"Write to file\"\"\" sc . makefilepath ( self . dest , makedirs = True ) sc . savetext ( self . dest , self . new_str ) return CoreMigrate Bases: prettyobj Source code in aimigrate/migrate_core.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class CoreMigrate ( sc . prettyobj ): def make_code_files ( self ): if self . verbose : self . log ( \"Parsing the files...\" ) if self . files is None : self . files = aim . get_python_files ( self . source_dir ) else : self . files = sc . tolist ( self . files ) if not len ( self . files ): errormsg = ( f \"Could not find any Python files to migrate in { self . source_dir } \" ) raise FileNotFoundError ( errormsg ) for file in self . files : source = self . source_dir / file dest = self . dest_dir / file code_file = aim . CoreCodeFile ( source = source , dest = dest , file = file ) # Actually do the processing self . code_files . append ( code_file ) def log ( self , string , color = \"green\" ): \"\"\"Print if self.verbose is True\"\"\" if self . verbose : printfunc = dict ( default = print , red = sc . printred , green = sc . printgreen , blue = sc . printcyan , yellow = sc . printyellow , )[ color ] printfunc ( string ) return def run_single ( self , code_file ): \"\"\"Where everything happens!!\"\"\" self . log ( f \"Migrating { code_file . file } \" ) try : code_file . run ( self . chatter , save = self . save ) except Exception as E : errormsg = f \"Could not parse { code_file . file } : { E } \" self . errors . append ( errormsg ) raise E if self . die else print ( errormsg ) return def run ( self ): raise NotImplementedError def _run ( self ): \"\"\"Run all steps of the process\"\"\" if self . encoder is None : self . make_encoder () if self . chatter is None : self . make_chatter () self . log ( f \" \\n Starting migration of { self . source_dir } \" , color = \"blue\" ) if self . verbose : self . log ( f \" \\n Migrating { len ( self . files ) } files\" , color = \"blue\" ) self . log ( f \" { sc . newlinejoin ( self . files ) } \" , color = \"default\" ) assert len ( self . code_files ) == len ( self . files ), ( f \"Length of code_files ( { len ( self . code_files ) } ) does not match length of files ( { len ( self . files ) } )\" ) self . timer = sc . timer () if self . parallel : sc . parallelize ( self . run_single , self . code_files , parallelizer = \"thread\" ) else : for code_file in self . code_files : self . run_single ( code_file ) self . timer . toc ( \"Total time\" ) return def make_encoder ( self ): self . log ( \"Creating encoder...\" ) try : self . encoder = tiktoken . encoding_for_model ( self . model ) # encoder (for counting tokens) except KeyError as E : self . log ( f \"Could not create encoder for { self . model } : { E } \" , color = \"yellow\" ) self . encoder = None def make_chatter ( self ): \"\"\"Create the LLM agent\"\"\" self . log ( \"Creating agent...\" ) self . chatter = aim . SimpleQuery ( model = self . model , ** self . model_kw ) return def parse_library ( self ): \"\"\"Extract the right folder for library\"\"\" self . log ( \"Parsing library folder\" ) if isinstance ( self . library , types . ModuleType ): self . library = sc . thispath ( self . library ) . parent self . library = sc . path ( self . library ) if not self . library . is_dir (): errormsg = f \"The library must be supplied as the module or the folder path, not { self . library } \" raise FileNotFoundError ( errormsg ) return _run () Run all steps of the process Source code in aimigrate/migrate_core.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def _run ( self ): \"\"\"Run all steps of the process\"\"\" if self . encoder is None : self . make_encoder () if self . chatter is None : self . make_chatter () self . log ( f \" \\n Starting migration of { self . source_dir } \" , color = \"blue\" ) if self . verbose : self . log ( f \" \\n Migrating { len ( self . files ) } files\" , color = \"blue\" ) self . log ( f \" { sc . newlinejoin ( self . files ) } \" , color = \"default\" ) assert len ( self . code_files ) == len ( self . files ), ( f \"Length of code_files ( { len ( self . code_files ) } ) does not match length of files ( { len ( self . files ) } )\" ) self . timer = sc . timer () if self . parallel : sc . parallelize ( self . run_single , self . code_files , parallelizer = \"thread\" ) else : for code_file in self . code_files : self . run_single ( code_file ) self . timer . toc ( \"Total time\" ) return log ( string , color = 'green' ) Print if self.verbose is True Source code in aimigrate/migrate_core.py 38 39 40 41 42 43 44 45 46 47 48 49 def log ( self , string , color = \"green\" ): \"\"\"Print if self.verbose is True\"\"\" if self . verbose : printfunc = dict ( default = print , red = sc . printred , green = sc . printgreen , blue = sc . printcyan , yellow = sc . printyellow , )[ color ] printfunc ( string ) return make_chatter () Create the LLM agent Source code in aimigrate/migrate_core.py 99 100 101 102 103 def make_chatter ( self ): \"\"\"Create the LLM agent\"\"\" self . log ( \"Creating agent...\" ) self . chatter = aim . SimpleQuery ( model = self . model , ** self . model_kw ) return parse_library () Extract the right folder for library Source code in aimigrate/migrate_core.py 105 106 107 108 109 110 111 112 113 114 def parse_library ( self ): \"\"\"Extract the right folder for library\"\"\" self . log ( \"Parsing library folder\" ) if isinstance ( self . library , types . ModuleType ): self . library = sc . thispath ( self . library ) . parent self . library = sc . path ( self . library ) if not self . library . is_dir (): errormsg = f \"The library must be supplied as the module or the folder path, not { self . library } \" raise FileNotFoundError ( errormsg ) return run_single ( code_file ) Where everything happens!! Source code in aimigrate/migrate_core.py 51 52 53 54 55 56 57 58 59 60 def run_single ( self , code_file ): \"\"\"Where everything happens!!\"\"\" self . log ( f \"Migrating { code_file . file } \" ) try : code_file . run ( self . chatter , save = self . save ) except Exception as E : errormsg = f \"Could not parse { code_file . file } : { E } \" self . errors . append ( errormsg ) raise E if self . die else print ( errormsg ) return","title":"Migrate core"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreCodeFile","text":"Bases: prettyobj A class to hold the original and migrated code Source code in aimigrate/migrate_core.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 class CoreCodeFile ( sc . prettyobj ): \"\"\" A class to hold the original and migrated code \"\"\" def __init__ ( self , source , dest , file , process = True ): self . source = source self . dest = dest self . file = file self . python_code = None self . orig_str = None self . prompt = None self . chatter = None self . n_tokens = None self . response = None self . new_str = None self . error = None self . timer = None self . cost = { \"total\" : 0 , \"prompt\" : 0 , \"completion\" : 0 , \"cost\" : 0 } if process : self . process_code () return def process_code ( self ): \"\"\"Parse the Python file into a string\"\"\" self . python_code = aim . PythonCode ( self . source ) self . orig_str = self . python_code . get_code_string () return def make_prompt ( self , base_prompt , prompt_kwargs , encoder = None ): \"\"\"Create the prompt for the LLM\"\"\" self . prompt = base_prompt . format ( code = self . orig_str , ** prompt_kwargs ) if encoder is not None : self . n_tokens = len ( encoder . encode ( self . prompt ) ) # Not strictly needed, but useful to know else : self . n_tokens = - 1 return def run_query ( self , chatter ): \"\"\"Where everything happens!!\"\"\" with sc . timer ( self . file ) as self . timer : self . response = chatter ( self . prompt ) return self . response def parse_response ( self ): \"\"\"Extract code from the response object\"\"\" result_string = self . response match_patterns = [ r \"```python(.*?)```\" , r \"```(.*?)```\" ] for match_pattern in match_patterns : code_match = re . compile ( match_pattern , re . DOTALL ) . search ( result_string ) if code_match : break if code_match : self . new_str = code_match . group ( 1 ) else : self . new_str = result_string return def run ( self , chatter , save = True ): \"\"\"Run the migration, using the supplied LLM (chatter)\"\"\" self . run_query ( chatter ) self . parse_response () if save : self . save () return self . response def save ( self ): \"\"\"Write to file\"\"\" sc . makefilepath ( self . dest , makedirs = True ) sc . savetext ( self . dest , self . new_str ) return","title":"CoreCodeFile"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreCodeFile.make_prompt","text":"Create the prompt for the LLM Source code in aimigrate/migrate_core.py 146 147 148 149 150 151 152 153 154 155 def make_prompt ( self , base_prompt , prompt_kwargs , encoder = None ): \"\"\"Create the prompt for the LLM\"\"\" self . prompt = base_prompt . format ( code = self . orig_str , ** prompt_kwargs ) if encoder is not None : self . n_tokens = len ( encoder . encode ( self . prompt ) ) # Not strictly needed, but useful to know else : self . n_tokens = - 1 return","title":"make_prompt"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreCodeFile.parse_response","text":"Extract code from the response object Source code in aimigrate/migrate_core.py 163 164 165 166 167 168 169 170 171 172 173 174 175 def parse_response ( self ): \"\"\"Extract code from the response object\"\"\" result_string = self . response match_patterns = [ r \"```python(.*?)```\" , r \"```(.*?)```\" ] for match_pattern in match_patterns : code_match = re . compile ( match_pattern , re . DOTALL ) . search ( result_string ) if code_match : break if code_match : self . new_str = code_match . group ( 1 ) else : self . new_str = result_string return","title":"parse_response"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreCodeFile.process_code","text":"Parse the Python file into a string Source code in aimigrate/migrate_core.py 140 141 142 143 144 def process_code ( self ): \"\"\"Parse the Python file into a string\"\"\" self . python_code = aim . PythonCode ( self . source ) self . orig_str = self . python_code . get_code_string () return","title":"process_code"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreCodeFile.run","text":"Run the migration, using the supplied LLM (chatter) Source code in aimigrate/migrate_core.py 177 178 179 180 181 182 183 def run ( self , chatter , save = True ): \"\"\"Run the migration, using the supplied LLM (chatter)\"\"\" self . run_query ( chatter ) self . parse_response () if save : self . save () return self . response","title":"run"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreCodeFile.run_query","text":"Where everything happens!! Source code in aimigrate/migrate_core.py 157 158 159 160 161 def run_query ( self , chatter ): \"\"\"Where everything happens!!\"\"\" with sc . timer ( self . file ) as self . timer : self . response = chatter ( self . prompt ) return self . response","title":"run_query"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreCodeFile.save","text":"Write to file Source code in aimigrate/migrate_core.py 185 186 187 188 189 def save ( self ): \"\"\"Write to file\"\"\" sc . makefilepath ( self . dest , makedirs = True ) sc . savetext ( self . dest , self . new_str ) return","title":"save"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreMigrate","text":"Bases: prettyobj Source code in aimigrate/migrate_core.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class CoreMigrate ( sc . prettyobj ): def make_code_files ( self ): if self . verbose : self . log ( \"Parsing the files...\" ) if self . files is None : self . files = aim . get_python_files ( self . source_dir ) else : self . files = sc . tolist ( self . files ) if not len ( self . files ): errormsg = ( f \"Could not find any Python files to migrate in { self . source_dir } \" ) raise FileNotFoundError ( errormsg ) for file in self . files : source = self . source_dir / file dest = self . dest_dir / file code_file = aim . CoreCodeFile ( source = source , dest = dest , file = file ) # Actually do the processing self . code_files . append ( code_file ) def log ( self , string , color = \"green\" ): \"\"\"Print if self.verbose is True\"\"\" if self . verbose : printfunc = dict ( default = print , red = sc . printred , green = sc . printgreen , blue = sc . printcyan , yellow = sc . printyellow , )[ color ] printfunc ( string ) return def run_single ( self , code_file ): \"\"\"Where everything happens!!\"\"\" self . log ( f \"Migrating { code_file . file } \" ) try : code_file . run ( self . chatter , save = self . save ) except Exception as E : errormsg = f \"Could not parse { code_file . file } : { E } \" self . errors . append ( errormsg ) raise E if self . die else print ( errormsg ) return def run ( self ): raise NotImplementedError def _run ( self ): \"\"\"Run all steps of the process\"\"\" if self . encoder is None : self . make_encoder () if self . chatter is None : self . make_chatter () self . log ( f \" \\n Starting migration of { self . source_dir } \" , color = \"blue\" ) if self . verbose : self . log ( f \" \\n Migrating { len ( self . files ) } files\" , color = \"blue\" ) self . log ( f \" { sc . newlinejoin ( self . files ) } \" , color = \"default\" ) assert len ( self . code_files ) == len ( self . files ), ( f \"Length of code_files ( { len ( self . code_files ) } ) does not match length of files ( { len ( self . files ) } )\" ) self . timer = sc . timer () if self . parallel : sc . parallelize ( self . run_single , self . code_files , parallelizer = \"thread\" ) else : for code_file in self . code_files : self . run_single ( code_file ) self . timer . toc ( \"Total time\" ) return def make_encoder ( self ): self . log ( \"Creating encoder...\" ) try : self . encoder = tiktoken . encoding_for_model ( self . model ) # encoder (for counting tokens) except KeyError as E : self . log ( f \"Could not create encoder for { self . model } : { E } \" , color = \"yellow\" ) self . encoder = None def make_chatter ( self ): \"\"\"Create the LLM agent\"\"\" self . log ( \"Creating agent...\" ) self . chatter = aim . SimpleQuery ( model = self . model , ** self . model_kw ) return def parse_library ( self ): \"\"\"Extract the right folder for library\"\"\" self . log ( \"Parsing library folder\" ) if isinstance ( self . library , types . ModuleType ): self . library = sc . thispath ( self . library ) . parent self . library = sc . path ( self . library ) if not self . library . is_dir (): errormsg = f \"The library must be supplied as the module or the folder path, not { self . library } \" raise FileNotFoundError ( errormsg ) return","title":"CoreMigrate"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreMigrate._run","text":"Run all steps of the process Source code in aimigrate/migrate_core.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def _run ( self ): \"\"\"Run all steps of the process\"\"\" if self . encoder is None : self . make_encoder () if self . chatter is None : self . make_chatter () self . log ( f \" \\n Starting migration of { self . source_dir } \" , color = \"blue\" ) if self . verbose : self . log ( f \" \\n Migrating { len ( self . files ) } files\" , color = \"blue\" ) self . log ( f \" { sc . newlinejoin ( self . files ) } \" , color = \"default\" ) assert len ( self . code_files ) == len ( self . files ), ( f \"Length of code_files ( { len ( self . code_files ) } ) does not match length of files ( { len ( self . files ) } )\" ) self . timer = sc . timer () if self . parallel : sc . parallelize ( self . run_single , self . code_files , parallelizer = \"thread\" ) else : for code_file in self . code_files : self . run_single ( code_file ) self . timer . toc ( \"Total time\" ) return","title":"_run"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreMigrate.log","text":"Print if self.verbose is True Source code in aimigrate/migrate_core.py 38 39 40 41 42 43 44 45 46 47 48 49 def log ( self , string , color = \"green\" ): \"\"\"Print if self.verbose is True\"\"\" if self . verbose : printfunc = dict ( default = print , red = sc . printred , green = sc . printgreen , blue = sc . printcyan , yellow = sc . printyellow , )[ color ] printfunc ( string ) return","title":"log"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreMigrate.make_chatter","text":"Create the LLM agent Source code in aimigrate/migrate_core.py 99 100 101 102 103 def make_chatter ( self ): \"\"\"Create the LLM agent\"\"\" self . log ( \"Creating agent...\" ) self . chatter = aim . SimpleQuery ( model = self . model , ** self . model_kw ) return","title":"make_chatter"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreMigrate.parse_library","text":"Extract the right folder for library Source code in aimigrate/migrate_core.py 105 106 107 108 109 110 111 112 113 114 def parse_library ( self ): \"\"\"Extract the right folder for library\"\"\" self . log ( \"Parsing library folder\" ) if isinstance ( self . library , types . ModuleType ): self . library = sc . thispath ( self . library ) . parent self . library = sc . path ( self . library ) if not self . library . is_dir (): errormsg = f \"The library must be supplied as the module or the folder path, not { self . library } \" raise FileNotFoundError ( errormsg ) return","title":"parse_library"},{"location":"autoapi/aimigrate/migrate_core/#aimigrate.migrate_core.CoreMigrate.run_single","text":"Where everything happens!! Source code in aimigrate/migrate_core.py 51 52 53 54 55 56 57 58 59 60 def run_single ( self , code_file ): \"\"\"Where everything happens!!\"\"\" self . log ( f \"Migrating { code_file . file } \" ) try : code_file . run ( self . chatter , save = self . save ) except Exception as E : errormsg = f \"Could not parse { code_file . file } : { E } \" self . errors . append ( errormsg ) raise E if self . die else print ( errormsg ) return","title":"run_single"},{"location":"autoapi/aimigrate/migrate_diff/","text":"Migrate using diffs MigrateDiff Bases: CoreMigrate Handle all steps of code migration Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / path / module the library to base the migration on (i.e., Starsim or the path to it) None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None diff_file str if provided, load this diff file instead of computing it via library/v_from/v_to, i.e. git diff v1.0.3 v2.2.0 > diff_file None diff str if provided, use this diff rather than loading it from file None model str the LLM to use None model_kw dict any keywords to pass to the model None include list the list of files to include from the diff None exclude list the list of files to not include from the diff None base_prompt str the prompt template that will be populated with the diff and file information None diff_speed bool whether to use include/exclude to choose files for diff construction. (default False) False filter list if diff_speed=True, a list of file extensions to include when constructing the diff (default [\".py\"]) None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import starsim as ss import starsim_ai as ssai M = aim.Migrate( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) v_from = 'v1.0.3', # can be any valid git tag or hash v_to = 'v2.2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_diff.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class MigrateDiff ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/path/module): the library to base the migration on (i.e., Starsim or the path to it) v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in diff_file (str): if provided, load this diff file instead of computing it via library/v_from/v_to, i.e. git diff v1.0.3 v2.2.0 > diff_file diff (str): if provided, use this diff rather than loading it from file model (str): the LLM to use model_kw (dict): any keywords to pass to the model include (list): the list of files to include from the diff exclude (list): the list of files to not include from the diff base_prompt (str): the prompt template that will be populated with the diff and file information diff_speed (bool): whether to use include/exclude to choose files for diff construction. (default False) filter (list): if diff_speed=True, a list of file extensions to include when constructing the diff (default [\".py\"]) parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import starsim as ss import starsim_ai as ssai M = aim.Migrate( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) v_from = 'v1.0.3', # can be any valid git tag or hash v_to = 'v2.2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , # Migration settings include = None , exclude = None , diff_file = None , diff = None , patience = None , diff_speed = False , filter = None , # Diff settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run settings # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . include = sc . ifelse ( include , DEFAULT_INCLUDE ) self . exclude = sc . ifelse ( exclude , DEFAULT_EXCLUDE ) self . diff_file = diff_file self . diff = diff self . patience = patience self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . filter = sc . ifelse ( filter , [ \".py\" ]) self . diff_speed = diff_speed self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] # Optionally run if run : self . run () return def make_diff ( self ): self . log ( \"Making the diff\" ) if self . diff : return elif self . diff_file : with open ( self . diff_file , \"r\" ) as f : self . diff = f . readlines () else : self . parse_library () if self . diff_speed : self . diff = \"\" with aim . utils . TemporaryDirectoryChange ( self . library ): # check that the revisions are good assert not sc . runcommand ( f \"git rev-parse --verify { self . v_from } \" ) . startswith ( \"fatal\" ), \"Invalid v_from\" assert not sc . runcommand ( f \"git rev-parse --verify { self . v_to } \" ) . startswith ( \"fatal\" ), \"Invalid v_to\" # get current git commit current_head = sc . runcommand ( \"git rev-parse HEAD\" ) # get the files in the library library_files = aim . files . get_python_files ( self . library , gitignore = True , filter = self . filter ) assert not sc . runcommand ( f \"git checkout { current_head } \" ) . startswith ( \"error\" ), \"Error checking out previous commit\" # get the diff for each file that passes the include/exclude for current_file in library_files : if self . include and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . include ): continue elif self . exclude and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . exclude ): continue else : self . diff += sc . runcommand ( f \"git diff { '--patience ' if self . patience else '' }{ self . v_from } { self . v_to } -- { current_file } \" ) else : with aim . utils . TemporaryDirectoryChange ( self . library ): assert not sc . runcommand ( f \"git rev-parse --verify { self . v_from } \" ) . startswith ( \"fatal\" ), \"Invalid v_from\" assert not sc . runcommand ( f \"git rev-parse --verify { self . v_to } \" ) . startswith ( \"fatal\" ), \"Invalid v_to\" self . diff = sc . runcommand ( f \"git diff { self . v_from } { self . v_to } \" ) def parse_diff ( self ): self . log ( \"Parsing the diff\" ) self . git_diff = aim . GitDiff ( self . diff , include_patterns = self . include , exclude_patterns = self . exclude ) self . git_diff . summarize () # summarize self . n_tokens = self . git_diff . count_all_tokens ( model = self . model ) # NB: not implemented for all models if self . verbose and ( self . n_tokens > - 1 ): print ( f \"Number of tokens in the diff: { self . n_tokens } \" ) def make_prompts ( self ): diff_string = self . git_diff . get_diff_string () for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . stem , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"diff\" : diff_string , }, encoder = self . encoder , ) return def run ( self ): # construct the diff self . make_diff () # parse the diff self . parse_diff () # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run ()","title":"Migrate diff"},{"location":"autoapi/aimigrate/migrate_diff/#aimigrate.migrate_diff.MigrateDiff","text":"Bases: CoreMigrate Handle all steps of code migration Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / path / module the library to base the migration on (i.e., Starsim or the path to it) None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None diff_file str if provided, load this diff file instead of computing it via library/v_from/v_to, i.e. git diff v1.0.3 v2.2.0 > diff_file None diff str if provided, use this diff rather than loading it from file None model str the LLM to use None model_kw dict any keywords to pass to the model None include list the list of files to include from the diff None exclude list the list of files to not include from the diff None base_prompt str the prompt template that will be populated with the diff and file information None diff_speed bool whether to use include/exclude to choose files for diff construction. (default False) False filter list if diff_speed=True, a list of file extensions to include when constructing the diff (default [\".py\"]) None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import starsim as ss import starsim_ai as ssai M = aim.Migrate( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) v_from = 'v1.0.3', # can be any valid git tag or hash v_to = 'v2.2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_diff.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class MigrateDiff ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/path/module): the library to base the migration on (i.e., Starsim or the path to it) v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in diff_file (str): if provided, load this diff file instead of computing it via library/v_from/v_to, i.e. git diff v1.0.3 v2.2.0 > diff_file diff (str): if provided, use this diff rather than loading it from file model (str): the LLM to use model_kw (dict): any keywords to pass to the model include (list): the list of files to include from the diff exclude (list): the list of files to not include from the diff base_prompt (str): the prompt template that will be populated with the diff and file information diff_speed (bool): whether to use include/exclude to choose files for diff construction. (default False) filter (list): if diff_speed=True, a list of file extensions to include when constructing the diff (default [\".py\"]) parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import starsim as ss import starsim_ai as ssai M = aim.Migrate( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) v_from = 'v1.0.3', # can be any valid git tag or hash v_to = 'v2.2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , # Migration settings include = None , exclude = None , diff_file = None , diff = None , patience = None , diff_speed = False , filter = None , # Diff settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run settings # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . include = sc . ifelse ( include , DEFAULT_INCLUDE ) self . exclude = sc . ifelse ( exclude , DEFAULT_EXCLUDE ) self . diff_file = diff_file self . diff = diff self . patience = patience self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . filter = sc . ifelse ( filter , [ \".py\" ]) self . diff_speed = diff_speed self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] # Optionally run if run : self . run () return def make_diff ( self ): self . log ( \"Making the diff\" ) if self . diff : return elif self . diff_file : with open ( self . diff_file , \"r\" ) as f : self . diff = f . readlines () else : self . parse_library () if self . diff_speed : self . diff = \"\" with aim . utils . TemporaryDirectoryChange ( self . library ): # check that the revisions are good assert not sc . runcommand ( f \"git rev-parse --verify { self . v_from } \" ) . startswith ( \"fatal\" ), \"Invalid v_from\" assert not sc . runcommand ( f \"git rev-parse --verify { self . v_to } \" ) . startswith ( \"fatal\" ), \"Invalid v_to\" # get current git commit current_head = sc . runcommand ( \"git rev-parse HEAD\" ) # get the files in the library library_files = aim . files . get_python_files ( self . library , gitignore = True , filter = self . filter ) assert not sc . runcommand ( f \"git checkout { current_head } \" ) . startswith ( \"error\" ), \"Error checking out previous commit\" # get the diff for each file that passes the include/exclude for current_file in library_files : if self . include and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . include ): continue elif self . exclude and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . exclude ): continue else : self . diff += sc . runcommand ( f \"git diff { '--patience ' if self . patience else '' }{ self . v_from } { self . v_to } -- { current_file } \" ) else : with aim . utils . TemporaryDirectoryChange ( self . library ): assert not sc . runcommand ( f \"git rev-parse --verify { self . v_from } \" ) . startswith ( \"fatal\" ), \"Invalid v_from\" assert not sc . runcommand ( f \"git rev-parse --verify { self . v_to } \" ) . startswith ( \"fatal\" ), \"Invalid v_to\" self . diff = sc . runcommand ( f \"git diff { self . v_from } { self . v_to } \" ) def parse_diff ( self ): self . log ( \"Parsing the diff\" ) self . git_diff = aim . GitDiff ( self . diff , include_patterns = self . include , exclude_patterns = self . exclude ) self . git_diff . summarize () # summarize self . n_tokens = self . git_diff . count_all_tokens ( model = self . model ) # NB: not implemented for all models if self . verbose and ( self . n_tokens > - 1 ): print ( f \"Number of tokens in the diff: { self . n_tokens } \" ) def make_prompts ( self ): diff_string = self . git_diff . get_diff_string () for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . stem , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"diff\" : diff_string , }, encoder = self . encoder , ) return def run ( self ): # construct the diff self . make_diff () # parse the diff self . parse_diff () # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run ()","title":"MigrateDiff"},{"location":"autoapi/aimigrate/migrate_oob/","text":"Migrate out of the box MigrateOOB Bases: CoreMigrate Handle all steps of code migration using an LLM \"out of the box\". Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / module the library to base the migration on None library_alias str string to use as the alias for the library None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None model str the LLM to use None model_kw dict any keywords to pass to the model None base_prompt str the prompt template that will be populated with the diff and file information None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import aimigrate as aim M = aim.MigrateOOB( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the name of the library as a string (e.g., starsim) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # use a git tag v_to = 'v2.0', # use a git tag model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_oob.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class MigrateOOB ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration using an LLM \"out of the box\". Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/module): the library to base the migration on library_alias (str): string to use as the alias for the library v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in model (str): the LLM to use model_kw (dict): any keywords to pass to the model base_prompt (str): the prompt template that will be populated with the diff and file information parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import aimigrate as aim M = aim.MigrateOOB( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the name of the library as a string (e.g., starsim) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # use a git tag v_to = 'v2.0', # use a git tag model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , # Migration settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run setting # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] assert isinstance ( self . library , ( str , types . ModuleType )), ( \"Library must be a string or module\" ) # Optionally run if run : self . run () return def make_prompts ( self ): self . make_encoder () for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . __name__ if hasattr ( self . library , \"__name__\" ) else self . library , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"v_from\" : self . v_from , \"v_to\" : self . v_to , }, encoder = self . encoder , ) def run ( self ): # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run ()","title":"Migrate oob"},{"location":"autoapi/aimigrate/migrate_oob/#aimigrate.migrate_oob.MigrateOOB","text":"Bases: CoreMigrate Handle all steps of code migration using an LLM \"out of the box\". Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / module the library to base the migration on None library_alias str string to use as the alias for the library None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None model str the LLM to use None model_kw dict any keywords to pass to the model None base_prompt str the prompt template that will be populated with the diff and file information None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import aimigrate as aim M = aim.MigrateOOB( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the name of the library as a string (e.g., starsim) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # use a git tag v_to = 'v2.0', # use a git tag model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_oob.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class MigrateOOB ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration using an LLM \"out of the box\". Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/module): the library to base the migration on library_alias (str): string to use as the alias for the library v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in model (str): the LLM to use model_kw (dict): any keywords to pass to the model base_prompt (str): the prompt template that will be populated with the diff and file information parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import aimigrate as aim M = aim.MigrateOOB( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the name of the library as a string (e.g., starsim) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # use a git tag v_to = 'v2.0', # use a git tag model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , # Migration settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run setting # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] assert isinstance ( self . library , ( str , types . ModuleType )), ( \"Library must be a string or module\" ) # Optionally run if run : self . run () return def make_prompts ( self ): self . make_encoder () for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . __name__ if hasattr ( self . library , \"__name__\" ) else self . library , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"v_from\" : self . v_from , \"v_to\" : self . v_to , }, encoder = self . encoder , ) def run ( self ): # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run ()","title":"MigrateOOB"},{"location":"autoapi/aimigrate/migrate_repo/","text":"Migrate using the code in the target libarary as context. MigrateRepo Bases: CoreMigrate Handle all steps of code migration using files (e.g., code) from the target library as context. Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / path / module the library to base the migration on (i.e., the path to a git repository) None library_alias str string to use as the alias for the library None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None model str the LLM to use None model_kw dict any keywords to pass to the model None include list the list of files to include from the diff None exclude list the list of files to not include from the diff None base_prompt str the prompt template that will be populated with the diff and file information None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import aimigrate as aim M = aim.MigrateRepo( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # can be any valid git tag or hash v_to = 'v2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_repo.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class MigrateRepo ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration using files (e.g., code) from the target library as context. Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/path/module): the library to base the migration on (i.e., the path to a git repository) library_alias (str): string to use as the alias for the library v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in model (str): the LLM to use model_kw (dict): any keywords to pass to the model include (list): the list of files to include from the diff exclude (list): the list of files to not include from the diff base_prompt (str): the prompt template that will be populated with the diff and file information parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import aimigrate as aim M = aim.MigrateRepo( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # can be any valid git tag or hash v_to = 'v2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , filter = None , # Migration settings include = None , exclude = None , # Library settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run settings # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . include = sc . ifelse ( include , DEFAULT_INCLUDE ) self . exclude = sc . ifelse ( exclude , DEFAULT_EXCLUDE ) self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . filter = sc . ifelse ( filter , [ \".py\" ]) self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] # Optionally run if run : self . run () return def run ( self ): self . make_encoder () # get the repository files self . get_repo_files () # parse the repository files self . parse_repo_files () # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run () def get_repo_files ( self ): self . log ( \"Getting the repository files\" ) self . parse_library () self . repo_files = [] with aim . utils . TemporaryDirectoryChange ( self . library ): # get current git commit current_head = sc . runcommand ( \"git rev-parse HEAD\" ) assert not sc . runcommand ( f \"git checkout { self . v_to } \" ) . startswith ( \"error\" ), ( \"Invalid v_to\" ) all_repo_files = aim . files . get_python_files ( self . library , gitignore = True , filter = self . filter ) assert not sc . runcommand ( f \"git checkout { current_head } \" ) . startswith ( \"error\" ), \"Error checking out previous commit\" for current_file in all_repo_files : if self . include and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . include ): continue elif self . exclude and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . exclude ): continue else : self . repo_files . append ( current_file ) def parse_repo_files ( self ): self . log ( \"Parsing repository files\" ) self . repo_string = \"\" for current_file in self . repo_files : with open ( self . library / current_file , \"r\" ) as f : self . repo_string += \"\"\"File: {file_name} \\n ''' \\n {code} ''' \\n \"\"\" . format ( file_name = current_file , code = f . read () ) if self . encoder is not None : self . n_tokens = len ( self . encoder . encode ( self . repo_string )) else : self . n_tokens = - 1 if self . verbose and ( self . n_tokens > - 1 ): print ( f \"Number of tokens in repository files: { self . n_tokens } \" ) return def make_prompts ( self ): for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . stem , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"library_code\" : self . repo_string , }, encoder = self . encoder , ) return","title":"Migrate repo"},{"location":"autoapi/aimigrate/migrate_repo/#aimigrate.migrate_repo.MigrateRepo","text":"Bases: CoreMigrate Handle all steps of code migration using files (e.g., code) from the target library as context. Parameters: Name Type Description Default source_dir str / path the source folder (or single file) to migrate required dest_dir str / path the destination folder to put the migrated files in required files list if provided, the list of files to migrate (else, migrate all Python files in the source folder) None library str / path / module the library to base the migration on (i.e., the path to a git repository) None library_alias str string to use as the alias for the library None v_from str the git hash or version of Starsim that the code is currently written in None v_to str the git hash or version of Starsim that the new code should be written in None model str the LLM to use None model_kw dict any keywords to pass to the model None include list the list of files to include from the diff None exclude list the list of files to not include from the diff None base_prompt str the prompt template that will be populated with the diff and file information None parallel bool whether to migrate the files in parallel False verbose bool print information during the migration (default True) True save bool whether to save the files to disk (default True) True run bool whether to perform the migration immediately (default False) False Example :: import aimigrate as aim M = aim.MigrateRepo( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # can be any valid git tag or hash v_to = 'v2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() Source code in aimigrate/migrate_repo.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class MigrateRepo ( aim . CoreMigrate ): \"\"\" Handle all steps of code migration using files (e.g., code) from the target library as context. Args: source_dir (str/path): the source folder (or single file) to migrate dest_dir (str/path): the destination folder to put the migrated files in files (list): if provided, the list of files to migrate (else, migrate all Python files in the source folder) library (str/path/module): the library to base the migration on (i.e., the path to a git repository) library_alias (str): string to use as the alias for the library v_from (str): the git hash or version of Starsim that the code is currently written in v_to (str): the git hash or version of Starsim that the new code should be written in model (str): the LLM to use model_kw (dict): any keywords to pass to the model include (list): the list of files to include from the diff exclude (list): the list of files to not include from the diff base_prompt (str): the prompt template that will be populated with the diff and file information parallel (bool): whether to migrate the files in parallel verbose (bool): print information during the migration (default True) save (bool): whether to save the files to disk (default True) run (bool): whether to perform the migration immediately (default False) **Example**:: import aimigrate as aim M = aim.MigrateRepo( source_dir = '/path/to/your/code/folder', # folder with the code to migrate dest_dir = '/path/to/migrated/folder', # folder to output migrated code into library = ss, # can also be the path to the starsim folder, which must be the cloned repo (not from pypi) library_alias = 'ss', # the alias to use for the library in the prompt (optional) v_from = 'v1.0', # can be any valid git tag or hash v_to = 'v2.0', # ditto model = 'openai:gpt-4o', # use aisuite's provider:model syntax ) M.run() \"\"\" def __init__ ( self , source_dir , dest_dir , files = None , # Input and output folders library = None , library_alias = None , v_from = None , v_to = None , filter = None , # Migration settings include = None , exclude = None , # Library settings model = None , model_kw = None , base_prompt = None , # Model settings parallel = False , verbose = True , save = True , die = False , run = False , ): # Run settings # Inputs self . source_dir = sc . path ( source_dir ) self . dest_dir = sc . path ( dest_dir ) self . files = files self . library = library self . library_alias = library_alias self . v_from = v_from self . v_to = v_to self . include = sc . ifelse ( include , DEFAULT_INCLUDE ) self . exclude = sc . ifelse ( exclude , DEFAULT_EXCLUDE ) self . model = model self . model_kw = sc . mergedicts ( model_kw ) self . base_prompt = sc . ifelse ( base_prompt , DEFAULT_BASE_PROMPT ) self . filter = sc . ifelse ( filter , [ \".py\" ]) self . parallel = parallel self . verbose = verbose self . save = save self . die = die # Populated fields self . chatter = None self . encoder = None self . code_files = [] self . errors = [] # Optionally run if run : self . run () return def run ( self ): self . make_encoder () # get the repository files self . get_repo_files () # parse the repository files self . parse_repo_files () # parse the files for migration self . make_code_files () # make the prompts self . make_prompts () # run self . _run () def get_repo_files ( self ): self . log ( \"Getting the repository files\" ) self . parse_library () self . repo_files = [] with aim . utils . TemporaryDirectoryChange ( self . library ): # get current git commit current_head = sc . runcommand ( \"git rev-parse HEAD\" ) assert not sc . runcommand ( f \"git checkout { self . v_to } \" ) . startswith ( \"error\" ), ( \"Invalid v_to\" ) all_repo_files = aim . files . get_python_files ( self . library , gitignore = True , filter = self . filter ) assert not sc . runcommand ( f \"git checkout { current_head } \" ) . startswith ( \"error\" ), \"Error checking out previous commit\" for current_file in all_repo_files : if self . include and not any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . include ): continue elif self . exclude and any ( fnmatch . fnmatch ( current_file , pattern ) for pattern in self . exclude ): continue else : self . repo_files . append ( current_file ) def parse_repo_files ( self ): self . log ( \"Parsing repository files\" ) self . repo_string = \"\" for current_file in self . repo_files : with open ( self . library / current_file , \"r\" ) as f : self . repo_string += \"\"\"File: {file_name} \\n ''' \\n {code} ''' \\n \"\"\" . format ( file_name = current_file , code = f . read () ) if self . encoder is not None : self . n_tokens = len ( self . encoder . encode ( self . repo_string )) else : self . n_tokens = - 1 if self . verbose and ( self . n_tokens > - 1 ): print ( f \"Number of tokens in repository files: { self . n_tokens } \" ) return def make_prompts ( self ): for code_file in self . code_files : code_file . make_prompt ( self . base_prompt , prompt_kwargs = { \"library\" : self . library . stem , \"library_alias\" : f \" ( { self . library_alias } )\" if self . library_alias else \"\" , \"library_code\" : self . repo_string , }, encoder = self . encoder , ) return","title":"MigrateRepo"},{"location":"autoapi/aimigrate/migration/","text":"Default migrator migrate ( * args , ** kwargs ) Helper function for the Migrate class Source code in aimigrate/migration.py 15 16 17 18 19 def migrate ( * args , ** kwargs ): \"\"\"Helper function for the Migrate class\"\"\" mig = Migrate ( * args , ** kwargs ) mig . run () return mig","title":"Migration"},{"location":"autoapi/aimigrate/migration/#aimigrate.migration.migrate","text":"Helper function for the Migrate class Source code in aimigrate/migration.py 15 16 17 18 19 def migrate ( * args , ** kwargs ): \"\"\"Helper function for the Migrate class\"\"\" mig = Migrate ( * args , ** kwargs ) mig . run () return mig","title":"migrate"},{"location":"autoapi/aimigrate/paths/","text":"paths.py Exposes common paths useful for manipulating datasets and generating figures.","title":"Paths"},{"location":"autoapi/aimigrate/utils/","text":"EmptyCallback A context manager that does nothing when it is called. Example: with EmptyCallback() as callback: # Code that runs without any effect from the callback pass Source code in aimigrate/utils.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class EmptyCallback : \"\"\" A context manager that does nothing when it is called. Example: ```python with EmptyCallback() as callback: # Code that runs without any effect from the callback pass ``` \"\"\" def __enter__ ( self ): return self def __exit__ ( self , exc_type , exc_value , traceback ): pass TemporaryDirectoryChange A context manager to temporarily change the current working directory. Example: with TemporaryDirectoryChange('/path/to/new/dir'): # Code that runs in the new directory pass Attributes: Name Type Description new_dir str The directory to change to. original_dir str The original directory before the change. Methods: Name Description __enter__ Changes the current working directory to new_dir . __exit__ Reverts the current working directory to original_dir . Source code in aimigrate/utils.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class TemporaryDirectoryChange : \"\"\" A context manager to temporarily change the current working directory. Example: ```python with TemporaryDirectoryChange('/path/to/new/dir'): # Code that runs in the new directory pass ``` Attributes: new_dir (str): The directory to change to. original_dir (str): The original directory before the change. Methods: __enter__(): Changes the current working directory to `new_dir`. __exit__(exc_type, exc_value, traceback): Reverts the current working directory to `original_dir`. \"\"\" def __init__ ( self , new_dir ): self . new_dir = new_dir self . original_dir = os . getcwd () def __enter__ ( self ): os . chdir ( self . new_dir ) def __exit__ ( self , exc_type , exc_value , traceback ): os . chdir ( self . original_dir )","title":"Utils"},{"location":"autoapi/aimigrate/utils/#aimigrate.utils.EmptyCallback","text":"A context manager that does nothing when it is called. Example: with EmptyCallback() as callback: # Code that runs without any effect from the callback pass Source code in aimigrate/utils.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class EmptyCallback : \"\"\" A context manager that does nothing when it is called. Example: ```python with EmptyCallback() as callback: # Code that runs without any effect from the callback pass ``` \"\"\" def __enter__ ( self ): return self def __exit__ ( self , exc_type , exc_value , traceback ): pass","title":"EmptyCallback"},{"location":"autoapi/aimigrate/utils/#aimigrate.utils.TemporaryDirectoryChange","text":"A context manager to temporarily change the current working directory. Example: with TemporaryDirectoryChange('/path/to/new/dir'): # Code that runs in the new directory pass Attributes: Name Type Description new_dir str The directory to change to. original_dir str The original directory before the change. Methods: Name Description __enter__ Changes the current working directory to new_dir . __exit__ Reverts the current working directory to original_dir . Source code in aimigrate/utils.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class TemporaryDirectoryChange : \"\"\" A context manager to temporarily change the current working directory. Example: ```python with TemporaryDirectoryChange('/path/to/new/dir'): # Code that runs in the new directory pass ``` Attributes: new_dir (str): The directory to change to. original_dir (str): The original directory before the change. Methods: __enter__(): Changes the current working directory to `new_dir`. __exit__(exc_type, exc_value, traceback): Reverts the current working directory to `original_dir`. \"\"\" def __init__ ( self , new_dir ): self . new_dir = new_dir self . original_dir = os . getcwd () def __enter__ ( self ): os . chdir ( self . new_dir ) def __exit__ ( self , exc_type , exc_value , traceback ): os . chdir ( self . original_dir )","title":"TemporaryDirectoryChange"},{"location":"autoapi/aimigrate/version/","text":"Version and license information.","title":"Version"}]}