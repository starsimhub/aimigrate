diff --git a/.flake8 b/.flake8
new file mode 100644
index 0000000..bf54591
--- /dev/null
+++ b/.flake8
@@ -0,0 +1,11 @@
+# Custom settings for Starsim. Changes:
+# E221: allow multiple spaces before operator
+# E225: allow space around arithmetic operators
+# E226: allow space around arithmetic operators
+# E261: allow one space before comment
+# E272: allow multiple spaces before keyword
+# E501: allow long lines
+# E701: allow multiple statements on a line
+
+[flake8]
+ignore = E221, E225, E226, E261, E272, E501, E701
\ No newline at end of file
diff --git a/.github/dependabot.yaml b/.github/dependabot.yaml
new file mode 100644
index 0000000..2390d8c
--- /dev/null
+++ b/.github/dependabot.yaml
@@ -0,0 +1,10 @@
+version: 2
+updates:
+  - package-ecosystem: "github-actions"
+    directory: "/"
+    schedule:
+      interval: "monthly"
+    groups:
+      github-actions:
+        patterns:
+          - "*"
diff --git a/.github/workflows/tests.yaml b/.github/workflows/tests.yaml
index d740e20..e5a1d6f 100644
--- a/.github/workflows/tests.yaml
+++ b/.github/workflows/tests.yaml
@@ -9,12 +9,12 @@ jobs:
       max-parallel: 8
       matrix:
         os: ['ubuntu-latest']
-        python-version: ['3.9', '3.11']
+        python-version: ['3.10', '3.12']
     runs-on: ${{ matrix.os }}
     name: Install and test
     steps:
       - name: Checkout sources
-        uses: actions/checkout@v2
+        uses: actions/checkout@v4
       - uses: actions/setup-python@master
         with:
           python-version: ${{ matrix.python-version }}
@@ -28,7 +28,7 @@ jobs:
         working-directory: ./tests
         run: pytest test_*.py -n auto --durations=0 --junitxml=test-results.xml # Run actual tests
       - name: Upload test results
-        uses: actions/upload-artifact@v1
+        uses: actions/upload-artifact@v4
         if: failure()
         with:
           name: test_results
diff --git a/.pylintrc b/.pylintrc
new file mode 100644
index 0000000..aca48ac
--- /dev/null
+++ b/.pylintrc
@@ -0,0 +1,116 @@
+[BASIC]
+
+# Regular expression matching correct argument names. Overrides argument-
+# naming-style. If left empty, argument names will be checked with the set
+# naming style.
+argument-rgx=[a-z_][a-z0-9_]{0,15}$ # Starsim
+variable-rgx=[a-z_][a-z0-9_]{0,15}$ # Starsim
+attr-rgx=[a-z_][a-z0-9_]{0,15}$ # Starsim
+class-attribute-rgx=[a-z_][a-z0-9_]{0,15}$ # Starsim
+function-rgx=[a-z_][a-z0-9_]{0,15}$ # Starsim
+method-rgx=[a-z_][a-z0-9_]{0,15}$ # Starsim
+class-rgx=[a-zA-Z_][a-zA-Z0-9_]{0,15}$ # Starsim
+
+# Good variable names which should always be accepted, separated by a comma.
+good-names=E # Starsim
+
+
+[DESIGN]
+
+# Maximum number of arguments for function / method.
+max-args=20 # Starsim
+
+# Maximum number of attributes for a class (see R0902).
+max-attributes=20 # Starsim
+
+# Maximum number of boolean expressions in an if statement (see R0916).
+max-bool-expr=5
+
+# Maximum number of branch for function / method body.
+max-branches=15 # Starsim
+
+# Maximum number of locals for function / method body.
+max-locals=20 # Starsim
+
+# Maximum number of parents for a class (see R0901).
+max-parents=7
+
+# Maximum number of public methods for a class (see R0904).
+max-public-methods=20
+
+# Maximum number of return / yield for function / method body.
+max-returns=5 # Starsim
+
+# Maximum number of statements in function / method body.
+max-statements=200 # Starsim
+
+# Minimum number of public methods for a class (see R0903).
+min-public-methods=2
+
+
+[FORMAT]
+
+# Maximum number of characters on a single line.
+max-line-length=200 # Starsim
+
+# Maximum number of lines in a module.
+max-module-lines=2000 # Starsim
+
+# Allow the body of an if to be on the same line as the test if there is no
+# else.
+single-line-if-stmt=yes # Starsim
+
+
+[IMPORTS]
+
+# Allow wildcard imports from modules that define __all__.
+allow-wildcard-with-all=yes # Starsim
+
+
+[MESSAGES CONTROL]
+
+# Disable the message, report, category or checker with the given id(s). You
+# can either give multiple identifiers separated by comma (,) or put this
+# option multiple times (only on the command line, not in the configuration
+# file where it should appear only once). You can also use "--disable=all" to
+# disable everything first and then re-enable specific checks. For example, if
+# you want to run only the similarities checker, you can use "--disable=all
+# --enable=similarities". If you want to run only the classes checker, but have
+# no Warning level messages displayed, use "--disable=all --enable=classes
+# --disable=W".
+disable=raw-checker-failed,
+        bad-inline-option,
+        locally-disabled,
+        file-ignored,
+        suppressed-message,
+        useless-suppression,
+        deprecated-pragma,
+        use-symbolic-message-instead,
+        C0103, # Starsim: allow lowercase constants
+        C0321, # Starsim: multiple statements on a line
+        C0325, # Starsim: allow parentheses in if
+        C0411, # Starsim: allow different import order
+        C0412, # Starsim: allow ungrouped imports
+        C0413, # Starsim: allow imports not at the top
+        E1101, # Starsim: don't check class membership (dynamic classes)
+        R1705, # Starsim: allow else-return
+        R1711, # Starsim: empty return
+        R1720, # Starsim: allow else after raise
+        R1735, # Starsim: dict literal
+        W0702, # Starsim: allow bare except
+        W0718 # Starsim: allow general exception
+
+# Enable the message, report, category or checker with the given id(s). You can
+# either give multiple identifier separated by comma (,) or put this option
+# multiple time (only on the command line, not in the configuration file where
+# it should appear only once). See also the "--disable" option for examples.
+enable=c-extension-no-member
+
+
+[MISCELLANEOUS]
+
+# List of note tags to take in consideration, separated by a comma.
+notes=FIXME,
+      XXX,
+      TODO,
+      TEMP # Starsim
\ No newline at end of file
diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index e5bc96f..ec18f25 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -7,6 +7,240 @@ What's new
 All notable changes to the codebase are documented in this file. Changes that may result in differences in model output, or are required in order to run an old parameter set with the current version, are flagged with the term "Regression information".
 
 
+
+Version 2.1.1 (2024-11-08)
+---------------------------
+- Adds improved Jupyter support for plotting (to prevent plots from appearing twice); you can disable this by setting ``ss.options.set(jupyter=False)``.
+- Adds ``auto_plot`` to ``Result`` objects, to indicate if it should appear in ``sim.plot()`` by default.
+- Adds ``copy()`` to the Sim and modules.
+- Networks now store their length on each timestep as a result.
+- Improves ``sim.shrink()``, with typical size reductions of >99%.
+- Adds additional plotting options ``show_module`` (include the module name in the plot title), ``show_label`` (use the simulation label as the figure title), and ``show_skipped`` (shows results even if ``auto_plot=False``).
+- *GitHub info*: PR `745 <https://github.com/starsimhub/starsim/pull/745>`_
+
+
+Version 2.1.0 (2024-11-07)
+---------------------------
+
+Summary
+~~~~~~~
+- Time in simulations is now handled by an ``ss.Time()`` class, which unifies how time is represented between the ``Sim`` and each module.
+- In addition to networks, there is now a new way of implementing disease transmission via mixing pools.
+
+Time
+~~~~
+- Time handling now performed by the ``ss.Time()`` class. This has inputs similar to before (``start``, ``stop``, ``unit``, ``dt``, with ``dur`` still available as a sim input). However, instead of the previous ``timevec`` and ``abs_tvec`` arrays, there are now multiple ways of representing time (including ``datevec`` and ``yearvec``), regardless of what the inputs were.
+- Dates are now represented in a native format, ``ss.date``, that is based on ``pd.Timestamp``.
+
+Mixing pools
+~~~~~~~~~~~~
+- Adds a new approach to disease transmission called mixing pools. A mixing pool is a "mean field" coupling wherein susceptible agents are exposed to the average infectious agent. The user can create a single mixing pool using the ``ss.MixingPool`` class, or create many pools using ``MixingPools``. Such mixing pools could be used to simulate contact matrices, for example as published by Prem et al.
+- There is a new ``ss.Route`` class, which is the base class for ``ss.Network`` and ``ss.MixingPool``.
+
+Other changes
+~~~~~~~~~~~~~
+- Demographic modules have been updated to fix various bugs around different time units.
+- The method for hashing distribution trace strings into seeds has changed, meaning that results will be stochastically different compared to Starsim v2.0.
+- Fixed a bug with how timepars were updated in parameters.
+- There is a new ``ss.Base`` class, which both ``ss.Sim`` and ``ss.Module`` inherit from.
+- Results now print as a single line rather than the full array. The latter is available as ``result.disp()``.
+- ``sim.to_df()`` now works even if different modules have different numbers of timepoints.
+- The ``timepars`` module has been renamed to ``time``.
+- In demographics modules, ``units`` has been renamed ``rate_units``.
+- There are two new options, ``ss.options.date_sep`` and  ``ss.options.license``. The former sets the date separator (default ``.``, e.g. ``2024.04.0.4``), and the latter sets if the license prints when Starsim is imported.
+- *GitHub info*: PR `724 <https://github.com/starsimhub/starsim/pull/724>`_
+
+
+Version 2.0.0 (2024-10-01)
+--------------------------
+
+Summary
+~~~~~~~
+Version 2.0 contains several major changes. These include: module-specific timesteps and time-aware parameters (including a day/year ``unit`` flag for modules, and  ``ss.dur()`` and ``ss.rate()`` classes for parameters), and changes to module types and integration (e.g. renaming ``update()`` and ``apply()`` methods to ``step()``;).
+
+Time-aware parameters and modules
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+- Added ``ss.dur()``, ``ss.rate()``, and ``ss.time_prob()`` classes, for automatic handling of time units in simulations. There are also convenience classes ``ss.days()``, ``ss.years()``, ``ss.perday()``, ``ss.peryear()``, and ``ss.beta()`` for special cases of these.
+- ``ss.dur()`` and ``ss.rate()``, along with modules and the sim itself, have a ``unit`` parameter which can be ``'day'``, ``'week'``, ``'month'``, or ``'year'`` (default). Modules now also have their own timestep ``dt``. Different units and timesteps can be mixed and matched. Time parameters have a ``to()`` method, e.g. ``ss.dur(1, 'year').to('day')`` will return ``ss.dur(365, unit='day')``.
+- The ``ss.Sim`` parameter ``n_years`` has been renamed ``dur``; ``sim.yearvec`` is now ``sim.timevec``, which can have units of days (usually starting at 0), dates (e.g. ``'2020-01-01'``), or years (e.g. ``2020``). ``sim.abs_tvec`` is the translation of ``sim.timevec`` as a numeric array starting at 0, using the sim's units (usually ``'day'`` or ``'year'``). For example, if ``sim.timevec`` is a list of daily dates from ``'2022-01-01'`` to ``'2022-12-31'``, ``sim.abs_tvec`` will be ``np.arange(365)``.
+- Each module also has its own ``mod.timevec``; this can be different from the sim if it defines its own time unit and/or timestep. ``mod.abs_tvec`` always starts at 0 and always uses the sim's unit.
+- There is a new ``Loop`` class which handles the integration loop. You can view the integration plan via ``sim.loop.to_df()`` or ``sim.loop.plot()``. You can see how long each part of the sim took with ``sim.loop.plot_cpu()``.
+- There are more advanced debugging tools. You can run a single sim timestep with ``sim.run_one_step()`` (which in turn calls multiple functions), and you can run a single function from the integration loop with ``sim.loop.run_one_step()``.
+
+Module changes
+~~~~~~~~~~~~~~
+- Functionality has been moved from ``ss.Plugin`` to ``ss.Module``, and the former has been removed.
+- ``ss.Connector`` functionality has been moved to ``ss.Module``. ``ss.Module`` objects can be placed anywhere in the list of modules (e.g., in demographics, networks, diseases, interventions), depending on when you want them to execute. However, ``ss.Connector`` objects are applied after ``Disease.step_state()`` and before ``Network.step()``.
+- Many of the module methods have been renamed; in particular, all modules now have a ``step()`` method, which replaces ``update()`` (for demographics and networks), ``apply()`` (for interventions and analyzers), and ``make_new_cases()`` (for diseases). For both the sim and modules, ``initialize()`` has been renamed ``init()``.
+- All modules are treated the same in the integration loop, except for diseases, which have ``step_state()`` and ``step_die()`` methods.
+- The Starsim module ``states.py`` has been moved to ``arrays.py``, and ``network.py`` has been moved to ``networks.py``.
+
+State and array changes
+~~~~~~~~~~~~~~~~~~~~~~~
+- ``ss.Arr``, ``ss.TimePar``, and ``ss.Result`` all inherit from the new class ``ss.BaseArr``, which provides functionality similar to a NumPy array, except all values are stored in ``arr.values`` (like a ``pd.Series``).
+- Whereas before, computations on an ``ss.Arr`` usually returned a NumPy array, calculations now usually return the same type. To access the NumPy array, use ``arr.values``. 
+- There is a new ``ss.State`` class, which is a subtype of ``ss.BoolArr``. Typically, ``ss.State`` is used for boolean disease states, such as ``infected``, ``susceptible``, etc., where you want to automatically generate results (e.g. ``n_infected``). You can continue using ``ss.BoolArr`` for other agent attributes that you don't necessarily want to automatically generate results for, e.g. ``ever_vaccinated``.
+
+Results changes
+~~~~~~~~~~~~~~~
+- Results are now defined differently. They should be defined in ``ss.Module.init_results()``, not ``ss.Module.init_pre()``. They now take the module name, number of points, and time vector from the parent module. As a result, they are usually initialized via ``ss.Module.define_results(res1, res2)`` (as opposed to ``mod.results += [res1, res2]`` previously). ``define_results()`` automatically adds these properties from the parent module; they can still be defined explicitly if needed however.
+- Because results now store their own time information, they can be plotted in a self-contained way. Both ``ss.Result`` and ``ss.Results`` objects now have ``plot()`` and ``to_df()`` methods.
+
+Demographics changes
+~~~~~~~~~~~~~~~~~~~~
+- Fixed a bug in how results were defined for ``ss.Births`` and ``ss.Deaths``.
+- The ``ss.Pregnancy`` module has been significantly rewritten, including: (1) Agents now have a ``parent`` which indicates the UID of the parent; (2) Women now track ``child_uid``; (3) On neonatal death, the pregnancy state of the mother is corrected; (4) Pregnancy rates now adjusted for infecund rather than pregnant; (4) Pregnancy now has a burn-in, which defaults to ``True``; (5) Pregnancy has a ``p_neonatal_death`` parameter to capture fetal and neonatal death if the mother dies.
+- Slots now has a minimum, default of 100, to account for small initial population sizes that grow dramatically over time.
+
+Computational changes
+~~~~~~~~~~~~~~~~~~~~~
+- There have been several performance improvements. The default float type is now ``np.float32``. Transmission is now handled by a specialized ``Infection.compute_transmission()`` method. Several additional functions now use Numba, including ``fastmath=True``, which leverages Intel's short vector math library.
+- A new ``ss.multi_random()`` distribution class has been added, that allows random numbers to be generated by two (or more) agents. It largely replaces ``ss.combine_rands()`` and is 5-10x faster.
+- A new ``ss.gamma()`` distribution has also been added.
+- Distributions have a new ``jump_dt`` method that jumps by much more than a single state update.
+- ``ss.parallel()`` and ``ss.MultiSim.run()`` now modify simulations in place by default. Instead of ``sims = ss.parallel(sim1, sim2).sims; sims[0].plot()``, you can now simply do ``ss.parallel(sim1, sim2); sim1.plot()``.
+
+Other changes
+~~~~~~~~~~~~~
+- Data can now be supplied to a simulation; it will be automatically plotted by ``sim.plot()``.
+- ``ss.Calibration`` has been significantly reworked, and now includes more flexible parameter setting, plus plotting (``calib.plot_sims()`` and ``calib.plot_trend()``). It also has a ``debug`` argument (which runs in serial rather than paralell), which can be helpful for troubleshooting issues.
+- ``MultiSim`` now has display methods ``brief()`` (minimal), ``show()`` (moderate), and ``disp`` (verbose).
+- ``sim.export_df()`` has been renamed ``sim.to_df()``.
+- Most classes now have ``to_json()`` methods (which can also export to a dict).
+- Fixed a bug in how the ``InfectionLog`` is added to disease modules.
+- ``Sim.gitinfo`` has been replaced with ``Sim.metadata`` (which includes git info).
+- ``Infection.validate_beta()`` is now applied on every timestep, so changes to beta during the simulation are now honored.
+- ``sim.get_intervention()`` and ``sim.get_analyzer()`` have been removed; use built-in ``ndict`` operations (e.g., the label) to find the object you're after.
+- ``requires`` has been removed from modules, but ``ss.check_requires()`` is still available if needed. Call it manually from ``init_pre()`` if desired, e.g. a PMTCT intervention might call ``ss.check_requires(self.sim, ['hiv', 'maternalnet'])``.
+- For networks, ``contacts`` has been renamed ``edges`` except in cases where it refers to an *agent's* contacts. For example, ``network.contacts`` has been renamed ``network.edges``, but ``ss.find_contacts()`` remains the same.
+- Networks now have a ``to_graph()`` method that exports to NetworkX.
+- ``ss.diff_sims()`` can now handle ``MultiSim`` objects.
+- ``Sim._orig_pars`` has been removed.
+- ``ss.unique()`` has been removed.
+
+Regression information
+~~~~~~~~~~~~~~~~~~~~~~
+- Note: the list here covers major changes only; in general, Starsim v1.0 scripts will not be compatible with Starsim v2.0.
+- Results from Starsim v2.0 will be stochastically (but not statistically) different from Starsim v1.0.
+- All duration and rate parameters should now be wrapped with ``ss.dur()`` and ``ss.rate()``. Events that represent probabilities over time (i.e. hazard rates) can also be wrapped with ``ss.time_prob()``, although this is similar to ``ss.rate()`` unless the value is relatively large.
+- ``ss.Plugin`` has been removed. Use ``ss.Module`` instead.
+- ``init_results()`` is now called by ``init_pre()``, and does not need to be called explicitly.
+- ``default_pars()`` has been renamed ``define_pars()``.
+- ``add_states()`` has been renamed ``define_states()``
+- ``initialize()`` has been renamed ``init()``.
+- ``Demographics.update()`` has been renamed ``Demographics.step()``.
+- ``Network.update()`` has been renamed ``Network.step()``.
+- ``Disease.update_pre()`` has been renamed ``Disease.step_state()``.
+- ``Disease.make_new_cases()`` has been renamed ``Disease.step()``.
+- ``Disease.update_death()`` has been renamed ``Disease.step_die()`` (which is now called by ``People.step_die()``).
+- ``Infection._set_cases()`` has been renamed ``Infection.set_outcomes()``.
+- ``Intervention.apply(sim)`` has been renamed ``Intervention.step()``; ditto for ``Analyzer``.
+- ``Module.step()`` no longer takes ``sim`` as an argument (e.g., replace ``intervention.apply(sim)`` with ``intervention.step()``).
+- All modules now have methods for ``start_step()``, ``finish_step()``, ``init_results()``, and ``update_results()``.
+- ``Network.contacts`` has been renamed ``Network.edges``.
+- ``sim.get_intervention()`` and ``sim.get_analyzer()`` have been removed; simply call directly instead (e.g. replace ``sim.get_intervention('vaccine')`` with ``sim.interventions['vaccine']``).
+- ``requires`` is no longer an attribute of modules; call the ``ss.check_requires()`` function directly if needed.
+- ``People.resolve_deaths()`` has been renamed ``People.check_deaths()``
+- ``ss.unique()`` has been removed.
+- *GitHub info*: PR `626 <https://github.com/starsimhub/starsim/pull/626>`_
+
+
+Version 1.0.3 (2024-09-26)
+---------------------------
+- Fixes a bug in which some intervention parameters (e.g. eligibility) do not get set properly.
+- *GitHub info*: PR `639 <https://github.com/starsimhub/starsim/pull/639>`_
+
+
+Version 1.0.2 (2024-09-25)
+---------------------------
+- Fixes a bug in which random numbers drawn from auto-jumped distributions would overlap with random numbers drawn from subsequent timesteps.
+- *GitHub info*: PR `639 <https://github.com/starsimhub/starsim/pull/639>`_
+
+
+Version 1.0.1 (2024-07-22)
+---------------------------
+- Adds a new distribution, ``ss.rand_raw()``, that samples raw integers from the random number bit generator, for use with calculating transmission. This version is roughly 20-30% faster than the previous implementation.
+- Adds interpolation to age-standardized fertility rate (ASFR) data.
+- Adds flexibility to ART initiation.
+- *GitHub info*: PR `593 <https://github.com/starsimhub/starsim/pull/593>`_
+
+
+Version 1.0.0 (2024-07-10)
+---------------------------
+- Official release of Starsim!
+- Adds a ``Calibration`` class, based on `Optuna <https://optuna.org>`_, to facilitate the calibration of Starsim models.
+- Adds ``mean()``, ``median()``, and ``plot()`` methods to ``MultiSim``.
+- Adds ``low`` and ``high`` attributes to ``Result`` objects.
+- Adds a ``flatten()`` method to ``Results``, allowing nested ``Results`` objects to be turned into flat dictionaries.
+- Removes duplicate UIDs among new infections, and adds a ``unique()`` method to ``ss.uids``.
+- Fixes a bug that prevented ``ss.lognorm_im()`` from using callable parameters.
+- Updates the default ``Sim`` string representation to be a single line; the more verbose version is available via ``sim.disp()``.
+- *GitHub info*: PR `581 <https://github.com/starsimhub/starsim/pull/581>`_
+
+
+Version 0.5.10 (2024-07-03)
+---------------------------
+- Adds two new common-random-number-safe networks. The first is an Erdős-Rényi network that is similar to ``RandomNet`` but parameterized differently. The second is a 2D spatial network with connectivity between agents within a given radius; these agents can also optionally move.
+- *GitHub info*: PR `575 <https://github.com/starsimhub/starsim/pull/575>`_
+
+
+Version 0.5.9 (2024-06-30)
+--------------------------
+- Added a ``ss.histogram()`` distribution, which allows generating new random values from an empirical histogram.
+- When binned age data is provided to specify the initial ages for new agents, the ages are now distributed throughout the year/bin rather than new agents being assigned integer ages
+- Initial age data is now accepted as a ``pd.Series`` rather than a ``pd.DataFrame`` where the index corresponds to the age values, thereby avoiding the need for specific dataframe column names to be used to specify the age and value
+- *GitHub info*: PR `572 <https://github.com/starsimhub/starsim/pull/572>`_
+
+
+Version 0.5.8 (2024-06-30)
+--------------------------
+- Revert to making infection logging disabled by default. However, the infection log will now always be created so disease subclasses can override logging behaviour where required (e.g., to capture additional metadata)
+- **Backwards-compatibility notes:** Logging has been moved from an argument to ``Disease`` to ``pars``. Existing code such as ``Disease(log=True)`` should be changed to ``Disease(pars={'log':True})``. The 'log' option can be added to the pars passed to any subclass e.g., ``ss.HIV(pars={...,log=True})``.
+- *GitHub info*: PR `573 <https://github.com/starsimhub/starsim/pull/573>`_
+
+Version 0.5.7 (2024-06-27)
+--------------------------
+- Implemented a new ``ss.combine_rands()`` function based on a bitwise-XOR, since the previous modulo-based approach could introduce correlations between pairs of agents.
+- *GitHub info*: PR `546 <https://github.com/starsimhub/starsim/pull/546>`_
+
+
+Version 0.5.6 (2024-06-22)
+--------------------------
+- ``ss.Infection.make_new_cases()`` now returns the index of the network associated with each transmission event
+- If a ``People`` object is provided to the ``Arr`` constructor, the arrays will be pre-initialized to index the current UIDs in the ``People`` object. This enables construction of temporary ``Arr`` instances that can be used to perform intermediate calculations (e.g., inside ``Intervention.apply()`` or within a module update step)
+- Deprecated ``Arr(raw=...)`` argument to simplify initialization, as in practice the ``raw`` variable is not directly set, and this update also introduces a new pathway for initializating the `raw` attribute
+- ``ss.uids.to_numpy()`` now returns a view rather than a copy
+- ``ss.bernoulli.filter()`` now supports ``ss.BoolArr`` as an input, where the filtering will operate on the ``uids`` returned by ``ss.BoolArr.uids``
+- ``ss.uids()`` supports construction from ``set`` objects (via ``np.fromiter()``)
+- *GitHub info*: PR `565 <https://github.com/starsimhub/starsim/pull/555>`_
+
+
+Version 0.5.5 (2024-06-19)
+--------------------------
+- Added labels to ``Result`` and state (``Arr``) objects.
+- Added Numba decorator to ``find_contacts`` to significantly increase performance.
+- Fixed bug when comparing ``uids`` and ``BoolArr`` objects.
+- *GitHub info*: PR `562 <https://github.com/starsimhub/starsim/pull/555>`_
+
+
+Version 0.5.4 (2024-06-18)
+--------------------------
+- Adjusted ``RandomNet`` to avoid connections to unborn agents and use random rounding for half edges
+- Adds ``get_analyzers`` and ``get_analyzer``
+- Refactor how data is pre-processed for births/pregnancy/death rates, giving about a 10% decrease in run time for the STIsim HIV model
+- ``BoolArr.uids`` is automatically called when doing set operations on ``uids`` with a ``BoolArr``
+- *GitHub info*: PR `555 <https://github.com/starsimhub/starsim/pull/555>`_
+
+
+Version 0.5.3 (2024-06-10)
+--------------------------
+- ``ss.uids`` class implements set operators to facilitate combining or otherwise operating on collections of UIDs
+- ``FloatArr.isnan`` and ``FloatArr.notnan`` return ``BoolArr`` instances rather than UIDs (so as to facilitate logical operations with other ``BoolArr`` instances, and to align more closely with `np.isnan`)
+- ``Arr.true()`` and ``Arr.false()`` are supported for all ``Arr`` subclasses
+- ``BoolArr.isnan`` and ``Boolarr.notnan`` are also implemented (although since ``BoolArr`` cannot store NaN values, these always return ``False`` and ``True``, respectively)
+- *GitHub info*: PR `544 <https://github.com/starsimhub/starsim/pull/544>`_
+
+
 Version 0.5.2 (2024-06-04)
 --------------------------
 - Renames ``network.contacts`` to ``network.edges``.
diff --git a/LICENSE b/LICENSE
index 705f935..bba8252 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,6 +1,6 @@
 MIT License
 
-Copyright (c) 2023 by the Starsim Development Team
+Copyright (c) 2023 - 2024 Bill & Melinda Gates Foundation
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
diff --git a/README.rst b/README.rst
index e8e1caf..7ae3053 100644
--- a/README.rst
+++ b/README.rst
@@ -1,13 +1,13 @@
 Starsim
 =======
 
-**Warning! Starsim is still in the early stages of development. It is being shared solely for transparency and to facilitate collaborative development. It is not ready to be used for real research or policy questions.**
+Starsim is an agent-based modeling framework for simulating the spread of diseases among agents via dynamic transmission networks. Starsim supports the co-transmission of multiple diseases at once, capturing how they interact biologically and behaviorally. Users can also include non-infectious diseases either on their own or as factors affecting infectious diseases. Starsim allows detailed modeling of mother-child relationships from conception to study birth-related diseases. Additionally, Starsim lets users compare different intervention strategies, like vaccines or treatments, to see their impact through various delivery methods such as mass campaigns or targeted outreach.
 
-Starsim is an agent-based modeling framework in which users can design and configure simulations of diseases (or other health states) that progress over time within each agent and pass from one agent to the next along dynamic transmission networks. The framework explicitly supports co-transmission of multiple pathogens, allowing users to concurrently simulate several diseases while capturing behavioral and biological interactions. Non-communicable diseases can be included as well, either as a co-factor for transmissible pathogens or as an independent exploration. Detailed modeling of mother-child relationships can be simulated from the timepoint of conception, enabling study of congenital diseases and associated birth outcomes. Finally, Starsim facilitates the comparison of one or more intervention scenarios to a baseline scenario in evaluating the impact of various products like vaccines, therapeutics, and novel diagnostics delivered via flexible routes including mass campaigns, screen and treat, and targeted outreach.
+Examples of diseases that have already been implemented in Starsim include sexually transmitted infections (HIV, HPV, and syphilis, including co-transmission), respiratory infections (tuberculosis and RSV), plus other diseases (Ebola and cholera) and underlying determinants of health (such as malnutrition).
 
-The framework is appropriate for simulating sexually transmitted infections (including syphilis, gonorrhea, chlamydia, HPV, and HIV, including co-transmission), respiratory infections (like RSV and tuberculosis), and other diseases and underlying determinants (such as Ebola, diabetes, and malnutrition).
+Note: Starsim is a general-purpose, multi-disease framework that builds on our previous suite of disease-specific models, which included `Covasim <https://covasim.org>`_, `HPVsim <https://hpvsim.org>`_, and `FPsim <https://fpsim.org>`_. In cases where a distinction needs to be made, Starsim is also known as the "Starsim framework", while this collection of other models is known as the "Starsim suite".
 
-Starsim is a general-purpose modeling framework that is part of the same suite of tools as `Covasim <https://covasim.org>`_, `HPVsim <https://hpvsim.org>`_, and `FPsim <https://fpsim.org>`_.
+For more information about Starsim, please see the `documentation <https://docs.starsim.org>`__.
 
 
 Requirements
@@ -25,53 +25,64 @@ Starsim is most easily installed via PyPI: ``pip install starsim``.
 
 Starsim can also be installed locally. To do this, clone first this repository, then run ``pip install -e .`` (don't forget the dot at the end!).
 
+*Note:* Starsim leverages Intel's `short vector math library <https://numba.readthedocs.io/en/stable/user/performance-tips.html#intel-svml>`_. If you want to use this (for a ~10% speed improvement), install via `conda install intel-cmplr-lib-rt`.
+
 
 Usage and documentation
 -----------------------
 
-Documentation, including tutorials and an API reference, is available at https://docs.starsim.org. 
+Full documentation, including tutorials and an API reference, is available at https://docs.starsim.org. 
 
-If everything is working, the following Python commands will run a simulation with the simplest version of a Starsim model. We'll make a version of a classic SIR model::
+You can run a simple demo via::
 
   import starsim as ss
-  
+  ss.demo()
+
+Here is a slightly more realistic example of an SIR model with random connections between agents::
+
+  import starsim as ss
+
   # Define the parameters
   pars = dict(
-    n_agents = 5_000,   # Number of agents to simulate
-    networks = dict(    # *Networks* add detail on how agents interact w/ each other
-      type = 'random',  # Here, we use a 'random' network
-      n_contacts = 10   # Each person has an average of 10 contacts w/ other people  
-    ),
-    diseases = dict(    # *Diseases* add detail on what diseases to model
-      type = 'sir',     # Here, we're creating an SIR disease
-      init_prev = 0.1,  # Proportion of the population initially infected
-      beta = 0.5,       # Probability of transmission between contacts
-    )
+      n_agents = 5_000,     # Number of agents to simulate
+      networks = dict(      # Networks define how agents interact w/ each other
+          type = 'random',  # Here, we use a 'random' network
+          n_contacts = 10   # Each person has 10 contacts with other people  
+      ),
+      diseases = dict(      # *Diseases* add detail on what diseases to model
+          type = 'sir',     # Here, we're creating an SIR disease
+          init_prev = 0.01, # Proportion of the population initially infected
+          beta = 0.05,      # Probability of transmission between contacts
+      )
   )
-  
+
   # Make the sim, run and plot
   sim = ss.Sim(pars)
   sim.run()
-  sim.plot()
+  sim.plot() # Plot all the sim results
+  sim.diseases.sir.plot() # Plot the standard SIR curves
 
-More usage examples are available in the ``tests`` folder.
+More usage examples are available in the tutorials, as well as the ``tests`` folder.
 
 
-Model structure
----------------
+Starsim structure
+-----------------
 
 All core model code is located in the ``starsim`` subfolder; standard usage is ``import starsim as ss``.
 
-The model consists of core classes including Sim, Run, People, State, Network, Connectors, Analyzers, Interventions, Results, and more. These classes contain methods for running, building simple or dynamic networks, generating random numbers, calculating results, plotting, etc.
+The model consists of core classes including ``Sim``, ``People``, ``Disease``, ``Network``, ``Intervention``, and more. These classes contain methods for running, building simple or dynamic networks, generating random numbers, calculating results, plotting, etc.
 
-The structure of the starsim folder is as follows, roughly in the order in which the modules are imported, building from most fundamental to most complex:
+The submodules of the Starsim folder are as follows:
 
+• ``arrays.py``: Classes to handle store and update states for people in networks in the simulation including living, mother, child, susceptible, infected, inoculated, recovered, etc.
+• ``calibration.py``: Class to handle automated calibration of the model to data.
 •	``demographics.py``: Classes to transform initial condition input parameters for use in building and utilizing networks.
 •	``disease.py``: Classes to manage infection rate of spread, prevalence, waning effects, and other parameters for specific diseases.
-•	``distributions.py``: Classes that handle statistical distributions used throughout Starsim.
+•	``distributions.py``: Classes that handle statistical distributions used throughout Starsim to produce random numbers.
 •	``interventions.py``: The Intervention class, for adding interventions and dynamically modifying parameters, and classes for each of the specific interventions derived from it. The Analyzers class (for performing analyses on the sim while it's running), and other classes and functions for analyzing simulations.
+• ``loop.py``: The logic for the main simulation integration loop.
 •	``modules.py``: Class to handle "module" logic, such as updates (diseases, networks, etc).
-•	``network.py``: Classes for creating simple and dynamic networks of people based on input parameters.
+•	``networks.py``: Classes for creating simple and dynamic networks of people based on input parameters.
 •	``parameters.py``: Classes for creating the simulation parameters.
 •	``people.py``: The People class, for handling updates of state for each person.
 •	``products.py``: Classes to manage the deployment of vaccines and treatments.
@@ -80,11 +91,11 @@ The structure of the starsim folder is as follows, roughly in the order in which
 •	``samples.py``: Class to store data from a large number of simulations.
 •	``settings.py``: User-customizable options for Starsim (e.g. default font size).
 •	``sim.py``: The Sim class, which performs most of the heavy lifting: initializing the model, running, and plotting.
-•	``states.py``: Classes to handle store and update states for people in networks in the simulation including living, mother, child, susceptible, infected, inoculated, recovered, etc.
+• ``time.py``: The Time class, which coordinates time between the Sim and different modules.
 •	``utils.py``: Helper functions.
 •	``version.py``: Version, date, and license information.
 
-The ``diseases`` folder within the Starsim package contains loading scripts for the epidemiological data specific to each respective disease.
+The ``diseases`` folder within the Starsim package contains definitions of different types of diseases, including STIs, Ebola, and cholera.
 
 
 Contributing
@@ -96,6 +107,4 @@ Questions or comments can be directed to `info@starsim.org <mailto:info@starsim.
 Disclaimer
 ----------
 
-The code in this repository was developed by IDM, the Burnet Institute, and other collaborators to support our joint research on flexible agent-based modeling. We've made it publicly available under the MIT License to provide others with a better understanding of our research and an opportunity to build upon it for their own work. We make no representations that the code works as intended or that we will provide support, address issues that are found, or accept pull requests. You are welcome to create your own fork and modify the code to suit your own modeling needs as permitted under the MIT License.
-
-
+The code in this repository was developed by `IDM <https://idmod.org>`_, the `Burnet Institute <https://burnet.edu.au>`_, and other collaborators to support our joint research on flexible agent-based modeling. We've made it publicly available under the MIT License to provide others with a better understanding of our research and an opportunity to build upon it for their own work. We make no representations that the code works as intended or that we will provide support, address issues that are found, or accept pull requests. You are welcome to create your own fork and modify the code to suit your own modeling needs as permitted under the MIT License.
diff --git a/docs/api/index.rst b/docs/api/index.rst
index 3c9540c..67630e4 100644
--- a/docs/api/index.rst
+++ b/docs/api/index.rst
@@ -12,19 +12,22 @@ This page lists Starsim's full API, including all functions and classes.
    :recursive:
    :nosignatures:
 
-   starsim.demographics
-   starsim.disease
-   starsim.distributions
-   starsim.interventions
-   starsim.modules
-   starsim.network
-   starsim.parameters
-   starsim.people
-   starsim.products
-   starsim.results
-   starsim.run
-   starsim.samples
-   starsim.settings
-   starsim.sim
-   starsim.states
-   starsim.utils
+   arrays
+   calibration
+   demographics
+   disease
+   distributions
+   interventions
+   loop
+   modules
+   networks
+   parameters
+   people
+   products
+   results
+   run
+   samples
+   settings
+   sim
+   time
+   utils
diff --git a/docs/build_docs b/docs/build_docs
index 4bc5046..3b327cc 100755
--- a/docs/build_docs
+++ b/docs/build_docs
@@ -20,10 +20,10 @@ make clean # Delete previous build
 # Handle notebook build options
 if [[ "$*" == *"never"* ]]; then
     export NBSPHINX_EXECUTE=never
-elif [[ "$*" == *"always"* ]]; then
-    export NBSPHINX_EXECUTE=always
-else
+elif [[ "$*" == *"auto"* ]]; then
     export NBSPHINX_EXECUTE=auto
+else
+    export NBSPHINX_EXECUTE=always
 fi
 
 
diff --git a/docs/conf.py b/docs/conf.py
index 4099148..726962c 100644
--- a/docs/conf.py
+++ b/docs/conf.py
@@ -6,9 +6,6 @@ import os
 import sys
 import sciris as sc
 import starsim as ss
-
-# Set environment
-os.environ['SPHINX_BUILD'] = 'True' # This is used so ss.options.set('jupyter') doesn't reset the Matplotlib renderer
 on_rtd = os.environ.get('READTHEDOCS') == 'True'
 
 
@@ -119,11 +116,8 @@ def setup(app):
 
 
 # Modify this to not rerun the Jupyter notebook cells -- usually set by build_docs
-nb_ex_default = ['auto', 'never'][0]
-nb_ex = os.getenv('NBSPHINX_EXECUTE')
-if not nb_ex: nb_ex = nb_ex_default
-print(f'\n\nBuilding Jupyter notebooks with build option: {nb_ex}\n\n')
-nbsphinx_execute = nb_ex
+nbsphinx_execute = 'always'
+nbsphinx_timeout = 300
 
 # OpenSearch options
 html_use_opensearch = 'docs.idmod.org/projects/starsim/en/latest'
diff --git a/docs/requirements.txt b/docs/requirements.txt
index ed9af80..d2303a8 100644
--- a/docs/requirements.txt
+++ b/docs/requirements.txt
@@ -1,15 +1,15 @@
 pandoc
 pypandoc
-sphinx
+sphinx>=7.3.7
 sphinx-autodoc-typehints
 pydata-sphinx-theme
 sphinx-design
 readthedocs-sphinx-search
+sphinxcontrib-napoleon
 ipykernel # For tutorials
-nbconvert==7.13.0 # For tutorials; >=7.14 does not work
-nbsphinx # For tutorials
+ipywidgets # For the tutorials
+nbconvert>=7.10.0 # For tutorials
+nbsphinx>=0.9.5 # For tutorials
 plantweb
-ipykernel
-nbsphinx
 optuna
 seaborn
diff --git a/docs/run_tutorials b/docs/run_tutorials
new file mode 120000
index 0000000..9d6178e
--- /dev/null
+++ b/docs/run_tutorials
@@ -0,0 +1 @@
+tutorials/run_tutorials
\ No newline at end of file
diff --git a/docs/tutorials.rst b/docs/tutorials.rst
index 574924b..b121e51 100644
--- a/docs/tutorials.rst
+++ b/docs/tutorials.rst
@@ -9,8 +9,8 @@ User tutorials
     tutorials/tut_intro.ipynb
     tutorials/tut_buildsim.ipynb
     tutorials/tut_demographics.ipynb
-    tutorials/tut_networks.ipynb
     tutorials/tut_diseases.ipynb
+    tutorials/tut_transmission.ipynb
     tutorials/tut_interventions.ipynb
 
 Developer tutorials
@@ -20,4 +20,7 @@ Developer tutorials
     :maxdepth: 1
 
     tutorials/dev_tut_diseases.ipynb
+    tutorials/dev_tut_pars.ipynb
+    tutorials/dev_tut_analyzers.ipynb
+    tutorials/dev_tut_nonstandard.ipynb
     
diff --git a/docs/tutorials/dev_tut_analyzers.ipynb b/docs/tutorials/dev_tut_analyzers.ipynb
new file mode 100644
index 0000000..606d811
--- /dev/null
+++ b/docs/tutorials/dev_tut_analyzers.ipynb
@@ -0,0 +1,188 @@
+{
+ "cells": [
+  {
+   "cell_type": "markdown",
+   "id": "2b9940bf",
+   "metadata": {},
+   "source": [
+    "# Developer tutorial: Analyzers"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "b1167214",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/dev_tut_analyzers.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Fdev_tut_analyzers.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "17f9cc01",
+   "metadata": {},
+   "source": [
+    "## Reporting results\n",
+    "\n",
+    "Each Starsim module can have its own results, which get added to the full list of results in the Sim object. For example, the `ss.Pregnancy` module adds results like `sim.results.pregnancy.pregnant`, and the `ss.HIV` module adds results like `sim.results.hiv.new_infections`. If you are writing your own module, you can add whatever custom results you want. However, another option is to create an `Analyzer` to store results that you might need for one particular analysis but won't need all the time. An `Analyzer` is very similar to other Starsim modules in its structure, but the general idea of an analyzer is that it gets called at the end of a timestep, and reports of the state of things after everything else has been updated without changing any of the module states itself.\n"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "9c34dcc8",
+   "metadata": {},
+   "source": [
+    "## Simple usage\n",
+    "\n",
+    "For simple reporting, it's possible to use a single function as an analyzer. In this case, the function receives a single argument, `sim`, which it has full access to. For example, if you wanted to know the number of connections in the network on each timestep, you could write a small analyzer as follows:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "306a385e",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import starsim as ss\n",
+    "import matplotlib.pyplot as plt\n",
+    "\n",
+    "# Store the number of edges\n",
+    "n_edges = []\n",
+    "\n",
+    "def count_edges(sim):\n",
+    "    \"\"\" Print out the number of edges in the network on each timestep \"\"\"\n",
+    "    network = sim.networks[0] # Get the first network\n",
+    "    n = len(network)\n",
+    "    n_edges.append(n)\n",
+    "    print(f'Number of edges for network {network.name} on step {sim.ti}: {n}')\n",
+    "    return\n",
+    "\n",
+    "# Create the sim\n",
+    "pars = dict(\n",
+    "    diseases='sis',\n",
+    "    networks = 'mf',\n",
+    "    analyzers = count_edges,\n",
+    "    demographics = True,\n",
+    ")\n",
+    "\n",
+    "# Run the sim\n",
+    "sim = ss.Sim(pars).run()\n",
+    "sim.plot()\n",
+    "\n",
+    "# Plot the number of edges\n",
+    "plt.figure()\n",
+    "plt.plot(sim.timevec, n_edges)\n",
+    "plt.title('Number of edges over time')\n",
+    "plt.show()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "10599c01",
+   "metadata": {},
+   "source": [
+    "Is that what you expected it to look like? The reason it looks like that is that initially, agents die (either from aging or from disease), reducing the number of edges. New agents are being born, but they don't participate in male-female networks until the age of debut -- which is 15 years old by default, which is why the trend reverses (and tracks population size) after 2015. This illustrates the importance of model burn-in!"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "79869fb8",
+   "metadata": {},
+   "source": [
+    "## Advanced usage\n",
+    "\n",
+    "Suppose we wanted to create an analyzer that would report on the number of new HIV infections in pregnant women:\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "639d87f1",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import starsim as ss\n",
+    "import pandas as pd\n",
+    "\n",
+    "class HIV_preg(ss.Analyzer):\n",
+    "    def __init__(self, *args, **kwargs):\n",
+    "        super().__init__(*args, **kwargs)\n",
+    "        return\n",
+    "    \n",
+    "    def init_results(self):\n",
+    "        super().init_results()\n",
+    "        self.define_results(\n",
+    "            ss.Result('new_infections_pregnancy'),\n",
+    "        )\n",
+    "        return\n",
+    "\n",
+    "    def step(self):\n",
+    "        sim = self.sim\n",
+    "        ti = sim.ti\n",
+    "        hiv = sim.diseases.hiv\n",
+    "        pregnant = sim.demographics.pregnancy.pregnant\n",
+    "        newly_infected = hiv.ti_infected == ti\n",
+    "        self.results['new_infections_pregnancy'][ti] = len((newly_infected & pregnant).uids)\n",
+    "        return\n",
+    "\n",
+    "pregnancy = ss.Pregnancy(pars=dict(fertility_rate=pd.read_csv('test_data/nigeria_asfr.csv')))\n",
+    "hiv = ss.HIV(beta={'mfnet':[0.5,0.25]})\n",
+    "sim = ss.Sim(diseases=hiv, networks='mfnet', demographics=pregnancy, analyzers=HIV_preg())\n",
+    "sim.run()\n",
+    "print(f'Total infections among pregnant women: {sim.results.hiv_preg.new_infections_pregnancy.sum()}')\n"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "69d050f3",
+   "metadata": {},
+   "source": [
+    "Analyzers are ideal for adding custom results, and because they get added to the sim in the same way as any other result, they also get automatically exported in the same format, e.g. using `sim.to_df()`.\n",
+    "\n",
+    "Here's a plot of the results from our HIV in pregnancy analyzer:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "29072323",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import matplotlib.pyplot as plt\n",
+    "\n",
+    "res = sim.results.hiv_preg\n",
+    "\n",
+    "plt.figure()\n",
+    "plt.bar(res.timevec, res.new_infections_pregnancy)\n",
+    "plt.title('HIV infections acquired during pregnancy')\n",
+    "plt.show()"
+   ]
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "base",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.12.2"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 5
+}
diff --git a/docs/tutorials/dev_tut_diseases.ipynb b/docs/tutorials/dev_tut_diseases.ipynb
index 69e93b6..c1d04ef 100644
--- a/docs/tutorials/dev_tut_diseases.ipynb
+++ b/docs/tutorials/dev_tut_diseases.ipynb
@@ -2,13 +2,27 @@
  "cells": [
   {
    "cell_type": "markdown",
+   "id": "397b7212",
    "metadata": {},
    "source": [
-    "# Developer tutorial - Diseases"
+    "# Developer tutorial: Diseases"
    ]
   },
   {
    "cell_type": "markdown",
+   "id": "a30cce76",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/dev_tut_diseases.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Fdev_tut_diseases.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "6adf65fe",
    "metadata": {},
    "source": [
     "## Overview of Starsim's disease structure\n",
@@ -22,6 +36,7 @@
   },
   {
    "cell_type": "markdown",
+   "id": "03077b6c",
    "metadata": {
     "collapsed": false,
     "jupyter": {
@@ -35,14 +50,8 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
-   "source": []
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
+   "execution_count": 1,
+   "id": "8b1bf68d",
    "metadata": {
     "collapsed": false,
     "jupyter": {
@@ -52,67 +61,79 @@
    "outputs": [],
    "source": [
     "import numpy as np\n",
+    "import matplotlib.pyplot as plt\n",
     "import starsim as ss\n",
     "\n",
-    "\n",
     "class SEIR(ss.SIR):\n",
     "    def __init__(self, pars=None, *args, **kwargs):\n",
-    "        \n",
-    "        # Additional pars beyond the SIR model ones\n",
-    "        pars = ss.omerge({\n",
-    "            'dur_exp': 0.5,  \n",
-    "        }, pars)\n",
-    "        \n",
-    "        # Initialize the SIR model, which will add all the parameters and states of that model.\n",
-    "        super().__init__(pars=pars, *args, **kwargs)\n",
+    "        super().__init__()\n",
+    "        self.define_pars(\n",
+    "            dur_exp = ss.lognorm_ex(0.5),\n",
+    "        )\n",
+    "        self.update_pars(pars, **kwargs)\n",
     "\n",
     "        # Additional states beyond the SIR ones \n",
-    "        self.exposed = ss.State('exposed', bool, False)\n",
-    "        self.ti_exposed = ss.State('ti_exposed', float, np.nan)\n",
-    "\n",
+    "        self.define_states(\n",
+    "            ss.State('exposed', label='Exposed'),\n",
+    "            ss.FloatArr('ti_exposed', label='TIme of exposure'),\n",
+    "        )\n",
     "        return\n",
     "\n",
     "    @property\n",
     "    def infectious(self):\n",
     "        return self.infected | self.exposed\n",
     "\n",
-    "    def update_pre(self, sim):\n",
-    "        # Make all the updates from the SIR model \n",
-    "        n_deaths = super().update_pre(sim)\n",
+    "    def step_state(self):\n",
+    "        \"\"\" Make all the updates from the SIR model \"\"\"\n",
+    "        # Perform SIR updates\n",
+    "        super().step_state()\n",
     "\n",
     "        # Additional updates: progress exposed -> infected\n",
-    "        infected = ss.true(self.exposed & (self.ti_infected <= sim.ti))\n",
+    "        infected = self.exposed & (self.ti_infected <= self.ti)\n",
     "        self.exposed[infected] = False\n",
     "        self.infected[infected] = True\n",
+    "        return\n",
     "\n",
-    "        return n_deaths\n",
-    "\n",
-    "    def update_death(self, sim, uids):\n",
-    "        super().update_death(sim, uids)\n",
+    "    def step_die(self, uids):\n",
+    "        super().step_die(uids)\n",
     "        self.exposed[uids] = False\n",
     "        return\n",
     "\n",
-    "    def set_prognoses(self, sim, uids, from_uids):\n",
-    "        # Carry out state changes associated with infection\n",
+    "    def set_prognoses(self, uids, sources=None):\n",
+    "        \"\"\" Carry out state changes associated with infection \"\"\"\n",
+    "        super().set_prognoses(uids, sources)\n",
+    "        ti = self.ti\n",
     "        self.susceptible[uids] = False\n",
     "        self.exposed[uids] = True\n",
-    "        self.ti_exposed[uids] = sim.ti\n",
+    "        self.ti_exposed[uids] = ti\n",
     "\n",
     "        # Calculate and schedule future outcomes\n",
     "        dur_exp = self.pars['dur_exp'].rvs(uids)\n",
-    "        self.ti_infected[uids] = sim.ti + dur_exp / sim.dt\n",
+    "        self.ti_infected[uids] = ti + dur_exp\n",
     "        dur_inf = self.pars['dur_inf'].rvs(uids)\n",
     "        will_die = self.pars['p_death'].rvs(uids)        \n",
-    "        self.ti_recovered[uids[~will_die]] = sim.ti + dur_inf[~will_die] / sim.dt\n",
-    "        self.ti_dead[uids[will_die]] = sim.ti + dur_inf[will_die] / sim.dt\n",
+    "        self.ti_recovered[uids[~will_die]] = ti + dur_inf[~will_die]\n",
+    "        self.ti_dead[uids[will_die]] = ti + dur_inf[will_die]\n",
     "\n",
     "        # Update result count of new infections \n",
-    "        self.results['new_infections'][sim.ti] += len(uids)\n",
-    "        return\n"
+    "        self.results['new_infections'][self.ti] += len(uids)\n",
+    "        return\n",
+    "    \n",
+    "    def plot(self):\n",
+    "        \"\"\" Update the plot with the exposed compartment \"\"\"\n",
+    "        with ss.options.context(jupyter=False):\n",
+    "            fig = super().plot()\n",
+    "            ax = plt.gca()\n",
+    "            res = self.results.n_exposed\n",
+    "            ax.plot(res.timevec, res, label=res.label)\n",
+    "            plt.legend()\n",
+    "        return ss.return_fig(fig)\n",
+    "\n"
    ]
   },
   {
    "cell_type": "markdown",
+   "id": "572ec8fe",
    "metadata": {
     "collapsed": false,
     "jupyter": {
@@ -127,11 +148,33 @@
     "3. We updated `update_pre` and `update_death` to include changes to the `exposed` state \n",
     "4. We rewrote `set_prognoses` to include the new exposed state.\n"
    ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "c6a7f164",
+   "metadata": {},
+   "source": [
+    "Here's how it would look in practice:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "2d627cb8",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "seir = SEIR()\n",
+    "sim = ss.Sim(diseases=seir, networks='random')\n",
+    "sim.run()\n",
+    "sim.plot()\n",
+    "sim.diseases.seir.plot()"
+   ]
   }
  ],
  "metadata": {
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "base",
    "language": "python",
    "name": "python3"
   },
@@ -145,31 +188,9 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.10.11"
-  },
-  "pycharm": {
-   "stem_cell": {
-    "cell_type": "raw",
-    "metadata": {
-     "collapsed": false
-    },
-    "source": []
-   }
-  },
-  "toc": {
-   "base_numbering": 1,
-   "nav_menu": {},
-   "number_sections": true,
-   "sideBar": true,
-   "skip_h1_title": false,
-   "title_cell": "Table of Contents",
-   "title_sidebar": "Contents",
-   "toc_cell": false,
-   "toc_position": {},
-   "toc_section_display": true,
-   "toc_window_display": false
+   "version": "3.12.2"
   }
  },
  "nbformat": 4,
- "nbformat_minor": 4
+ "nbformat_minor": 5
 }
diff --git a/docs/tutorials/dev_tut_nonstandard.ipynb b/docs/tutorials/dev_tut_nonstandard.ipynb
new file mode 100644
index 0000000..1503f91
--- /dev/null
+++ b/docs/tutorials/dev_tut_nonstandard.ipynb
@@ -0,0 +1,313 @@
+{
+ "cells": [
+  {
+   "cell_type": "markdown",
+   "id": "65d05112",
+   "metadata": {},
+   "source": [
+    "# Developer tutorial: Nonstandard usage\n",
+    "\n",
+    "Although Starsim is primarily intended as an agent-based disease model, due to its modular structure, it can be used for other applications as well. This tutorial describes how Starsim can be used (1) as a compartmental disease model, and (2) as a general-purpose agent-based model."
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "d5d9ebcb",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/dev_tut_nonstandard.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Fdev_tut_nonstandard.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "3517ab31",
+   "metadata": {},
+   "source": [
+    "## Compartmental modeling\n",
+    "\n",
+    "Much of Starsim's power comes from how it handles agents. However, agent-based modeling may be too slow or too complex for some problems. While in many cases it probably makes more sense to do compartmental disease modeling in another framework (such as [Atomica](https://atomica.tools/)), it is also possible to do it within Starsim, taking advantage of features such as demographics, time units, etc. This is especially useful for a multi-disease simulation where some diseases need the detail and flexibility of an ABM, while others can be modeled more simply (and faster) as compartmental models.\n",
+    "\n",
+    "### Setting up the model\n",
+    "\n",
+    "Here we will define a simple compartmental susceptible-infectious-susceptible (SIS) model. The model definition here is quite similar to the agent-based implementation in Starsim's [SIR module](https://github.com/starsimhub/starsim/blob/main/starsim/diseases/sir.py); differences are noted in comments. Note that the model runs extremely fast, since a three-state compartmental model (susceptible, infecious, and immunity) runs as fast as an agent-based model with three agents!"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "8b4b1e6d",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "\"\"\"\n",
+    "Example compartmental SIS model for Starsim\n",
+    "\"\"\"\n",
+    "\n",
+    "import starsim as ss\n",
+    "import sciris as sc\n",
+    "import matplotlib.pyplot as plt\n",
+    "\n",
+    "\n",
+    "class CompartmentalSIS(ss.Module): # We don't need the extra functionality of the Infection class, so just inherit from Module\n",
+    "    def __init__(self, pars=None, *args, **kwargs):\n",
+    "        super().__init__()\n",
+    "        self.define_pars(\n",
+    "            beta = ss.rate(0.8), # Leverage Starsim's automatic time unit handling\n",
+    "            init_prev = 0.01, # NB: this is a scalar, rather than a distribution for an ABM\n",
+    "            recovery = ss.rate(0.1), # Also not a distribution\n",
+    "            waning = ss.rate(0.05),\n",
+    "            imm_boost = 1.0,\n",
+    "            use_immunity = True,\n",
+    "        )\n",
+    "        self.update_pars(pars=pars, *args, **kwargs)\n",
+    "        \n",
+    "        # Don't need to define states; just use scalars\n",
+    "        self.N = 0\n",
+    "        self.S = 0\n",
+    "        self.I = 0\n",
+    "        self.immunity = 0\n",
+    "        return\n",
+    "    \n",
+    "    def init_post(self):\n",
+    "        \"\"\" Finish initialization \"\"\"\n",
+    "        super().init_post()\n",
+    "        self.N = len(self.sim.people) # Assumes a static population; could also use a dynamic population size\n",
+    "        i0 = self.pars.init_prev\n",
+    "        self.S = self.N*(1-i0)\n",
+    "        self.I = self.N*i0\n",
+    "        self.immunity = i0\n",
+    "        return\n",
+    "        \n",
+    "    @property\n",
+    "    def rel_sus(self):\n",
+    "        return 1 - self.immunity\n",
+    "    \n",
+    "    def step(self):\n",
+    "        \"\"\" Carry out disease transmission logic \"\"\"\n",
+    "        self.immunity *= (1 - self.pars.waning) # Update immunity from waning\n",
+    "        rel_sus = self.rel_sus if self.pars.use_immunity else 1.0\n",
+    "        infected = (self.S*self.I/self.N)*self.pars.beta*rel_sus # Replaces Infection.infect()\n",
+    "        recovered = self.I*self.pars.recovery # Replaces setting a time to recovery and checking that time\n",
+    "        net = infected - recovered # Net change in number infectious\n",
+    "        self.S -= net\n",
+    "        self.I += net\n",
+    "        self.immunity += infected/self.N*self.pars.imm_boost # Update immunity from new infections\n",
+    "        return\n",
+    "    \n",
+    "    def init_results(self):\n",
+    "        \"\"\" Initialize results \"\"\"\n",
+    "        super().init_results()\n",
+    "        self.define_results(\n",
+    "            ss.Result('S', label='Susceptible'),\n",
+    "            ss.Result('I', label='Infectious'),\n",
+    "        )\n",
+    "        return\n",
+    "\n",
+    "    def update_results(self):\n",
+    "        \"\"\" Store the current state \"\"\"\n",
+    "        super().update_results()\n",
+    "        self.results['S'][self.ti] = self.S\n",
+    "        self.results['I'][self.ti] = self.I\n",
+    "        return \n",
+    "\n",
+    "    def plot(self):\n",
+    "        \"\"\" Default plot for SIS model \"\"\"\n",
+    "        fig = plt.figure()\n",
+    "        res = self.results\n",
+    "        kw = dict(lw=2, alpha=0.7)\n",
+    "        for rkey in ['S', 'I']:\n",
+    "            plt.plot(res.timevec, res[rkey], label=res[rkey].label, **kw)\n",
+    "        plt.legend(frameon=False)\n",
+    "        plt.xlabel('Time')\n",
+    "        plt.ylabel('Number of people')\n",
+    "        plt.ylim(bottom=0)\n",
+    "        sc.boxoff()\n",
+    "        sc.commaticks() \n",
+    "        plt.show()      \n",
+    "        return\n",
+    "    \n",
+    "\n",
+    "# Run the compartmental simulation (csim)\n",
+    "csim = ss.Sim(diseases=CompartmentalSIS(), dur=100, dt=0.1, verbose=0.01)\n",
+    "csim.run()\n",
+    "\n",
+    "# Plot the results\n",
+    "csim.diseases.compartmentalsis.plot()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "58588afb",
+   "metadata": {},
+   "source": [
+    "Let's compare to our standard agent-based SIS model with similar parameters:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "6805c893",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import starsim as ss\n",
+    "\n",
+    "# Run the model\n",
+    "abm = ss.Sim(diseases=ss.SIS(beta=0.03), networks='random', dur=100, dt=0.1, verbose=0.01)\n",
+    "abm.run()\n",
+    "\n",
+    "# Plot the results\n",
+    "abm.diseases.sis.plot()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "960efa16",
+   "metadata": {},
+   "source": [
+    "The results are broadly similar, although there are differences due to the network transmission, duration of infection, etc. Note that the compartmental version runs 20 times faster than the agent-based version. Does this mean that compartmental models are better than agent-based models? If all you want to simulate is a simple SIS model, then ... the answer is probably yes!"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "aed50612",
+   "metadata": {},
+   "source": [
+    "## Mesa: Wealth model\n",
+    "\n",
+    "This example illustrates a simple \"weath model\", in which each agent starts with a single unit of wealth, and on each timestep, every agent with more than zero wealth gives one unit of wealth to another agent.\n",
+    "\n",
+    "This tutorial is adapted from the following example:\n",
+    "\n",
+    "https://mesa.readthedocs.io/en/stable/tutorials/intro_tutorial.html\n",
+    "\n",
+    "### Setting up the model\n",
+    "\n",
+    "We could define the wealth model as any type of module, since they all can store states and update them. Here we will define wealth as a subclass of `ss.Intervention` (though it could equally well be a subclass of `ss.Demographics` or even `ss.Disease`, if you are so inclined). All we need to do is update the `wealth` state (which we can store inside the \"intervention\"), and we can also use this class to track the wealth distribution over time and plot it. The full model looks like this:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "d42479c7",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "\"\"\"\n",
+    "Define the classic agent-based \"wealth model\" in Starsim\n",
+    "\"\"\"\n",
+    "\n",
+    "# Imports\n",
+    "import numpy as np\n",
+    "import starsim as ss\n",
+    "import matplotlib.pyplot as plt\n",
+    "\n",
+    "# Define the model\n",
+    "class WealthModel(ss.Module):\n",
+    "    \"\"\" A simple wealth transfer model\"\"\"\n",
+    "    \n",
+    "    def init_post(self, bins=10):\n",
+    "        \"\"\" Define custom model attributes \"\"\"\n",
+    "        super().init_post()\n",
+    "        self.npts = len(self.sim) # Number of timepoints\n",
+    "        self.n_agents = len(sim.people) # Number of agents\n",
+    "        self.wealth = np.ones(self.n_agents) # Initial wealth of each agent\n",
+    "        self.bins = np.arange(bins+1) # Bins used for plotting\n",
+    "        self.wealth_dist = np.zeros((self.npts, len(self.bins)-1)) # Wealth distribution over time\n",
+    "        return\n",
+    "        \n",
+    "    def step(self):\n",
+    "        \"\"\" Transfer wealth between agents -- core model logic \"\"\"\n",
+    "        self.wealth_hist() # Store the wealth at this time point\n",
+    "        givers = self.wealth > 0 # People need wealth to be givers\n",
+    "        receivers = np.random.choice(self.sim.people.uid, size=givers.sum()) # Anyone can be a receiver\n",
+    "        self.wealth[givers] -= 1 # Givers are unique, so can use vectorized version\n",
+    "        for receive in receivers: # Vectorized version is: np.add.at(sim.people.wealth.raw, receivers, 1)\n",
+    "            self.wealth[receive] += 1\n",
+    "        return\n",
+    "    \n",
+    "    def wealth_hist(self):\n",
+    "        \"\"\" Calculate the wealth histogram \"\"\"\n",
+    "        ti = self.sim.ti # Current timestep\n",
+    "        self.wealth_dist[ti,:], _ = np.histogram(self.wealth, bins=self.bins)\n",
+    "        return\n",
+    "    \n",
+    "    def plot(self):\n",
+    "        \"\"\" Plot a 2D histogram of the final wealth distribution \"\"\"\n",
+    "        plt.figure()\n",
+    "        plt.bar(self.bins[:-1], self.wealth_dist[-1,:])\n",
+    "        plt.title('Wealth distribution at final time point')\n",
+    "        plt.xlabel('Wealth')\n",
+    "        plt.ylabel('Number of agents')\n",
+    "        plt.show()\n",
+    "        return\n",
+    "    \n",
+    "    def plot3d(self):\n",
+    "        \"\"\" Plot a 3D heatmap of the wealth distribution over time \"\"\"\n",
+    "        plt.figure()\n",
+    "        plt.pcolor(self.wealth_dist.T, cmap='turbo')\n",
+    "        plt.title('Wealth distribution over time')\n",
+    "        plt.xlabel('Time')\n",
+    "        plt.ylabel('Wealth')\n",
+    "        plt.colorbar().set_label('Number of agents', rotation=270)\n",
+    "        plt.show()\n",
+    "        return\n",
+    "\n",
+    "# Create sim inputs, including the wealth model\n",
+    "wealth = WealthModel()\n",
+    "pars = dict(\n",
+    "    n_agents = 100, # Number of agents\n",
+    "    start = 0,\n",
+    "    stop = 100,\n",
+    "    demographics = wealth,\n",
+    ")\n",
+    "\n",
+    "# Run the model\n",
+    "sim = ss.Sim(pars, copy_inputs=False) # copy_inputs=False lets us reuse the \"wealth\" object from above\n",
+    "sim.run()\n",
+    "\n",
+    "# Plot the results\n",
+    "wealth.plot()\n",
+    "wealth.plot3d()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "f4391653",
+   "metadata": {},
+   "source": [
+    "### Comparison with Mesa\n",
+    "\n",
+    "While the implementation in Starsim is similar to Mesa, there are a couple key differences:\n",
+    "\n",
+    "- Because Starsim's people object is vectorized, the wealth definition and update is vectorized as well.\n",
+    "- Both Mesa and Starsim versions of the model are quite simple, but there is a little less boilerplate in the Starsim version."
+   ]
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "base",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.12.2"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 5
+}
diff --git a/docs/tutorials/dev_tut_pars.ipynb b/docs/tutorials/dev_tut_pars.ipynb
new file mode 100644
index 0000000..d3897ac
--- /dev/null
+++ b/docs/tutorials/dev_tut_pars.ipynb
@@ -0,0 +1,167 @@
+{
+ "cells": [
+  {
+   "cell_type": "markdown",
+   "id": "51cebe65",
+   "metadata": {},
+   "source": [
+    "# Developer tutorial: Flexible parameters"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "2f2bbf84",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/dev_tut_pars.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Fdev_tut_pars.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "f3048bcb",
+   "metadata": {},
+   "source": [
+    "## Defining default parameters\n",
+    "\n",
+    "When you create a module using Starsim, you have the opportunity to define the default format for parameters. Let's look at an example from the SIR disease model:\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 14,
+   "id": "78162546",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import starsim as ss\n",
+    "\n",
+    "class SIR(ss.SIR):\n",
+    "    def __init__(self, pars=None, **kwargs):\n",
+    "        super().__init__()\n",
+    "        self.define_pars(\n",
+    "            beta = ss.beta(0.1),\n",
+    "            init_prev = ss.bernoulli(p=0.01),\n",
+    "            dur_inf = ss.lognorm_ex(mean=ss.dur(6)),\n",
+    "            p_death = ss.bernoulli(p=0.01),\n",
+    "        )\n",
+    "        self.update_pars(pars, **kwargs)\n",
+    "\n",
+    "        self.define_states(\n",
+    "            ss.State('susceptible', default=True, label='Susceptible'),\n",
+    "            ss.State('infected', label='Infectious'),\n",
+    "            ss.State('recovered', label='Recovered'),\n",
+    "            ss.FloatArr('ti_infected', label='Time of infection'),\n",
+    "            ss.FloatArr('ti_recovered', label='Time of recovery'),\n",
+    "            ss.FloatArr('ti_dead', label='Time of death'),\n",
+    "            ss.FloatArr('rel_sus', default=1.0, label='Relative susceptibility'),\n",
+    "            ss.FloatArr('rel_trans', default=1.0, label='Relative transmission'),\n",
+    "        )\n",
+    "        return"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "486245ab",
+   "metadata": {},
+   "source": [
+    "The point of `self.define_pars()` is to set the ground truth for the format that the parameters should take. When users enter their own parameters for defining an instance of this module, the parameter values they enter will be processed within `self.update_pars()` and will be checked for consistency with the format provided in the original parameters (`define_pars`). For example, the parameter `p_death` in the SIR example above is specified initially as a Bernoulli distribution. It would be perfectly legitimate to create an instance of the SIR model using any of the following formats:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 15,
+   "id": "3b9db922",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "sir1 = SIR(p_death=0.02)\n",
+    "sir2 = SIR(p_death=ss.bernoulli(p=0.2))\n",
+    "sir3 = SIR(pars=dict(p_death=0.03))"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "d89c53a3",
+   "metadata": {},
+   "source": [
+    "However, it would NOT be ok to create an SIR model with e.g. `SIR(p_death=ss.lognorm_ex(4))`, because if a distribution is defined as a Bernoulli in the default_pars, it can't be changed. This is only the case for Bernoulli distributions; other distributions can be changed, e.g. `SIR(dur_inf=ss.normal(4))` would be okay.\n",
+    "\n",
+    "## Using callable parameters\n",
+    " \n",
+    "One of the most flexible aspects of how Starsim's distributions are defined is that they can take callable functions as parameter values. For example, in reality the duration of infection of a disease might vary by age. We could model this as follows:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "379f6ed7",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import sciris as sc\n",
+    "import matplotlib.pyplot as plt\n",
+    "\n",
+    "# Create and run the simulation\n",
+    "sir = SIR(dur_inf=ss.normal(loc=10))  # Define an SIR model with a default duration of 10 days\n",
+    "sir.pars.dur_inf.set(loc = lambda self, sim, uids: sim.people.age[uids] / 10)  # Change the mean duration so it scales with age\n",
+    "sim = ss.Sim(n_agents=20e3, dur=10, diseases=sir, networks='random')\n",
+    "sim.run()\n",
+    "sim.plot()\n",
+    "\n",
+    "# Show the age distribution of infections\n",
+    "ages = sim.people.age[:]\n",
+    "infected_ages = ages[sim.diseases.sir.infected]\n",
+    "\n",
+    "fig = plt.figure()\n",
+    "\n",
+    "plt.subplot(2,1,1)\n",
+    "plt.hist(ages, bins=range(0,100,5))\n",
+    "plt.title('Simulation age distribution')\n",
+    "plt.xlabel('Age')\n",
+    "plt.ylabel('Number of people')\n",
+    "\n",
+    "plt.subplot(2,1,2)\n",
+    "plt.hist(infected_ages, bins=range(0,100,5))\n",
+    "plt.title('Infection age distribution')\n",
+    "plt.xlabel('Age')\n",
+    "plt.ylabel('Number of people')\n",
+    "\n",
+    "sc.figlayout()\n",
+    "plt.show()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "b4dcf2fc",
+   "metadata": {},
+   "source": [
+    "Using similar logic, any other parameter could be set to depend on anything that the sim is aware of, including time or agent properties like age, sex, or health attributes.\n"
+   ]
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "base",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.12.2"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 5
+}
diff --git a/docs/tutorials/normalize_notebooks b/docs/tutorials/normalize_notebooks
new file mode 100755
index 0000000..29492a1
--- /dev/null
+++ b/docs/tutorials/normalize_notebooks
@@ -0,0 +1,30 @@
+#!/usr/bin/env python
+"""
+Normalize Jupyter notebooks
+"""
+
+import sciris as sc
+import nbformat
+
+T = sc.timer()
+
+filenames = sc.getfilelist('*.ipynb')
+
+print('Normalizing notebooks...')
+for filename in filenames:
+
+    # Load file
+    print(filename)
+    with open(filename, "r") as file:
+        nb_orig = nbformat.reader.read(file)
+
+    # Perform validation
+    nbformat.validator.validate(nb_orig)
+    nb_fixed = nbformat.validator.normalize(nb_orig)
+    nbformat.validator.validate(nb_fixed[1])
+
+    # Write output
+    with open(filename, "w") as file:
+        nbformat.write(nb_fixed[1], file)
+
+T.toc()
\ No newline at end of file
diff --git a/docs/tutorials/run_tutorials b/docs/tutorials/run_tutorials
new file mode 100755
index 0000000..df269b7
--- /dev/null
+++ b/docs/tutorials/run_tutorials
@@ -0,0 +1,62 @@
+#!/usr/bin/env python
+"""
+Run all the Jupyter notebook tutorials. Usage:
+  ./run_tutorials
+
+It will execute all notebooks in parallel, print out any errors
+encountered, and print a summary of results.
+
+NB: The execute() function was drafted in part via ChatGPT.
+"""
+
+import os
+import sciris as sc
+import nbformat
+import nbconvert.preprocessors as nbp
+
+folder = sc.path(__file__).resolve().parent # Ensure it's the real path if it's symlinked
+timeout = 600
+yay = '✓'
+boo = '😢'
+
+
+def execute(path):
+    """ Executes a single Jupyter notebook and returns success/failure """
+    try:
+        with open(path) as f:
+            print(f'Executing {path}...')
+            nb = nbformat.read(f, as_version=4)
+            ep = nbp.ExecutePreprocessor(timeout=timeout)
+            ep.preprocess(nb, {'metadata': {'path': os.path.dirname(path)}})
+        return f'{yay} {path} executed successfully.'
+    except nbp.CellExecutionError as e:
+        return f'{boo} Execution failed for {path}: {str(e)}'
+    except Exception as e:
+        return f'{boo} Error processing {path}: {str(e)}'
+
+
+def main():
+    """ Executes the notebooks in parallel and prints the results """
+    notebooks = sc.getfilepaths(folder=folder, pattern='*.ipynb')
+    results = sc.parallelize(execute, notebooks)
+    string = sc.newlinejoin(results)
+    
+    sc.heading('Results')
+    print(string)
+    
+    sc.heading('Summary')
+    n_yay = string.count(yay)
+    n_boo = string.count(boo)
+    summary = f'{n_yay} succeeded, {n_boo} failed'
+    if n_boo:
+        for i in range(len(notebooks)):
+            if boo in results[i]:
+                summary += f'\nFailed: {notebooks[i]}'
+    print(summary)
+    
+    return results
+
+
+if __name__ == '__main__':
+    results = main()
+
diff --git a/docs/tutorials/tut_buildsim.ipynb b/docs/tutorials/tut_buildsim.ipynb
index 0a374c4..978e063 100644
--- a/docs/tutorials/tut_buildsim.ipynb
+++ b/docs/tutorials/tut_buildsim.ipynb
@@ -2,6 +2,7 @@
  "cells": [
   {
    "cell_type": "markdown",
+   "id": "79a4bb76",
    "metadata": {},
    "source": [
     "# T2 - How to build your model\n",
@@ -13,8 +14,24 @@
   },
   {
    "cell_type": "markdown",
+   "id": "13049772",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/tut_buildsim.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Ftut_buildsim.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "36126a51",
    "metadata": {
-    "collapsed": false
+    "collapsed": false,
+    "jupyter": {
+     "outputs_hidden": false
+    }
    },
    "source": [
     "## Simple SIR model\n",
@@ -25,8 +42,12 @@
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "e39a8782",
    "metadata": {
-    "collapsed": false
+    "collapsed": false,
+    "jupyter": {
+     "outputs_hidden": false
+    }
    },
    "outputs": [],
    "source": [
@@ -49,13 +70,17 @@
     "# Make the sim, run and plot\n",
     "sim = ss.Sim(pars)\n",
     "sim.run()\n",
-    "sim.plot();"
+    "sim.plot()"
    ]
   },
   {
    "cell_type": "markdown",
+   "id": "b35591f8",
    "metadata": {
-    "collapsed": false
+    "collapsed": false,
+    "jupyter": {
+     "outputs_hidden": false
+    }
    },
    "source": [
     "Now let's look at the `pars` dictionary in more detail. The one we've created here has 3 things in it: the number of agents (`n_agents`), detail on how the agents interact with each other (`networks`) and detail on what disease we're modeling (`diseases`). When we create and run the model, what happens 'under the hood' is that the simulation creates 5,000 people, and allows them to the interact with one another over the network and transmit the infection. \n",
@@ -67,6 +92,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "b3e79bfc",
    "metadata": {},
    "outputs": [],
    "source": [
@@ -75,13 +101,17 @@
     "sir = ss.SIR(init_prev=0.1, beta=0.1)\n",
     "sim = ss.Sim(diseases=sir, people=people, networks=network)\n",
     "sim.run()\n",
-    "sim.plot();"
+    "sim.plot()"
    ]
   },
   {
    "cell_type": "markdown",
+   "id": "64e760ac",
    "metadata": {
-    "collapsed": false
+    "collapsed": false,
+    "jupyter": {
+     "outputs_hidden": false
+    }
    },
    "source": [
     "Rather than bundling everything under pars, we're now defining components individually for people, networks, and diseases. As for the disease/network details, instead of putting all information in one bucket (`pars['diseases'] = dict(name='sir', init_prev=0.1, beta=0.1)`), we're now using `ss.SIR() `which serves as a prepared 'template' where we fill in the details. This new way provides us more flexibility to adjust details of the disease as we need.\n",
@@ -96,20 +126,28 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 7,
+   "id": "d17dd68a",
    "metadata": {
-    "collapsed": false
+    "collapsed": false,
+    "jupyter": {
+     "outputs_hidden": false
+    }
    },
    "outputs": [],
    "source": [
     "network = ss.RandomNet(pars={'n_contacts': ss.poisson(4)})\n",
-    "network = ss.RandomNet(pars=dict(n_contacts=dict(type='poisson', scale=4)))"
+    "network = ss.RandomNet(n_contacts=dict(type='poisson', lam=4))"
    ]
   },
   {
    "cell_type": "markdown",
+   "id": "24a9599d",
    "metadata": {
-    "collapsed": false
+    "collapsed": false,
+    "jupyter": {
+     "outputs_hidden": false
+    }
    },
    "source": [
     "If we use this network, our agents will have varying numbers of contacts."
@@ -117,8 +155,12 @@
   },
   {
    "cell_type": "markdown",
+   "id": "be4847a8",
    "metadata": {
-    "collapsed": false
+    "collapsed": false,
+    "jupyter": {
+     "outputs_hidden": false
+    }
    },
    "source": [
     "## Accessing results \n",
@@ -131,18 +173,27 @@
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "ad4fac82",
    "metadata": {
-    "collapsed": false
+    "collapsed": false,
+    "jupyter": {
+     "outputs_hidden": false
+    }
    },
    "outputs": [],
    "source": [
-    "sim = ss.Sim(start=2020, n_years=1, dt=1/12)  # Simulate from 2020 for 1 year with a monthly timestep"
+    "sim = ss.Sim(start='2020-01-01', stop='2021-01-01', unit='month', diseases='sis', networks=network)  # Simulate from 2020 for 1 year with a monthly timestep\n",
+    "sim.run().plot()"
    ]
   },
   {
    "cell_type": "markdown",
+   "id": "c42bb5d0",
    "metadata": {
-    "collapsed": false
+    "collapsed": false,
+    "jupyter": {
+     "outputs_hidden": false
+    }
    },
    "source": [
     "## Summary \n",
@@ -157,7 +208,7 @@
  ],
  "metadata": {
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "base",
    "language": "python",
    "name": "python3"
   },
@@ -171,31 +222,9 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.11.7"
-  },
-  "pycharm": {
-   "stem_cell": {
-    "cell_type": "raw",
-    "metadata": {
-     "collapsed": false
-    },
-    "source": []
-   }
-  },
-  "toc": {
-   "base_numbering": 1,
-   "nav_menu": {},
-   "number_sections": true,
-   "sideBar": true,
-   "skip_h1_title": false,
-   "title_cell": "Table of Contents",
-   "title_sidebar": "Contents",
-   "toc_cell": false,
-   "toc_position": {},
-   "toc_section_display": true,
-   "toc_window_display": false
+   "version": "3.12.2"
   }
  },
  "nbformat": 4,
- "nbformat_minor": 4
+ "nbformat_minor": 5
 }
diff --git a/docs/tutorials/tut_demographics.ipynb b/docs/tutorials/tut_demographics.ipynb
index 93c3981..a7a0385 100644
--- a/docs/tutorials/tut_demographics.ipynb
+++ b/docs/tutorials/tut_demographics.ipynb
@@ -2,16 +2,37 @@
  "cells": [
   {
    "cell_type": "markdown",
+   "id": "e0c09801",
+   "metadata": {},
+   "source": [
+    "# T3 - Demographics "
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "5f220c21",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/tut_demographics.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Ftut_demographics.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "4a666d81",
    "metadata": {},
    "source": [
-    "# T3 - Demographics \n",
     "\n",
     "There are a few basic ways to add vital dynamics to your model, e.g. "
    ]
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 1,
+   "id": "7dc8b21a",
    "metadata": {
     "collapsed": false
    },
@@ -30,17 +51,19 @@
   },
   {
    "cell_type": "markdown",
+   "id": "2f5ad9e8",
    "metadata": {
     "collapsed": false
    },
    "source": [
     "\n",
-    "This will apply annual birth and death rates as specified in the `pars` dict. Alternatively, we can make demographic components:"
+    "This will apply annual birth and death rates as specified in the `pars` dict. Alternatively, we can make demographic components, which achieves the same thing:"
    ]
   },
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "acfa0a44",
    "metadata": {
     "collapsed": false
    },
@@ -50,16 +73,40 @@
     "    ss.Births(birth_rate=20),\n",
     "    ss.Deaths(death_rate=15)\n",
     "]\n",
-    "sim = ss.Sim(diseases='sir', networks='random', demographics=demographics)"
+    "sim = ss.Sim(demographics=demographics)"
    ]
   },
   {
    "cell_type": "markdown",
-   "metadata": {
-    "collapsed": false
-   },
+   "id": "8b9d6b6d",
+   "metadata": {},
+   "source": [
+    "You can even simply set `demographics=True` to use default rates:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "3b914207",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "ss.Sim(demographics=True).run().plot();"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "cbeb0b9a",
+   "metadata": {},
+   "source": [
+    "By default, agents age if and only if at least one demographics module is included. You can override this behavior by setting `use_aging`, e.g. `ss.Sim(use_aging=False)`"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "2027fecb",
+   "metadata": {},
    "source": [
-    "Both achieve the same thing. \n",
     "\n",
     "## Scaling results to whole populations\n",
     "Even though we've been simulating populations of a few thousand agents, we can also use the `total_pop` parameter to scale our results so that they reflect a much larger population. You can think of this as a kind of statistical sampling approximation. If we want to model the population of Nigeria, for example, it would be much too computationally intensive to simulate 200 million agents. However, we could simulate 50,000 agents and then say that each agent represents 4,000 people. Again, we can do this by passing `total_pop=200e6` to the sim or in the `pars` dictionary. Here's an example:"
@@ -67,7 +114,8 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 3,
+   "id": "753528fa",
    "metadata": {
     "collapsed": false
    },
@@ -82,6 +130,7 @@
   },
   {
    "cell_type": "markdown",
+   "id": "e5b0bd8a",
    "metadata": {
     "collapsed": false
    },
@@ -93,6 +142,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "4bf3309e",
    "metadata": {
     "collapsed": false
    },
@@ -100,13 +150,14 @@
    "source": [
     "import starsim as ss\n",
     "import pandas as pd\n",
+    "import matplotlib.pyplot as plt\n",
     "\n",
     "# Read in age-specific fertility rates\n",
     "fertility_rates = pd.read_csv('test_data/nigeria_asfr.csv')\n",
     "pregnancy = ss.Pregnancy(pars={'fertility_rate': fertility_rates})\n",
     "\n",
     "death_rates = pd.read_csv('test_data/nigeria_deaths.csv')\n",
-    "death = ss.Deaths(pars={'death_rate': death_rates, 'units': 1})\n",
+    "death = ss.Deaths(pars={'death_rate': death_rates, 'rate_units': 1})\n",
     "\n",
     "demographics = [pregnancy, death]\n",
     "\n",
@@ -125,31 +176,31 @@
     "data = nigeria_popsize[(nigeria_popsize.year >= 1995) & (nigeria_popsize.year <= 2030)]\n",
     "\n",
     "# Plot the overall population size - simulated vs data\n",
-    "import matplotlib.pyplot as plt\n",
     "fig, ax = plt.subplots(1, 1)\n",
+    "res = sim.results\n",
     "ax.scatter(data.year, data.n_alive, alpha=0.5, label='Data')\n",
-    "ax.plot(sim.yearvec, sim.results.n_alive, color='k', label='Model')\n",
+    "ax.plot(res.timevec, res.n_alive, color='k', label='Model')\n",
     "ax.legend()\n",
     "ax.set_title('Population')\n",
-    "plt.show();"
+    "plt.show()"
    ]
   },
   {
    "cell_type": "markdown",
+   "id": "42921340",
    "metadata": {
     "collapsed": false
    },
    "source": [
     "If you want to use realistic demographics for your model, you can adapt the data files and code snippet above to read in the relevant demographic data files for your country/setting.\n",
     "\n",
-    "Note:\n",
-    "- In the code block above, we set the units of the mortality data to 1, as opposed to 1/1000. If your data come in the form of deaths per 1000 people, set units to 1/1000. "
+    "*Note*: In the code block above, we set the units of the mortality data to 1, as opposed to 1/1000. If your data come in the form of deaths per 1000 people, set units to 1/1000. Note also that as per standard definitions, `fertility_rate` is defined per *woman*, whereas `birth_rate` is defined per *person*."
    ]
   }
  ],
  "metadata": {
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "base",
    "language": "python",
    "name": "python3"
   },
@@ -163,31 +214,9 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.11.7"
-  },
-  "pycharm": {
-   "stem_cell": {
-    "cell_type": "raw",
-    "metadata": {
-     "collapsed": false
-    },
-    "source": []
-   }
-  },
-  "toc": {
-   "base_numbering": 1,
-   "nav_menu": {},
-   "number_sections": true,
-   "sideBar": true,
-   "skip_h1_title": false,
-   "title_cell": "Table of Contents",
-   "title_sidebar": "Contents",
-   "toc_cell": false,
-   "toc_position": {},
-   "toc_section_display": true,
-   "toc_window_display": false
+   "version": "3.12.2"
   }
  },
  "nbformat": 4,
- "nbformat_minor": 4
+ "nbformat_minor": 5
 }
diff --git a/docs/tutorials/tut_diseases.ipynb b/docs/tutorials/tut_diseases.ipynb
index 2ba4a8e..32e24e8 100644
--- a/docs/tutorials/tut_diseases.ipynb
+++ b/docs/tutorials/tut_diseases.ipynb
@@ -2,9 +2,29 @@
  "cells": [
   {
    "cell_type": "markdown",
+   "id": "49cd23ac",
+   "metadata": {},
+   "source": [
+    "# T4 - Diseases"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "8d394d0f",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/tut_diseases.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Ftut_diseases.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "f2202221",
    "metadata": {},
    "source": [
-    "# T5 - Diseases\n",
     "\n",
     "Diseases are the cornerstone of almost any Starsim analysis. This is where you add details about what disease you are modeling, including transmissibility, natural history, and mortality outcomes.      \n",
     "\n",
@@ -15,6 +35,7 @@
   },
   {
    "cell_type": "markdown",
+   "id": "dc2a1cb6",
    "metadata": {},
    "source": [
     "## Modifying a disease\n",
@@ -25,6 +46,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "ba3ff270",
    "metadata": {},
    "outputs": [],
    "source": [
@@ -36,6 +58,7 @@
   },
   {
    "cell_type": "markdown",
+   "id": "cd44e476",
    "metadata": {
     "collapsed": false,
     "jupyter": {
@@ -52,6 +75,7 @@
   },
   {
    "cell_type": "markdown",
+   "id": "08391ccb",
    "metadata": {
     "collapsed": false,
     "jupyter": {
@@ -60,12 +84,13 @@
    },
    "source": [
     "## Adding multiple diseases\n",
-    "You can add multiple diseases to the same simulation, like so. Here we are making use of a _connector_. A connector is a special thing in Starsim that tells you how two things relate to one another - in this case, how HIV modifies a person's transmissibility and susceptibility to gonorrhea and vice versa "
+    "You can add multiple diseases to the same simulation, like so. Here we are making use of a \"connector\". A connector is a module in Starsim that tells you how two things relate to one another - in this case, how HIV modifies a person's transmissibility and susceptibility to gonorrhea and vice versa. Unlike dieases, networks, interventions, etc., connectors don't have any pre-specified location in the sim. Instead, they can be placed wherever they make the most sense (for example, a connector that mediated how two networks behaved might be placed at the beginning or end of the list of networks; for diseases, it might be placed at the beginning or end of the list of diseases)."
    ]
   },
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "269ba6a1",
    "metadata": {
     "collapsed": false,
     "jupyter": {
@@ -76,14 +101,12 @@
    "source": [
     "import sciris as sc\n",
     "import starsim as ss\n",
-    "import pylab as pl\n",
-    "sc.options(jupyter=True)\n",
     "\n",
-    "class simple_hiv_ng(ss.Connector):\n",
+    "class simple_hiv_ng(ss.Module):\n",
     "    \"\"\" Simple connector whereby rel_sus to NG doubles if CD4 count is <200\"\"\"\n",
-    "    def __init__(self, pars=None, **kwargs):\n",
-    "        super().__init__(label='HIV-Gonorrhea', requires=[ss.HIV, ss.Gonorrhea])\n",
-    "        self.default_pars(\n",
+    "    def __init__(self, pars=None, label='HIV-Gonorrhea', **kwargs):\n",
+    "        super().__init__()\n",
+    "        self.define_pars(\n",
     "            rel_trans_hiv  = 2,\n",
     "            rel_trans_aids = 5,\n",
     "            rel_sus_hiv    = 2,\n",
@@ -92,7 +115,7 @@
     "        self.update_pars(pars, **kwargs)\n",
     "        return\n",
     "\n",
-    "    def update(self):\n",
+    "    def step(self):\n",
     "        \"\"\" Specify how HIV increases NG rel_sus and rel_trans \"\"\"\n",
     "        people = self.sim.people\n",
     "        people.gonorrhea.rel_sus[people.hiv.cd4 < 500] = self.pars.rel_sus_hiv\n",
@@ -115,16 +138,16 @@
     "\n",
     "# Make the sim, including a connector betweeh HIV and gonorrhea:\n",
     "n_agents = 5_000\n",
-    "sim = ss.Sim(n_agents=n_agents, networks='mf', diseases=[hiv, ng], connectors=simple_hiv_ng())\n",
+    "sim = ss.Sim(n_agents=n_agents, networks='mf', diseases=[simple_hiv_ng(), hiv, ng])\n",
     "sim.run()\n",
     "sim.plot('hiv')\n",
-    "sim.plot('gonorrhea');"
+    "sim.plot('gonorrhea')"
    ]
   }
  ],
  "metadata": {
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "base",
    "language": "python",
    "name": "python3"
   },
@@ -138,31 +161,9 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.11.7"
-  },
-  "pycharm": {
-   "stem_cell": {
-    "cell_type": "raw",
-    "metadata": {
-     "collapsed": false
-    },
-    "source": []
-   }
-  },
-  "toc": {
-   "base_numbering": 1,
-   "nav_menu": {},
-   "number_sections": true,
-   "sideBar": true,
-   "skip_h1_title": false,
-   "title_cell": "Table of Contents",
-   "title_sidebar": "Contents",
-   "toc_cell": false,
-   "toc_position": {},
-   "toc_section_display": true,
-   "toc_window_display": false
+   "version": "3.12.2"
   }
  },
  "nbformat": 4,
- "nbformat_minor": 4
+ "nbformat_minor": 5
 }
diff --git a/docs/tutorials/tut_interventions.ipynb b/docs/tutorials/tut_interventions.ipynb
index 053294c..53bf9ec 100644
--- a/docs/tutorials/tut_interventions.ipynb
+++ b/docs/tutorials/tut_interventions.ipynb
@@ -2,6 +2,7 @@
  "cells": [
   {
    "cell_type": "markdown",
+   "id": "0911386d",
    "metadata": {},
    "source": [
     "# T6 - Interventions\n",
@@ -11,6 +12,19 @@
   },
   {
    "cell_type": "markdown",
+   "id": "c4a4a2ee",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/tut_interventions.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Ftut_interventions.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "4574ce23",
    "metadata": {},
    "source": [
     "## Products and interventions\n",
@@ -35,7 +49,8 @@
   },
   {
    "cell_type": "code",
-   "execution_count": null,
+   "execution_count": 2,
+   "id": "d609380d",
    "metadata": {},
    "outputs": [],
    "source": [
@@ -59,6 +74,7 @@
   },
   {
    "cell_type": "markdown",
+   "id": "39bb9ca3",
    "metadata": {
     "collapsed": false
    },
@@ -69,6 +85,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "33d18540",
    "metadata": {
     "collapsed": false
    },
@@ -93,6 +110,7 @@
   },
   {
    "cell_type": "markdown",
+   "id": "abe7afff",
    "metadata": {
     "collapsed": false
    },
@@ -103,6 +121,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "4a563cdc",
    "metadata": {
     "collapsed": false
    },
@@ -114,16 +133,17 @@
     "res_intv = sim_intv.results\n",
     "\n",
     "plt.figure()\n",
-    "plt.plot(res_base.yearvec, res_base.sir.prevalence, label='Baseline')\n",
-    "plt.plot(res_intv.yearvec, res_intv.sir.prevalence, label='Vax')\n",
+    "plt.plot(res_base.timevec, res_base.sir.prevalence, label='Baseline')\n",
+    "plt.plot(res_intv.timevec, res_intv.sir.prevalence, label='Vax')\n",
     "plt.axvline(x=2015, color='k', ls='--')\n",
     "plt.title('Prevalence')\n",
     "plt.legend()\n",
-    "plt.show();"
+    "plt.show()"
    ]
   },
   {
    "cell_type": "markdown",
+   "id": "7353fc91",
    "metadata": {
     "collapsed": false
    },
@@ -134,7 +154,7 @@
  ],
  "metadata": {
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "base",
    "language": "python",
    "name": "python3"
   },
@@ -148,31 +168,9 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.11.7"
-  },
-  "pycharm": {
-   "stem_cell": {
-    "cell_type": "raw",
-    "metadata": {
-     "collapsed": false
-    },
-    "source": []
-   }
-  },
-  "toc": {
-   "base_numbering": 1,
-   "nav_menu": {},
-   "number_sections": true,
-   "sideBar": true,
-   "skip_h1_title": false,
-   "title_cell": "Table of Contents",
-   "title_sidebar": "Contents",
-   "toc_cell": false,
-   "toc_position": {},
-   "toc_section_display": true,
-   "toc_window_display": false
+   "version": "3.12.2"
   }
  },
  "nbformat": 4,
- "nbformat_minor": 4
+ "nbformat_minor": 5
 }
diff --git a/docs/tutorials/tut_intro.ipynb b/docs/tutorials/tut_intro.ipynb
index f26e4b4..d97d51d 100644
--- a/docs/tutorials/tut_intro.ipynb
+++ b/docs/tutorials/tut_intro.ipynb
@@ -2,6 +2,7 @@
  "cells": [
   {
    "cell_type": "markdown",
+   "id": "dd65a1f9",
    "metadata": {},
    "source": [
     "# T1 - Getting started\n",
@@ -23,6 +24,19 @@
   },
   {
    "cell_type": "markdown",
+   "id": "c00c109e",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/tut_intro.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Ftut_intro.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "2ae50b40",
    "metadata": {},
    "source": [
     "## Hello world\n",
@@ -33,6 +47,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
+   "id": "c6b0dfc8",
    "metadata": {},
    "outputs": [],
    "source": [
@@ -40,26 +55,28 @@
     "\n",
     "# Define the parameters\n",
     "pars = dict(\n",
-    "    n_agents = 5_000,     # Number of agents to simulate\n",
+    "    n_agents = 10_000,    # Number of agents to simulate\n",
     "    networks = dict(      # *Networks* add detail on how the agents interact with each other \n",
     "        type = 'random',  # Here, we use a 'random' network\n",
-    "        n_contacts = 10    # Each person has an average of 10 contacts with other people\n",
+    "        n_contacts = 10   # Each person has an average of 10 contacts with other people\n",
     "    ),\n",
     "    diseases = dict(      # *Diseases* add detail on what diseases to model \n",
     "        type = 'sir',     # Here, we're creating an SIR disease \n",
-    "        init_prev = 0.1,  # Proportion of the population initially infected \n",
-    "        beta = 0.5,       # Probability of transmission between contacts\n",
+    "        init_prev = 0.01, # Proportion of the population initially infected \n",
+    "        beta = 0.05,      # Probability of transmission between contacts\n",
     "    )\n",
     ")\n",
     "\n",
     "# Make the sim, run and plot\n",
     "sim = ss.Sim(pars)\n",
     "sim.run()\n",
-    "sim.plot();"
+    "sim.plot()\n",
+    "sim.diseases.sir.plot()"
    ]
   },
   {
    "cell_type": "markdown",
+   "id": "02be91b3",
    "metadata": {},
    "source": [
     "As the tutorials progress we'll show how to extend this different diseases with different transmission pathways, and how to customize the model in lots of different ways."
@@ -68,7 +85,7 @@
  ],
  "metadata": {
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "base",
    "language": "python",
    "name": "python3"
   },
@@ -82,7 +99,7 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.11.7"
+   "version": "3.12.2"
   }
  },
  "nbformat": 4,
diff --git a/docs/tutorials/tut_networks.ipynb b/docs/tutorials/tut_networks.ipynb
deleted file mode 100644
index 939134c..0000000
--- a/docs/tutorials/tut_networks.ipynb
+++ /dev/null
@@ -1,211 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "metadata": {},
-   "source": [
-    "# T4 - Networks\n",
-    "\n",
-    "Many infectious diseases transmit when people come into contact with one another. In the basic SIR example that we covered in the first two tutorials, we used a 'random' contact network, which creates random pairings of people. Generally speaking, the structure of network that you use depends on what disease you're modeling. In addition to the 'random' network, Starim contains some basic sexual networks for modeling sexually transmitted infections (STIs) and a 'maternal' network for modeling mother-to-child transmission.  \n",
-    "\n",
-    "In this tutorial, we'll demonstrate a couple of the built-in networks, and give an overview of how you might create your own for your own disease modeling work."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {},
-   "source": [
-    "## Overview of Starsim's network structure\n",
-    "\n",
-    "Starsim's networks are stored in the `networks.py` file. At the top of this file you'll see the `Network` class, which provides the template for all the other networks. At a high level, all you need to know is that network stores various *parameters* that determine how pairs of people form and dissolve, and a collection of all the *contacts* that exist at a given point in time. Let's look at a simple example of the `random` network:"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [],
-   "source": [
-    "import starsim as ss\n",
-    "\n",
-    "# Make random network\n",
-    "random = ss.RandomNet()"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "collapsed": false
-   },
-   "source": [
-    "The network we just made stores two very important things: the list of contacts (found in `random.contacts`) and the parameters (`random.pars`).  \n",
-    "\n",
-    "If we just make a network on its own like this, it's not very interesting. Like all components of Starsim, it needs to be initialized within a sim before the database of contacts gets populated:"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "network = ss.RandomNet()\n",
-    "sir = ss.SIR()\n",
-    "sim = ss.Sim(n_agents=2_000, diseases=sir, networks=network)\n",
-    "sim.initialize()"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "collapsed": false
-   },
-   "source": [
-    "Now `sim.networks.random.contacts` has all the information about which agents (referenced by their UID) are paired with which other agents.\n",
-    "\n",
-    "## Sexual networks\n",
-    "Starsim contains a few basic sexual networks, including an `mf` network for modeling heterosexual partnerships and an `msm` network for men having sex with men. Modeling STIs is a straightforward extension of the SIR example we looked at previously. Here's an example modeling syphilis:"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {
-    "collapsed": false
-   },
-   "outputs": [],
-   "source": [
-    "# Create the disease\n",
-    "syph = ss.Syphilis(\n",
-    "    beta = {'mf': [0.25, 0.15]},    # See notes below \n",
-    ")\n",
-    "\n",
-    "# Create a heterosexual network\n",
-    "mf = ss.MFNet(\n",
-    "    duration=1/24,  # Using very short relationships so that we get more transmission \n",
-    "    acts=80,        # Distribution of the number of coital acts/year\n",
-    ")\n",
-    "\n",
-    "pars = dict(dt=1/12, start=2000, n_years=20)\n",
-    "sim = ss.Sim(pars=pars, diseases=syph, networks=mf)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "collapsed": false
-   },
-   "source": [
-    "The main difference here is that we've added the line `syph.pars['beta'] = {'mf': [0.25, 0.15]}`. Because STIs are generally more transmissible from males to females than vice versa, we can specify `beta` as a list, and we can also allow it to vary between networks. For instance, if we also had an MSM network here, we could set \n",
-    "```\n",
-    "syph.pars.update(beta = {'mf': [0.25, 0.15], 'msm': [0.4, 0.4]})\n",
-    "```\n",
-    "The sexual network itself is structurally similar to the `random` network that we looked at previously, and can be customized by changing the `pars` dictionary that's used to construct it.\n",
-    " \n",
-    "## Maternal networks\n",
-    "Maternal networks are useful for capturing mother-to-child transmission. If you want to use them, you also need to model pregnancy. Here's an example showing how you would do this for syphilis:"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {
-    "collapsed": false
-   },
-   "outputs": [],
-   "source": [
-    "syph = ss.Syphilis(\n",
-    "    beta = {'mf': [0.25, 0.15], 'maternal': [0.99, 0]}\n",
-    ")\n",
-    "\n",
-    "# Make demographic modules\n",
-    "pregnancy = ss.Pregnancy(fertility_rate=20)\n",
-    "death = ss.Deaths(death_rate=15)\n",
-    "\n",
-    "# Make maternal network\n",
-    "maternal = ss.MaternalNet()\n",
-    "\n",
-    "# Make sim\n",
-    "sim = ss.Sim(pars=pars, diseases=syph, networks=[mf, maternal], demographics=[pregnancy, death])"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "collapsed": false
-   },
-   "source": [
-    "## Making your own network\n",
-    "If you want to make your own network, a good place to start is by inheriting from one of the templates in networks.py. For example, if you wanted to make an `mf` network that has more age structure, you could do something like this:"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {
-    "collapsed": false
-   },
-   "outputs": [],
-   "source": [
-    "class age_mf(ss.MFNet):\n",
-    "    def add_pairs(self, people, ti=None):\n",
-    "        # Custom code to select pairs based on age\n",
-    "        return "
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "metadata": {
-    "collapsed": false
-   },
-   "source": [
-    "This network would operate exactly like the existing `mf` network, but you could control how new pairs were added.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
-   "language": "python",
-   "name": "python3"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.11.7"
-  },
-  "pycharm": {
-   "stem_cell": {
-    "cell_type": "raw",
-    "metadata": {
-     "collapsed": false
-    },
-    "source": []
-   }
-  },
-  "toc": {
-   "base_numbering": 1,
-   "nav_menu": {},
-   "number_sections": true,
-   "sideBar": true,
-   "skip_h1_title": false,
-   "title_cell": "Table of Contents",
-   "title_sidebar": "Contents",
-   "toc_cell": false,
-   "toc_position": {},
-   "toc_section_display": true,
-   "toc_window_display": false
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 4
-}
diff --git a/docs/tutorials/tut_transmission.ipynb b/docs/tutorials/tut_transmission.ipynb
new file mode 100644
index 0000000..5634948
--- /dev/null
+++ b/docs/tutorials/tut_transmission.ipynb
@@ -0,0 +1,507 @@
+{
+ "cells": [
+  {
+   "cell_type": "markdown",
+   "id": "a8590a81",
+   "metadata": {},
+   "source": [
+    "# T5 - Transmission"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "1ada2412",
+   "metadata": {},
+   "source": [
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "An interactive version of this notebook is available on [Google Colab](https://colab.research.google.com/github/starsimhub/starsim/blob/main/docs/tutorials/tut_transmission.ipynb?install=starsim) or [Binder](https://mybinder.org/v2/gh/starsimhub/starsim/HEAD?labpath=docs%2Ftutorials%2Ftut_transmission.ipynb).\n",
+    "    \n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "884f0f84",
+   "metadata": {},
+   "source": [
+    "\n",
+    "Many infectious diseases transmit when people come into contact with one another. In the basic SIR example that we covered in the first two tutorials, we used a 'random' contact network, which creates random pairings of people. Generally speaking, the structure of network that you use depends on what disease you're modeling.\n",
+    "\n",
+    "Starsim contains two different approaches to disease transmission.\n",
+    "\n",
+    "**Contact network:** Disease transmits on individual person-to-person relationships. These are networks in the sense that each agent (person) can be viewed as a node and each contact is an edge. Networks are undirected in the sense that an edge will allow transmission in both directions, however you can make transmission stronger one way (p1-->p2) than the other (p2-->p1). The framework includes several pre-built contact network algorithms, each of which manages a list of edges that can change on each simulation step. In addition to the 'random' network, the framework include algorithms representing basic sexual networks for modeling sexually transmitted infections (STIs) and a 'maternal' network for modeling mother-to-child transmission.\n",
+    "\n",
+    "**Mixing pools:** Simulate well-mixed transmission from one group of agents to another. Each mixing pool simulates directed transmission from a group of source agents to a group of destination agents. Instead of simulating individual edges like in a contact network, mixing pools first compute the total \"contagion\" that is shed by the source group. This total contagion value is normalized by the number of agents in the source group to arrive at a value that represents a typical infectious source agent. Then, each destination agent is exposed to this typical (average) infectious agent, likely resulting in new infections in the destination group. Multiple mixing pools can be run simultaneously to simulate heterogeneous transmission between various source and destination groups. Mixing pools could be used with age contact matrices like those developed by Prem et al.\n",
+    "\n",
+    "Note that contact networks and mixing pools can be used together in a single simulation.\n",
+    "\n",
+    "In this tutorial, we'll demonstrate a couple of the built-in contact networks, and give an overview of how you might create your own for your own disease modeling work. We'll also demonstrate how to use mixing pools."
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "123831c1",
+   "metadata": {},
+   "source": [
+    "## Overview of Starsim's contact network structure\n",
+    "\n",
+    "Starsim's networks are stored in the `networks.py` file. At the top of this file you'll see the `Network` class, which provides the template for all the other networks. At a high level, all you need to know is that network stores various *parameters* that determine how pairs of people form and dissolve, and a collection of all the *edges* that exist at a given point in time. Let's look at a simple example of the `random` network:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 13,
+   "id": "04b07551",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [],
+   "source": [
+    "import starsim as ss\n",
+    "import numpy as np\n",
+    "import matplotlib.pyplot as plt\n",
+    "\n",
+    "# Make random network\n",
+    "random = ss.RandomNet()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "5e16e5ea",
+   "metadata": {
+    "collapsed": false
+   },
+   "source": [
+    "The network we just made stores two very important things: the list of contacts (found in `random.edges`) and the parameters (`random.pars`).  \n",
+    "\n",
+    "If we just make a network on its own like this, it's not very interesting. Like all components of Starsim, it needs to be initialized within a `sim` before the database of contacts gets populated:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "f2b1686b",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "net = ss.RandomNet()\n",
+    "sir = ss.SIR()\n",
+    "sim = ss.Sim(n_agents=100, diseases=sir, networks=net) # Decreasing n_agents so we can plot the network below\n",
+    "sim.init()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "34922029",
+   "metadata": {
+    "collapsed": false
+   },
+   "source": [
+    "We can easily take a look at the list of edges between agents. All networks are stored in `sim.networks`, and individual networks can be found at their class name after conversion to lower case. So for this example, `sim.networks.randomnet.edges` has all the information about which agents (referenced by their UID) are paired with which other agents as well as a per-edge transmission multiplier called `beta` and a per-edge duration, `dur`."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "a835439d",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "sim.networks.randomnet"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "0affb7bc",
+   "metadata": {},
+   "source": [
+    "Networks provide some basic functionality, for example to identify contacts. Additionally, the edge list can be quickly converted to a Pandas data frame for further analysis and manipulation."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "09da79de",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "net = sim.networks.randomnet\n",
+    "\n",
+    "# Use the \"find_contacts\" function to find all contacts of agent with uid 0\n",
+    "contacts_of_agent_0 = net.find_contacts([0])\n",
+    "print('The following agents were identified as contacts of agent 0:', contacts_of_agent_0)\n",
+    "\n",
+    "# Convert to a pandas DataFrame and manually find all edges involving agent with uid 0\n",
+    "df = net.to_df()\n",
+    "uid0_edges = df.loc[(df['p1']==0) | (df['p2']==0)]\n",
+    "print('\\nEdges involving UID 0 extracted from the edge list data frame:')\n",
+    "display(uid0_edges)\n",
+    "\n",
+    "import networkx as nx\n",
+    "G = net.to_graph()\n",
+    "nx.draw(G, with_labels=True)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "285679db",
+   "metadata": {},
+   "source": [
+    "\n",
+    "## Sexual networks\n",
+    "Starsim contains a few basic sexual networks, including an `mf` network for modeling heterosexual partnerships and an `msm` network for men having sex with men. Modeling STIs is a straightforward extension of the SIR example we looked at previously. Here's an example modeling syphilis:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 17,
+   "id": "dd802fdd",
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "# Create the disease\n",
+    "syph = ss.Syphilis(\n",
+    "    beta = {'mf': [0.25, 0.15]},    # See notes below \n",
+    ")\n",
+    "\n",
+    "# Create a heterosexual network\n",
+    "mf = ss.MFNet(\n",
+    "    duration=1/24,  # Using very short relationships so that we get more transmission \n",
+    "    acts=80,        # Distribution of the number of coital acts/year\n",
+    ")\n",
+    "\n",
+    "pars = dict(start=2000, dur=20, dt=1/12)\n",
+    "sim = ss.Sim(pars=pars, diseases=syph, networks=mf)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "e0905383",
+   "metadata": {
+    "collapsed": false
+   },
+   "source": [
+    "The main difference here is that we've added the line `syph.pars['beta'] = {'mf': [0.25, 0.15]}`. Because STIs are generally more transmissible from males to females than vice versa, we can specify `beta` as a list, and we can also allow it to vary between networks. For instance, if we also had an MSM network here, we could set \n",
+    "```\n",
+    "syph.pars.update(beta = {'mf': [0.25, 0.15], 'msm': [0.4, 0.4]})\n",
+    "```\n",
+    "The sexual network itself is structurally similar to the `random` network that we looked at previously, and can be customized by changing the `pars` dictionary that's used to construct it.\n",
+    " \n",
+    "## Maternal networks\n",
+    "Maternal networks are useful for capturing mother-to-child transmission. If you want to use them, you also need to model pregnancy. As new agents are born via pregnancy, edges are automatically added between mother and prenatal child in the maternal network. Here's an example showing how you would do this for syphilis:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "860b879b",
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "syph = ss.Syphilis(\n",
+    "    beta = {'mf': [0.25, 0.15], 'maternal': [0.99, 0]}\n",
+    ")\n",
+    "\n",
+    "# Make demographic modules\n",
+    "pregnancy = ss.Pregnancy(fertility_rate=20)\n",
+    "death = ss.Deaths(death_rate=15)\n",
+    "\n",
+    "# Make maternal network\n",
+    "maternal = ss.MaternalNet()\n",
+    "\n",
+    "# Make sim\n",
+    "sim = ss.Sim(pars=pars, diseases=syph, networks=[mf, maternal], demographics=[pregnancy, death], dur=10)\n",
+    "sim.run().plot(show_module=False)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "c2267da9",
+   "metadata": {
+    "collapsed": false
+   },
+   "source": [
+    "## Making your own contact network\n",
+    "If you want to make your own network, a good place to start is by inheriting from one of the templates in networks.py. For example, if you wanted to make an `mf` network that has more age structure, you could do something like this:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 19,
+   "id": "90ebaea5",
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "class age_mf(ss.MFNet):\n",
+    "    def add_pairs(self, people, ti=None):\n",
+    "        # Custom code to select pairs based on age\n",
+    "        return "
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "cdf7586a",
+   "metadata": {
+    "collapsed": false
+   },
+   "source": [
+    "This network would operate exactly like the existing `mf` network, but you could control how new pairs were added.\n"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "46760c64",
+   "metadata": {},
+   "source": [
+    "# Mixing Pools"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "fc8725f0",
+   "metadata": {},
+   "source": [
+    "Let's compare a simple SIR model configured with transmission using a single Mixing Pool to a similar model using a contact network. Mixing pools are not the same as contact networks, so the results are not expected to be identical."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "e0298394",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "# Transmission using a mixing pool\n",
+    "mp = ss.MixingPool(beta=ss.beta(0.1), contacts=ss.poisson(lam=3)) # A single mixing pool\n",
+    "sir = ss.SIR() # Beta doesn't matter, that's just for networks\n",
+    "sim1 = ss.Sim(diseases=sir, networks=mp, verbose=0, label='Mixing Pool')\n",
+    "\n",
+    "# Transmission using a network\n",
+    "net = ss.RandomNet(n_contacts=ss.poisson(lam=3))\n",
+    "sir = ss.SIR(beta=ss.beta(0.1))\n",
+    "sim2 = ss.Sim(diseases=sir, networks=net, verbose=0, label='Contact Network')\n",
+    "\n",
+    "msim = ss.MultiSim([sim1, sim2]).run()\n",
+    "msim.plot()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "0bf06ad9",
+   "metadata": {},
+   "source": [
+    "Each MixingPool has several configuration parameters, including `src` and `dst`. The value of these parameters can either be an array of uids, like `ss.uids([0,1,2])` or a callable function that takes `sim` as an argument and returns an array of uids (or a BoolArr) like `lambda sim: sim.people.age<10`. One helper class we have created is called `AgeGroup`, which takes `low` and `high` ages as parameters. This class has some performance advantages when using multiple pools via `MixingPools` through caching.\n",
+    "\n",
+    "While mixing pools do not represent individual agent-to-agent connections, each agent does have an \"effective\" number of contacts, typically drawn from a Poisson distribution. Individuals retain their number of contacts within each pool for the duration of the simulation. Effective contacts are used on the acquisition sides. On the transmission side, the \"average\" infection level, called `trans`, against which susceptible agents are challenged is computed as:\n",
+    "```python\n",
+    "trans = np.mean(disease.infectious[self.src_uids] * disease.rel_trans[self.src_uids])\n",
+    "```\n",
+    "And on the acquisition side, each susceptible agent can be thought of as connected to `eff_contacts` average infectious agents, computed as:\n",
+    "```python\n",
+    "acq = self.eff_contacts[self.dst_uids] * disease.susceptible[self.dst_uids] * disease.rel_sus[self.dst_uids]\n",
+    "```\n",
+    "Ultimately, the acquisition probability for each susceptible agent in `dst_uids` is computed as\n",
+    "```python\n",
+    "p = self.pars.beta * trans * acq\n",
+    "```\n",
+    "\n",
+    "You can see the `beta` parameter here, which is another pool parameter and should use `ss.beta()` to automatically adjust for time units. Mixing pools do not currently use the `beta` parameters configured in individual disease modules."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "aa28b522",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "mp = ss.MixingPool(\n",
+    "    diseases = 'sir', # Use this pool only for SIR, not other diseases (HIV in this example)\n",
+    "    src = lambda sim: sim.people.age < 15, # Infection sources will be agents under age 15\n",
+    "    dst = ss.AgeGroup(low=15, high=None), # Here demonstrating the AgeGroup class, identical to lambda sim: sim.people.age >= 15\n",
+    "    contacts = ss.poisson(lam=2), # Contacts will be poisson distributed with a mean of 2\n",
+    "    beta = ss.beta(0.2), # And we set beta to 0.2, automatically adjusting for time units via the ss.beta wrapper\n",
+    ")\n",
+    "sim = ss.Sim(diseases=['sir', 'hiv'], networks=mp) # Two diseases, only \"sir\" will have transmission\n",
+    "sim.run()\n",
+    "sim.plot()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "8756491b",
+   "metadata": {},
+   "source": [
+    "`MixingPools` (plural) allows you to configure multiple individual `MixingPool` pools. This first example shows how to do age mixing. Like `MixingPool`, `MixingPools` also takes `src` and `dst`, however each of these parameters must be a dictionary with key specifying the name of each group and value as in the singlular mixing pool proving the uids by a callable function or list of uids."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "25a9ed2a",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "lows = np.arange(0, 80, 5)\n",
+    "groups = ss.ndict([ss.AgeGroup(low=low, high=low+5) for low in lows[:-1]])\n",
+    "groups.append(ss.AgeGroup(low=lows[-1], high=None)) # 80+\n",
+    "n_groups = len(groups)\n",
+    "\n",
+    "# Let's create a random contact matrix. If using contact matrices from Prem et al., put data here.\n",
+    "cm = np.random.random((n_groups, n_groups)) + 3*np.diag(np.random.rand(n_groups))\n",
+    "\n",
+    "print('The first axis (rows) of the contact matrix is the SOURCE group')\n",
+    "print('The second axis (columns) of the contact matrix is the DESTINATION group')\n",
+    "plt.imshow(cm)\n",
+    "\n",
+    "mps = ss.MixingPools(\n",
+    "    contacts = cm,\n",
+    "    beta = ss.beta(0.2),\n",
+    "    src = groups,\n",
+    "    dst = groups,\n",
+    ")\n",
+    "\n",
+    "# Track new infections by age using an Analyzer, you'll learn about these in a subsequent tutorial\n",
+    "class New_Infections_By_Age(ss.Analyzer):\n",
+    "    def __init__(self, bins, **kwargs):\n",
+    "        super().__init__(**kwargs)\n",
+    "        self.bins = bins\n",
+    "\n",
+    "    def init_post(self):\n",
+    "        super().init_post()\n",
+    "        self.new_cases = np.zeros((len(self), len(self.bins)-1))\n",
+    "\n",
+    "    def step(self):\n",
+    "        new_inf = self.sim.diseases.sir.ti_infected == self.ti\n",
+    "        if not new_inf.any(): return\n",
+    "        self.new_cases[self.ti, :] = np.histogram(self.sim.people.age[new_inf], bins=self.bins)[0]\n",
+    "\n",
+    "    def plot(self):\n",
+    "        fig, ax = plt.subplots()\n",
+    "        ax.set_prop_cycle('color', plt.cm.nipy_spectral(np.linspace(0, 1, len(self.bins))))\n",
+    "\n",
+    "        for i, (b1, b2) in enumerate(zip(self.bins[:-1], self.bins[1:])):\n",
+    "            ax.plot(self.timevec, self.new_cases[:,i], label=f'Age {b1}-{b2}')\n",
+    "        ax.legend(); ax.set_xlabel('Year'); ax.set_ylabel('New Infections')\n",
+    "\n",
+    "az = New_Infections_By_Age(np.concatenate([lows, [1000]]))\n",
+    "\n",
+    "sir = ss.SIR()\n",
+    "sim = ss.Sim(diseases=sir, networks=mps, analyzers=az, dur=5, dt=1/4, n_agents=1000, verbose=0)\n",
+    "sim.run()\n",
+    "sim.analyzers[0].plot()\n",
+    "print('↑ The default age distribution is uniform, so the 75+ group contains many more people than the other age groups, explaining the larger number of new infections.')"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "55650f48",
+   "metadata": {},
+   "source": [
+    "Mixing pools work well with properties other than age. Here's an example that mixes by socio-economic status (SES)."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "0263e430",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "from enum import IntEnum\n",
+    "class SES(IntEnum):\n",
+    "    LOW = 0\n",
+    "    MID = 1\n",
+    "    HIGH = 2\n",
+    "\n",
+    "# Create 5,000 people adding 50% LOW, 30% MID, and 20% HIGH SES\n",
+    "ses = ss.FloatArr('ses', default=ss.choice(a=[SES.LOW, SES.MID, SES.HIGH], p=[0.5, 0.3, 0.2]))\n",
+    "ppl = ss.People(n_agents=5_000, extra_states=ses)\n",
+    "\n",
+    "# Create the mixing pools, note that the contact matrix need not be symmetric\n",
+    "mps = ss.MixingPools(\n",
+    "    src = {s.name: lambda sim, s=s: ss.uids(sim.people.ses == s) for s in [SES.LOW, SES.MID, SES.HIGH]},\n",
+    "    dst = {s.name: lambda sim, s=s: ss.uids(sim.people.ses == s) for s in [SES.LOW, SES.MID]}, # People in the HIGH group have not route to acquire new infections, for demonstration purposes here\n",
+    "\n",
+    "    # src on rows (1st dimension), dst on cols (2nd dimension)\n",
+    "    contacts = np.array([\n",
+    "        [2.50, 0.00], # LOW->LOW,  LOW->MID\n",
+    "        [0.05, 1.75], # MID->LOW,  MID->MID\n",
+    "        [0.00, 0.15], # HIGH->LOW, HIGH->MID\n",
+    "    ]),\n",
+    "\n",
+    "    beta = ss.beta(0.2),\n",
+    ")\n",
+    "\n",
+    "# Create an analyzer to track results by SES group\n",
+    "class New_Infections_By_SES(ss.Analyzer):\n",
+    "    def init_results(self):\n",
+    "        self.new_cases = np.zeros((len(self), len(SES)))\n",
+    "\n",
+    "    def step(self):\n",
+    "        new_inf = self.sim.diseases.sir.ti_infected == self.ti\n",
+    "        if not new_inf.any():\n",
+    "            return\n",
+    "\n",
+    "        for ses in SES:\n",
+    "            self.new_cases[self.ti, ses] = np.count_nonzero(new_inf & (self.sim.people.ses==ses))\n",
+    "\n",
+    "az = New_Infections_By_SES()\n",
+    "\n",
+    "def seeding(self, sim, uids):\n",
+    "    p = np.zeros(len(uids))\n",
+    "    high_ses = ss.uids(sim.people.ses == SES.HIGH)\n",
+    "    p[high_ses] = 0.1 # Seed infections into 10% of SES HIGH\n",
+    "    return p\n",
+    "sir = ss.SIR(init_prev = ss.bernoulli(p=seeding)) # The probability of being selected as a seed is determined on a per-agent basis by the above 'seeding' function\n",
+    "\n",
+    "sim = ss.Sim(people=ppl, diseases=sir, networks=mps, analyzers=az, dt=1/12, dur=35, verbose=0)\n",
+    "sim.run()\n",
+    "\n",
+    "\n",
+    "fig, ax = plt.subplots()\n",
+    "new_cases = sim.analyzers[0].new_cases\n",
+    "for ses in [SES.LOW, SES.MID, SES.HIGH]:\n",
+    "    ax.plot(sim.results.timevec, new_cases[:,ses], label=ses.name)\n",
+    "ax.legend(); ax.set_xlabel('Year'); ax.set_ylabel('New Infections')\n",
+    "plt.show()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "2ed791af",
+   "metadata": {},
+   "source": [
+    "In the above figure, infections are seeded into the HIGH group at the beginning of the simulation, explaining the spike in new cases at that time. HIGH SES can only infect MID SES, so the MID (orange) wave follows. LOW SES can only become infected by MID SES in this example, so the blue wave follows. This example intentionally demonstrates the directional nature of mixing pools and includes strong mixing within groups and bottlenecks between groups to make the point."
+   ]
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "base",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.12.2"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 5
+}
diff --git a/pyproject.toml b/pyproject.toml
new file mode 100644
index 0000000..67d0850
--- /dev/null
+++ b/pyproject.toml
@@ -0,0 +1,63 @@
+[build-system]
+requires = ["setuptools", "setuptools-scm"]
+build-backend = "setuptools.build_meta"
+
+[project]
+name = "starsim"
+dynamic = ["version"]
+description = "A fast, flexible agent-based disease modeling framework"
+readme = "README.rst"
+requires-python = ">=3.8"
+license = {file = "LICENSE"}
+keywords = ["agent-based model", "simulation", "disease", "epidemiology"]
+
+authors = [
+  { name = "Starsim Development Team", email = "info@starsim.org" },
+  { name = "Cliff Kerr" },
+  { name = "Robyn Stuart" },
+  { name = "Romesh Abeysuriya" },
+  { name = "Paula Sanz-Leon" },
+  { name = "Jamie Cohen" },
+  { name = "Daniel Klein" }
+]
+
+classifiers = [
+  "Intended Audience :: Science/Research",
+  "License :: OSI Approved :: MIT License",
+  "Operating System :: OS Independent",
+  "Programming Language :: Python",
+  "Topic :: Software Development :: Libraries :: Python Modules",
+  "Development Status :: 5 - Production/Stable",
+  "Programming Language :: Python :: 3.10",
+  "Programming Language :: Python :: 3.11",
+  "Programming Language :: Python :: 3.12"
+]
+
+dependencies = [
+    "numpy>=1.24.0",
+    "pandas>=2.0.0",
+    "sciris>=3.2.0",
+    "numba",
+    "scipy",
+    "matplotlib",
+    "networkx",
+    "optuna"
+]
+
+[project.optional-dependencies]
+fastmath = ["intel-cmplr-lib-rt"]
+test = ["pytest>=7.3", "pytest-cov", "pytest-env", "pytest-xdist"]
+
+[project.urls]
+"Website" = "https://starsim.org"
+"Source" = "https://github.com/starsimhub/starsim/"
+
+[tool.setuptools.packages.find]
+where = ["."]
+include = ["starsim*"]
+
+[tool.setuptools.package-data]
+mypkg = ["*.ipynb", "*.rst", "*.csv"]
+
+[tool.setuptools.dynamic]
+version = {attr = "starsim.version.__version__"}
\ No newline at end of file
diff --git a/setup.py b/setup.py
index 4d4ae2f..d7b72bd 100644
--- a/setup.py
+++ b/setup.py
@@ -1,49 +1,7 @@
-import os
-import runpy
-from setuptools import setup, find_packages
+"""
+Legacy support; see pyproject.toml for current information
+"""
 
-# Get version
-cwd = os.path.abspath(os.path.dirname(__file__))
-versionpath = os.path.join(cwd, 'starsim', 'version.py')
-version = runpy.run_path(versionpath)['__version__']
+import setuptools
 
-# Get the documentation
-with open(os.path.join(cwd, 'README.rst'), "r") as f:
-    long_description = f.read()
-
-CLASSIFIERS = [
-    "Environment :: Console",
-    "Intended Audience :: Science/Research",
-    "License :: Other/Proprietary License",
-    "Operating System :: OS Independent",
-    "Programming Language :: Python",
-    "Topic :: Software Development :: Libraries :: Python Modules",
-    "Development Status :: 5 - Production/Stable",
-    "Programming Language :: Python :: 3.9",
-    "Programming Language :: Python :: 3.10",
-    "Programming Language :: Python :: 3.11",
-    "Programming Language :: Python :: 3.12",
-]
-
-setup(
-    name="starsim",
-    version=version,
-    author="Robyn Stuart, Cliff Kerr, Romesh Abeysuriya, Paula Sanz-Leon, Jamie Cohen, and Daniel Klein on behalf of the Starsim Collective",
-    description="Starsim",
-    long_description=long_description,
-    long_description_content_type="text/x-rst",
-    keywords=["agent-based model", "simulation", "disease", "epidemiology"],
-    platforms=["OS Independent"],
-    classifiers=CLASSIFIERS,
-    packages=find_packages(),
-    include_package_data=True,
-    install_requires=[ # NB: remember to update __init__.py if these requirements change
-        'numpy',
-        'scipy',
-        'pandas>=2.0.0',
-        'sciris>=3.1.6',
-        'matplotlib',
-        'numba',
-        'networkx',
-    ],
-)
+setuptools.setup()
\ No newline at end of file
diff --git a/starsim/__init__.py b/starsim/__init__.py
index 1e873df..6d055bc 100644
--- a/starsim/__init__.py
+++ b/starsim/__init__.py
@@ -1,12 +1,24 @@
+"""
+Import all Starsim modules
+"""
+
+# Start imports: version and settings
 from .version import __version__, __versiondate__, __license__
-from .settings      import *
+from .settings import dtypes, options
+
+# Optionally print the license
+if options.license:
+    print(__license__)
+
+# Finish imports
 from .utils         import *
+from .arrays        import *
+from .time          import *
 from .parameters    import *
 from .distributions import *
-from .states        import *
 from .people        import *
 from .modules       import *
-from .network       import *
+from .networks      import *
 from .results       import *
 from .demographics  import *
 from .products      import *
@@ -14,20 +26,18 @@ from .interventions import *
 from .demographics  import *
 from .disease       import *
 from .diseases      import *
+from .loop          import *
 from .sim           import *
 from .run           import *
+from .calibration   import *
 from .samples       import *
 
 # Assign the root folder
 import sciris as sc
 root = sc.thispath(__file__).parent
 
-# Import the version and print the license
-if options.verbose:
-    print(__license__)
-
-# Double-check key requirements -- should match setup.py
-reqs = ['sciris>=3.1.6', 'pandas>=2.0.0', 'scipy', 'numba', 'networkx']
+# Double-check key requirements -- should match pyproject.toml
+reqs = ['sciris>=3.2.0', 'pandas>=2.0.0']
 msg = f'The following dependencies for Starsim {__version__} were not met: <MISSING>.'
 sc.require(reqs, message=msg)
-del sc, reqs, msg # Don't keep this in the module
\ No newline at end of file
+del sc, reqs, msg # Don't keep this in the module
diff --git a/starsim/arrays.py b/starsim/arrays.py
new file mode 100644
index 0000000..7c8bc5c
--- /dev/null
+++ b/starsim/arrays.py
@@ -0,0 +1,551 @@
+"""
+Define array-handling classes, including agent states
+"""
+import numpy as np
+import sciris as sc
+import starsim as ss
+
+# Shorten these for performance
+ss_float = ss.dtypes.float
+ss_int   = ss.dtypes.int
+ss_bool  = ss.dtypes.bool
+type_def = {
+    ss_float: ('float', float, np.float64, np.float32),
+    ss_int: ('int', int, np.int64, np.int32),
+    ss_bool: ('bool', bool, np.bool_),
+}
+type_map = {v:k for k,vlist in type_def.items() for v in vlist} # Invert into a full dictionary
+
+__all__ = ['BaseArr', 'Arr', 'FloatArr', 'BoolArr', 'State', 'IndexArr', 'uids']
+
+
+class BaseArr(np.lib.mixins.NDArrayOperatorsMixin):
+    """
+    An object that acts exactly like a NumPy array, except stores the values in self.values.
+    """
+    def __init__(self, values, *args, **kwargs):
+        self.values = np.array(values, *args, **kwargs)
+        return
+
+    def __getattr__(self, attr):
+        """ Make it behave like a regular array mostly -- enables things like sum(), mean(), etc. """
+        if attr in ['__deepcopy__', '__getstate__', '__setstate__']:
+            return self.__getattribute__(attr)
+        else:
+            return object.__getattribute__(self, 'values').__getattribute__(attr) # Be explicit to avoid possible recurison
+
+    # Define more base methods
+    def __len__(self):   return self.values.__len__()
+    def __bool__(self):  return self.values.__bool__()
+    def __int__(self):   return self.values.__int__()
+    def __float__(self): return self.values.__float__()
+    def __contains__(self, key): return self.values.__contains__(key)
+
+    def convert(self, obj):
+        """ Check if an object is an array, and convert if so """
+        if isinstance(obj, np.ndarray):
+            return self.asnew(obj)
+        elif isinstance(obj, BaseArr):
+            return self.asnew(obj.values)
+        return obj
+
+    @staticmethod
+    def _arr(obj):
+        """ Helper function to efficiently extract values from a BaseArr, or return the original object """
+        if isinstance(obj, BaseArr):
+            return obj.values
+        return obj
+
+    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
+        """ To handle all numpy operations, e.g. arr1*arr2 """
+        # Convert all inputs to their .values if they are BaseArr, otherwise leave unchanged
+        inputs = [self._arr(x) for x in inputs]
+        kwargs = {k:self._arr(v) for k,v in kwargs.items()}
+        result = getattr(ufunc, method)(*inputs, **kwargs)
+
+        # If result is a tuple (e.g., for divmod or ufuncs that return multiple values), convert all results to BaseArr
+        if isinstance(result, tuple):
+            return tuple(self.convert(x) for x in result)
+
+        result = self.convert(result)
+        return result
+
+    def __iter__(self):
+        """ For iterating correctly, e.g. for sum() """
+        return iter(self.values)
+
+    def __getitem__(self, index):
+        """ For indexing and slicing, e.g. arr[inds] """
+        return self.values[index]
+
+    def __setitem__(self, index, value):
+        """ Assign values, e.g. arr1[inds] = arr2 """
+        self.values[index] = value
+
+    def __array__(self, *args, **kwargs):
+        """ To ensure isinstance(arr, BaseArr) passes when creating new instances """
+        return np.array(self.values, *args, **kwargs)
+
+    def __repr__(self):
+        return f"{self.__class__.__name__}({self.values})"
+
+    def disp(self):
+        """ Full display of object """
+        return sc.pr(self)
+
+    def asnew(self, values=None, cls=None, **kwargs):
+        """ Duplicate and copy (rather than link) data """
+        if cls is None: # Use the current class if none is provided
+            cls = self.__class__
+        new = object.__new__(cls) # Create a new Arr instance
+        new.__dict__ = self.__dict__.copy() # Copy pointers
+        new.__dict__.update(kwargs) # Update any keyword arguments provided # TODO: add validation?
+        if values is not None:
+            new.values = values # Replace data with new data
+        else:
+            new.values = sc.cp(new.values) # TODO: is this needed?
+        return new
+
+    def update(self, skip_none=True, overwrite=True, force=False, **kwargs):
+        """ Update the attributes, skipping None values and raising an error if extra keys are added """
+        if skip_none: # Remove None inputs
+            kwargs = {k:v for k,v in kwargs.items() if v is not None}
+        if not overwrite: # Don't overwrite non-None values
+            kwargs = {k:v for k,v in kwargs.items() if getattr(self, k, None) is None}
+        if not force: # Check if we'd be creating any new keys
+            kw_keys = set(kwargs.keys())
+            self_keys = set(self.__dict__.keys())
+            diff = kw_keys - self_keys
+            if diff:
+                errormsg = f'Invalid arguments to {self}: {diff}'
+                raise ValueError(errormsg)
+        self.__dict__.update(kwargs) # Actually perform the update
+        return self
+
+    def to_json(self):
+        """ Return a dictionary representation of the Arr """
+        out = dict(
+            classname = self.__class__.__name__,
+            values = sc.jsonify(self.values),
+        )
+        return out
+
+
+class Arr(BaseArr):
+    """
+    Store a state of the agents (e.g. age, infection status, etc.) as an array.
+
+    In practice, ``Arr`` objects can be used interchangeably with NumPy arrays.
+    They have two main data interfaces: ``Arr.raw`` contains the "raw", underlying
+    NumPy array of the data. ``Arr.values`` contains the "active" values, which
+    usually corresponds to agents who are alive.
+
+    By default, operations are performed on active agents only (specified by ``Arr.auids``,
+    which is a pointer to ``sim.people.auids``). For example, ``sim.people.age.mean()``
+    will only use the ages of active agents. Thus, ``sim.people.age.mean()``
+    is equal to ``sim.people.age.values.mean()``, not ``sim.people.age.raw.mean()``.
+
+    If indexing by an int or slice, ``Arr.values`` is used. If indexing by an
+    ``ss.uids`` object, ``Arr.raw`` is used. ``Arr`` objects can't be directly
+    indexed by a list or array of ints, as this would be ambiguous about whether
+    ``values`` or ``raw`` is intended. For example, if there are 1000 people in a
+    simulation and 100 of them have died, ``sim.people.age[999]`` will return
+    an ``IndexError`` (since ``sim.people.age[899]`` is the last active agent),
+    whereas ``sim.people.age[ss.uids(999)]`` is valid.
+
+    Args:
+        name (str): The name for the state (also used as the dictionary key, so should not have spaces etc.)
+        dtype (class): The dtype to use for this instance (if None, infer from value)
+        default (any): Specify default value for new agents. This can be
+        - A scalar with the same dtype (or castable to the same dtype) as the State
+        - A callable, with a single argument for the number of values to produce
+        - A ``ss.Dist`` instance
+        nan (any): the value to use to represent NaN (not a number); also used as the default value if not supplied
+        label (str): The human-readable name for the state
+        skip_init (bool): Whether to skip initialization with the People object (used for uid and slot states)
+        people (ss.People): Optionally specify an initialized People object, used to construct temporary Arr instances
+    """
+    def __init__(self, name=None, dtype=None, default=None, nan=None, label=None, skip_init=False, people=None):
+        # Set attributes
+        self.name = name
+        self.label = label or name
+        self.default = default
+        self.nan = nan
+        self.dtype = dtype
+        self.people = people # Used solely for accessing people.auids
+
+        if self.people is None:
+            # This Arr is being defined in advance (e.g., as a module state) and we want a bidirectional link
+            # with a People instance for dynamic growth. These properties will be initialized later when the
+            # People/Sim are initialized
+            self.len_used = 0
+            self.len_tot = 0
+            self.initialized = skip_init
+            self.raw = np.empty(0, dtype=dtype)
+        else:
+            # This Arr is a temporary object used for intermediate calculations when we want to index an array
+            # by UID (e.g., inside an update() method). We allow this state to reference an existing, initialized
+            # People object, but do not register it for dynamic growth
+            self.len_used = self.people.uid.len_used
+            self.len_tot = self.people.uid.len_tot
+            self.initialized = True
+            self.raw = np.full(self.len_tot, dtype=self.dtype, fill_value=self.nan)
+
+        return
+
+    def __repr__(self):
+        arr_str = np.array2string(self.values, max_line_width=200)
+        if self.name:
+            string = f'<{self.__class__.__name__} "{str(self.name)}", len={len(self)}, {arr_str}>'
+        else:
+            string = f'<{self.__class__.__name__}, len={len(self)}, {arr_str}>'
+        return string
+
+    def __len__(self):
+        return len(self.auids)
+
+    def _convert_key(self, key):
+        """
+        Used for getitem and setitem to determine whether the key is indexing
+        the raw array (``raw``) or the active agents (``values``), and to convert
+        the key to array indices if needed.
+        """
+        if isinstance(key, (uids, int, ss_int)):
+            return key
+        elif isinstance(key, (BoolArr, IndexArr)):
+            return key.uids
+        elif isinstance(key, slice):
+            return self.auids[key]
+        elif not np.isscalar(key) and len(key) == 0: # Handle [], np.array([]), etc.
+            return uids()
+        else:
+            errormsg = f'Indexing an Arr ({self.name}) by ({key}) is ambiguous or not supported. Use ss.uids() instead, or index Arr.raw or Arr.values.'
+            raise Exception(errormsg)
+
+    def __getitem__(self, key):
+        key = self._convert_key(key)
+        return self.raw[key]
+
+    def __setitem__(self, key, value):
+        key = self._convert_key(key)
+        self.raw[key] = value
+        return
+
+    def __gt__(self, other): return self.asnew(self.values > other,  cls=BoolArr)
+    def __lt__(self, other): return self.asnew(self.values < other,  cls=BoolArr)
+    def __ge__(self, other): return self.asnew(self.values >= other, cls=BoolArr)
+    def __le__(self, other): return self.asnew(self.values <= other, cls=BoolArr)
+    def __eq__(self, other): return self.asnew(self.values == other, cls=BoolArr)
+    def __ne__(self, other): return self.asnew(self.values != other, cls=BoolArr)
+
+    def __and__(self, other): raise BooleanOperationError(self)
+    def __or__(self, other):  raise BooleanOperationError(self)
+    def __xor__(self, other): raise BooleanOperationError(self)
+    def __invert__(self):     raise BooleanOperationError(self)
+
+    @property
+    def auids(self):
+        """ Link to the indices of active agents -- sim.people.auids """
+        try:
+            return self.people.auids
+        except:
+            if not self.initialized:
+                ss.warn('Trying to access non-initialized Arr object; in most cases, Arr objects need to be initialized with a Sim object, but set skip_init=True if this is intentional.')
+            return uids(np.arange(len(self.raw)))
+
+    def count(self):
+        return np.count_nonzero(self.values)
+
+    @property
+    def values(self):
+        """ Return the values of the active agents """
+        return self.raw[self.auids]
+
+    def set(self, uids, new_vals=None):
+        """ Set the values for the specified UIDs"""
+        if new_vals is None:
+            if isinstance(self.default, ss.Dist):
+                new_vals = self.default.rvs(uids)
+            elif callable(self.default):
+                new_vals = self.default(len(uids))
+            elif self.default is not None:
+                new_vals = self.default
+            else:
+                new_vals = self.nan
+        self.raw[uids] = new_vals
+        return new_vals
+
+    def set_nan(self, uids):
+        """ Shortcut function to set values to NaN """
+        self.raw[uids] = self.nan
+        return
+
+    @property
+    def isnan(self):
+        return self.asnew(self.values == self.nan, cls=BoolArr)
+
+    @property
+    def notnan(self):
+        return self.asnew(self.values != self.nan, cls=BoolArr)
+
+    def grow(self, new_uids=None, new_vals=None):
+        """
+        Add new agents to an Arr
+
+        This method is normally only called via `People.grow()`.
+
+        Args:
+            new_uids: Numpy array of UIDs for the new agents being added
+            new_vals: If provided, assign these state values to the new UIDs
+        """
+        orig_len = self.len_used
+        n_new = len(new_uids)
+        self.len_used += n_new  # Increase the count of the number of agents by `n` (the requested number of new agents)
+
+        # Physically reshape the arrays, if needed
+        if orig_len + n_new > self.len_tot:
+            n_grow = max(n_new, self.len_tot//2)  # Minimum 50% growth, since growing arrays is slow
+            new_empty = np.empty(n_grow, dtype=self.dtype) # 10x faster than np.zeros()
+            self.raw = np.concatenate([self.raw, new_empty], axis=0)
+            self.len_tot = len(self.raw)
+            if n_grow > n_new: # We added extra space at the end, set to NaN
+                nan_uids = np.arange(self.len_used, self.len_tot)
+                self.set_nan(nan_uids)
+
+        # Set new values, and NaN if needed
+        self.set(new_uids, new_vals=new_vals) # Assign new default values to those agents
+        return
+
+    def link_people(self, people):
+        """ Link a People object to this state, for access auids """
+        self.people = people # Link the people object to this state
+        people._link_state(self) # Ensure the state is linked to the People object as well
+        return
+
+    def init_vals(self):
+        """ Actually populate the initial values and mark as initialized; only to be used on initialization """
+        if self.initialized:
+            errormsg = f'Cannot re-initialize state {self}; use set() instead'
+            raise RuntimeError(errormsg)
+        self.grow(self.people.uid)
+        self.initialized = True
+        return
+
+    def asnew(self, arr=None, cls=None, name=None):
+        """ Duplicate and copy (rather than link) data, optionally resetting the array """
+        if cls is None:
+            cls = self.__class__
+        if arr is None:
+            arr = self.values
+        new = object.__new__(cls) # Create a new Arr instance
+        new.__dict__ = self.__dict__.copy() # Copy pointers
+        new.dtype = arr.dtype # Set to correct dtype
+        new.name = name # In most cases, the asnew Arr has different values to the original Arr so the original name no longer makes sense
+        new.raw = np.empty(new.raw.shape, dtype=new.dtype) # Copy values, breaking reference
+        new.raw[new.auids] = arr
+        return new
+
+    def true(self):
+        """ Efficiently convert truthy values to UIDs """
+        return self.auids[self.values.astype(bool)]
+
+    def false(self):
+        """ Reverse of true(); return UIDs of falsy values """
+        return self.auids[~self.values.astype(bool)]
+
+    def to_json(self):
+        """ Export to JSON """
+        out = dict(
+            classname = self.__class__.__name__,
+            name = self.name,
+            label = self.label,
+            default = self.default,
+            nan = self.nan,
+            dtype = self.dtype,
+            values = sc.jsonify(self.values),
+        )
+        return out
+
+
+class FloatArr(Arr):
+    """
+    Subclass of Arr with defaults for floats and ints.
+
+    Note: Starsim does not support integer arrays by default since they introduce
+    ambiguity in dealing with NaNs, and float arrays are suitable for most purposes.
+    If you really want an integer array, you can use the default Arr class instead.
+    """
+    def __init__(self, name=None, nan=np.nan, **kwargs):
+        super().__init__(name=name, dtype=ss_float, nan=nan, **kwargs)
+        return
+
+    @property
+    def isnan(self):
+        """ Return BoolArr for NaN values """
+        return self.asnew(np.isnan(self.values), cls=BoolArr)
+
+    @property
+    def notnan(self):
+        """ Return BoolArr for non-NaN values """
+        return self.asnew(~np.isnan(self.values), cls=BoolArr)
+
+    @property
+    def notnanvals(self):
+        """ Return values that are not-NaN """
+        vals = self.values # Shorten and avoid double indexing
+        out = vals[np.nonzero(~np.isnan(vals))[0]]
+        return out
+
+
+class BoolArr(Arr):
+    """ Subclass of Arr with defaults for booleans """
+    def __init__(self, name=None, nan=False, **kwargs): # No good NaN equivalent for bool arrays
+        super().__init__(name=name, dtype=ss_bool, nan=nan, **kwargs)
+        return
+
+    def __and__(self, other): return self.asnew(self.values & other)
+    def __or__(self, other):  return self.asnew(self.values | other)
+    def __xor__(self, other): return self.asnew(self.values ^ other)
+    def __invert__(self):     return self.asnew(~self.values)
+
+    # BoolArr cannot store NaNs so report all entries as being not-NaN
+    @property
+    def isnan(self):
+        return self.asnew(np.full_like(self.values, fill_value=False), cls=BoolArr)
+
+    @property
+    def notnan(self):
+        return self.asnew(np.full_like(self.values, fill_value=True), cls=BoolArr)
+
+    @property
+    def uids(self):
+        """ Alias to Arr.true """
+        return self.true()
+
+    def split(self):
+        """ Return UIDs of values that are true and false as separate arrays """
+        t_uids = self.true()
+        f_uids = self.false()
+        return t_uids, f_uids
+
+
+class State(BoolArr):
+    """
+    A boolean array being used as a state.
+
+    Although functionally identical to BoolArr, a State is handled differently in
+    terms of automation: specifically, results are automatically generated from a
+    State (but not a BoolArr).
+
+    States are typically used to keep track of externally-facing variables (e.g.
+    disease.susceptible), while BoolArrs can be used to keep track of internal
+    ones (e.g. disease.has_immunity).
+    """
+    pass
+
+
+class IndexArr(Arr):
+    """ A special class of Arr used for UIDs and RNG IDs; not to be used as an integer array (for that, use FloatArr) """
+    def __init__(self, name=None, label=None):
+        super().__init__(name=name, dtype=ss_int, default=None, nan=-1, label=label, skip_init=True)
+        self.raw = uids(self.raw)
+        return
+
+    @property
+    def uids(self):
+        """ Alias to self.values, to allow Arr.uids like BoolArr """
+        return self.values
+
+    def grow(self, new_uids=None, new_vals=None):
+        """ Change the size of the array """
+        if new_uids is None and new_vals is not None: # Used as a shortcut to avoid needing to supply twice
+            new_uids = new_vals
+        super().grow(new_uids=new_uids, new_vals=new_vals)
+        self.raw = uids(self.raw)
+        return
+
+
+class uids(np.ndarray):
+    """
+    Class to specify that integers should be interpreted as UIDs.
+
+    For all practical purposes, behaves like a NumPy integer array. However,
+    has additional methods ``uids.concat()`` (instance method), ``ss.uids.cat()``
+    (class method), ``uids.remove()``, and ``uids.intersect()`` to simplify common
+    UID operations.
+    """
+    def __new__(cls, arr=None):
+        if isinstance(arr, np.ndarray): # Shortcut to typical use case, where the input is an array
+            return arr.astype(ss_int).view(cls)
+        elif isinstance(arr, BoolArr): # Shortcut for arr.uids
+            return arr.uids
+        elif isinstance(arr, set):
+            return np.fromiter(arr, dtype=ss_int).view(cls)
+        elif arr is None: # Shortcut to return empty
+            return np.empty(0, dtype=ss_int).view(cls)
+        elif isinstance(arr, int): # Convert e.g. ss.uids(0) to ss.uids([0])
+            arr = [arr]
+        return np.asarray(arr, dtype=ss_int).view(cls) # Handle everything else
+
+    def concat(self, other, **kw): # Class and instance methods can't share a name
+        """ Equivalent to np.concatenate(), but return correct type """
+        return np.concatenate([self, other], **kw).view(self.__class__)
+
+    @classmethod
+    def cat(cls, *args, **kw):
+        """ Equivalent to np.concatenate(), but return correct type """
+        if len(args) == 0 or (len(args) == 1 and (args[0] is None or not len(args[0]))):
+            return uids()
+        arrs = args[0] if len(args) == 1 else args # TODO: handle one-array case
+        return np.concatenate(arrs, **kw).view(cls)
+
+    def remove(self, other, **kw):
+        """ Remove provided UIDs from current array"""
+        if isinstance(other, BoolArr):
+            other = other.uids
+        return np.setdiff1d(self, other, **kw).view(self.__class__)
+
+    def intersect(self, other, **kw):
+        """ Keep only UIDs that are also present in the other array """
+        if isinstance(other, BoolArr):
+            other = other.uids
+        return np.intersect1d(self, other, **kw).view(self.__class__)
+
+    def union(self, other, **kw):
+        """ Return all UIDs present in both arrays """
+        if isinstance(other, BoolArr):
+            other = other.uids
+        return np.union1d(self, other, **kw).view(self.__class__)
+
+    def xor(self, other, **kw):
+        """ Return UIDs present in only one of the arrays """
+        if isinstance(other, BoolArr):
+            other = other.uids
+        return np.setxor1d(self, other, **kw).view(self.__class__)
+
+    def to_numpy(self):
+        """ Return a view as a standard NumPy array """
+        return self.view(np.ndarray)
+
+    def unique(self, return_index=False):
+        """ Return unique UIDs; equivalent to np.unique() """
+        if return_index:
+            arr, index = np.unique(self, return_index=True)
+            return arr.view(self.__class__), index
+        else:
+            arr = np.unique(self).view(self.__class__)
+            return arr
+
+    # Implement collection of operators
+    def __and__(self, other): return self.intersect(other)
+    def __or__(self, other) : return self.union(other)
+    def __sub__(self, other): return self.remove(other)
+    def __xor__(self, other): return self.xor(other)
+    def __invert__(self)    : raise Exception(f"Cannot invert an instance of {self.__class__.__name__}. One possible cause is attempting `~x.uids` - use `x.false()` or `(~x).uids` instead")
+
+
+class BooleanOperationError(NotImplementedError):
+    """ Raised when a logical operation is performed on a non-logical array """
+    def __init__(self, arr):
+        msg = f'Logical operations are only valid on Boolean arrays, not {arr.dtype}'
+        super().__init__(msg)
diff --git a/starsim/calibration.py b/starsim/calibration.py
new file mode 100644
index 0000000..8c3a86d
--- /dev/null
+++ b/starsim/calibration.py
@@ -0,0 +1,573 @@
+"""
+Define the calibration class
+"""
+import os
+import numpy as np
+import pandas as pd
+import sciris as sc
+import optuna as op
+import matplotlib.pyplot as plt
+import starsim as ss
+
+
+__all__ = ['Calibration', 'compute_gof']
+
+
+def compute_gof(actual, predicted, normalize=True, use_frac=False, use_squared=False,
+                as_scalar='none', eps=1e-9, skestimator=None, estimator=None, **kwargs):
+    """
+    Calculate the goodness of fit. By default use normalized absolute error, but
+    highly customizable. For example, mean squared error is equivalent to
+    setting normalize=False, use_squared=True, as_scalar='mean'.
+
+    Args:
+        actual      (arr):   array of actual (data) points
+        predicted   (arr):   corresponding array of predicted (model) points
+        normalize   (bool):  whether to divide the values by the largest value in either series
+        use_frac    (bool):  convert to fractional mismatches rather than absolute
+        use_squared (bool):  square the mismatches
+        as_scalar   (str):   return as a scalar instead of a time series: choices are sum, mean, median
+        eps         (float): to avoid divide-by-zero
+        skestimator (str):   if provided, use this scikit-learn estimator instead
+        estimator   (func):  if provided, use this custom estimator instead
+        kwargs      (dict):  passed to the scikit-learn or custom estimator
+
+    Returns:
+        gofs (arr): array of goodness-of-fit values, or a single value if as_scalar is True
+
+    **Examples**::
+
+        x1 = np.cumsum(np.random.random(100))
+        x2 = np.cumsum(np.random.random(100))
+
+        e1 = compute_gof(x1, x2) # Default, normalized absolute error
+        e2 = compute_gof(x1, x2, normalize=False, use_frac=False) # Fractional error
+        e3 = compute_gof(x1, x2, normalize=False, use_squared=True, as_scalar='mean') # Mean squared error
+        e4 = compute_gof(x1, x2, skestimator='mean_squared_error') # Scikit-learn's MSE method
+        e5 = compute_gof(x1, x2, as_scalar='median') # Normalized median absolute error -- highly robust
+    """
+
+    # Handle inputs
+    actual    = np.array(sc.dcp(actual), dtype=float)
+    predicted = np.array(sc.dcp(predicted), dtype=float)
+
+    # Scikit-learn estimator is supplied: use that
+    if skestimator is not None: # pragma: no cover
+        try:
+            import sklearn.metrics as sm
+            sklearn_gof = getattr(sm, skestimator) # Shortcut to e.g. sklearn.metrics.max_error
+        except ImportError as E:
+            errormsg = f'You must have scikit-learn >=0.22.2 installed: {str(E)}'
+            raise ImportError(errormsg) from E
+        except AttributeError as E:
+            errormsg = f'Estimator {skestimator} is not available; see https://scikit-learn.org/stable/modules/model_evaluation.html#scoring-parameter for options'
+            raise AttributeError(errormsg) from E
+        gof = sklearn_gof(actual, predicted, **kwargs)
+        return gof
+
+    # Custom estimator is supplied: use that
+    if estimator is not None: # pragma: no cover
+        try:
+            gof = estimator(actual, predicted, **kwargs)
+        except Exception as E:
+            errormsg = f'Custom estimator "{estimator}" must be a callable function that accepts actual and predicted arrays, plus optional kwargs'
+            raise RuntimeError(errormsg) from E
+        return gof
+
+    # Default case: calculate it manually
+    else:
+        # Key step -- calculate the mismatch!
+        gofs = abs(np.array(actual) - np.array(predicted))
+
+        if normalize and not use_frac:
+            actual_max = abs(actual).max()
+            if actual_max > 0:
+                gofs /= actual_max
+
+        if use_frac:
+            if (actual<0).any() or (predicted<0).any():
+                print('Warning: Calculating fractional errors for non-positive quantities is ill-advised!')
+            else:
+                maxvals = np.maximum(actual, predicted) + eps
+                gofs /= maxvals
+
+        if use_squared:
+            gofs = gofs**2
+
+        if as_scalar == 'sum':
+            gofs = np.sum(gofs)
+        elif as_scalar == 'mean':
+            gofs = np.mean(gofs)
+        elif as_scalar == 'median':
+            gofs = np.median(gofs)
+
+        return gofs
+
+
+class Calibration(sc.prettyobj): # pragma: no cover
+    """
+    A class to handle calibration of Starsim simulations. Uses the Optuna hyperparameter
+    optimization library (optuna.org).
+
+    Args:
+        sim          (Sim)  : the simulation to calibrate
+        data         (df)   : pandas dataframe (or dataframe-compatible dict) of the data to calibrate to
+        calib_pars   (dict) : a dictionary of the parameters to calibrate of the format dict(key1=[best, low, high])
+        n_trials     (int)  : the number of trials per worker
+        n_workers    (int)  : the number of parallel workers (default: maximum number of available CPUs)
+        total_trials (int)  : if n_trials is not supplied, calculate by dividing this number by n_workers
+        reseed       (bool) : whether to generate new random seeds for each trial
+        weights      (dict) : the relative weights of each data source
+        fit_args     (dict) : a dictionary of options that are passed to sim.compute_fit() to calculate the goodness-of-fit
+        sep          (str)  : the separate between different types of results, e.g. 'hiv.deaths' vs 'hiv_deaths'
+        name         (str)  : the name of the database (default: 'starsim_calibration')
+        db_name      (str)  : the name of the database file (default: 'starsim_calibration.db')
+        keep_db      (bool) : whether to keep the database after calibration (default: false)
+        storage      (str)  : the location of the database (default: sqlite)
+        rand_seed    (int)  : if provided, use this random seed to initialize Optuna runs (for reproducibility)
+        label        (str)  : a label for this calibration object
+        die          (bool) : whether to stop if an exception is encountered (default: false)
+        debug        (bool) : if True, do not run in parallel
+        verbose      (bool) : whether to print details of the calibration
+
+    Returns:
+        A Calibration object
+    """
+    def __init__(self, sim, data, calib_pars, n_trials=None, n_workers=None, total_trials=None, reseed=True,
+                 weights=None, fit_args=None, sep='.', name=None, db_name=None, keep_db=None, storage=None,
+                 rand_seed=None, sampler=None, label=None, die=False, debug=False, verbose=True, save_results=False):
+
+        # Handle run arguments
+        if n_trials  is None: n_trials  = 20
+        if n_workers is None: n_workers = sc.cpu_count()
+        if name      is None: name      = 'starsim_calibration'
+        if db_name   is None: db_name   = f'{name}.db'
+        if keep_db   is None: keep_db   = False
+        if storage   is None: storage   = f'sqlite:///{db_name}'
+        if total_trials is not None: n_trials = int(np.ceil(total_trials/n_workers))
+        kw = dict(n_trials=int(n_trials), n_workers=int(n_workers), debug=debug, name=name, db_name=db_name,
+                  keep_db=keep_db, storage=storage, rand_seed=rand_seed, sampler=sampler)
+        self.run_args = sc.objdict(kw)
+
+        # Handle other inputs
+        self.label      = label
+        self.sim        = sim
+        self.calib_pars = calib_pars
+        self.reseed     = reseed
+        self.sep        = sep
+        self.weights    = sc.mergedicts(weights)
+        self.fit_args   = sc.mergedicts(fit_args)
+        self.die        = die
+        self.verbose    = verbose
+        self.save_results = save_results
+        self.calibrated = False
+        self.before_sim = None
+        self.after_sim  = None
+
+        # Load data -- this is expecting a dataframe with a column for 'time' and other columns for to sim results
+        self.data = ss.validate_sim_data(data, die=True)
+
+        # Temporarily store a filename
+        self.tmp_filename = 'tmp_calibration_%05i.obj'
+
+        # Initialize sim
+        if not self.sim.initialized:
+            self.sim.init()
+
+        # Figure out which sim results to get
+        self.sim_result_list = self.data.cols
+
+        return
+
+    def run_sim(self, calib_pars=None, label=None):
+        """ Create and run a simulation """
+        sim = sc.dcp(self.sim)
+        if label: sim.label = label
+
+        sim = self.translate_pars(sim, calib_pars=calib_pars)
+
+        # Run the sim
+        try:
+            sim.run()
+            return sim
+
+        except Exception as E:
+            if self.die:
+                raise E
+            else:
+                print(f'Encountered error running sim!\nParameters:\n{calib_pars}\nTraceback:\n{sc.traceback()}')
+                output = None
+                return output
+
+    @staticmethod
+    def translate_pars(sim=None, calib_pars=None):
+        """ Take the nested dict of calibration pars and modify the sim """
+
+        if 'rand_seed' in calib_pars:
+            sim.pars['rand_seed'] = calib_pars['rand_seed']
+
+        for parname, spec in calib_pars.items():
+            if parname == 'rand_seed':
+                continue
+
+            if 'path' not in spec:
+                raise ValueError(f'Cannot map {parname} because "path" is missing from the parameter configuration.')
+
+            p = spec['path']
+
+            if len(p) != 3:
+                raise ValueError(f'Cannot map {parname} because "path" must be a tuple of length 3.')
+
+            modtype = p[0]
+            dkey = p[1]
+            dparkey = p[2]
+            dparval = spec['value']
+            targetpar = sim[modtype][dkey].pars[dparkey]
+
+            if sc.isnumber(targetpar):
+                sim[modtype][dkey].pars[dparkey] = dparval
+            elif isinstance(targetpar, ss.Dist):
+                sim[modtype][dkey].pars[dparkey].set(dparval)
+            else:
+                errormsg = 'Type not implemented'
+                raise ValueError(errormsg)
+
+        return sim
+
+    def trial_to_sim_pars(self, pardict=None, trial=None):
+        """
+        Take in an optuna trial and sample from pars, after extracting them from the structure they're provided in
+
+        Different use cases:
+            - pardict is self.calib_pars, i.e. {'diseases':{'hiv':{'art_efficacy':[0.96, 0.9, 0.99]}}}, need to sample
+            - pardict is self.initial_pars, i.e. {'diseases':{'hiv':{'art_efficacy':[0.96, 0.9, 0.99]}}}, pull 1st vals
+            - pardict is self.best_pars, i.e. {'diseases':{'hiv':{'art_efficacy':0.96786}}}, pull single vals
+        """
+        pars = sc.dcp(pardict)
+        for parname, spec in pars.items():
+
+            if 'value' in spec:
+                # Already have a value, likely running initial or final values as part of checking the fit
+                continue
+
+            if 'sampler' in spec:
+                sampler = spec.pop('sampler')
+                sampler_fn = getattr(trial, sampler)
+            else:
+                sampler_fn = trial.suggest_float
+
+            path = spec.pop('path', None) # remove path
+            guess = spec.pop('guess', None) # remove guess
+            spec['value'] = sampler_fn(name=parname, **spec) # Sample!
+            spec['path'] = path
+            spec['guess'] = guess
+
+        return pars
+
+    @staticmethod
+    def sim_to_df(sim): # TODO: remove this method
+        """ Convert a sim to the expected dataframe type """
+        df_res = sim.to_df(sep='.')
+        df_res['t'] = df_res['timevec']
+        df_res = df_res.set_index('t')
+        df_res['time'] = np.floor(np.round(df_res.index, 1)).astype(int)
+        return df_res
+
+    def run_trial(self, trial):
+        """ Define the objective for Optuna """
+        if self.calib_pars is not None:
+            calib_pars = self.trial_to_sim_pars(self.calib_pars, trial)
+        else:
+            calib_pars = None
+
+        if self.reseed:
+            calib_pars['rand_seed'] = trial.suggest_int('rand_seed', 0, 1_000_000) # Choose a random rand_seed
+
+        sim = self.run_sim(calib_pars)
+
+        # Export results # TODO: make more robust
+        df_res = self.sim_to_df(sim)
+        sim_results = sc.objdict()
+
+        for skey in self.sim_result_list:
+            if 'prevalence' in skey or skey.startswith('n_'):
+                model_output = df_res.groupby(by='time')[skey].mean()
+            else:
+                model_output = df_res.groupby(by='time')[skey].sum()
+            sim_results[skey] = model_output.values
+
+        sim_results['time'] = model_output.index.values
+        # Store results in temporary files
+        if self.save_results:
+            filename = self.tmp_filename % trial.number
+            sc.save(filename, sim_results)
+
+        # Compute fit
+        fit = self.compute_fit(df_res=df_res)
+        return fit
+
+    def compute_fit(self, sim=None, df_res=None):
+        """ Compute goodness-of-fit """
+        fit = 0
+
+        # TODO: reduce duplication with above
+        if df_res is None:
+            df_res = self.sim_to_df(sim)
+        for skey in self.sim_result_list:
+            if 'prevalence' in skey or skey.startswith('n_'):
+                model_output = df_res.groupby(by='time')[skey].mean()
+            else:
+                model_output = df_res.groupby(by='time')[skey].sum()
+
+            data = self.data[skey]
+            combined = pd.merge(data, model_output, how='left', on='time')
+            combined['diffs'] = combined[skey+'_x'] - combined[skey+'_y']
+            gofs = compute_gof(combined.dropna()[skey+'_x'], combined.dropna()[skey+'_y'])
+
+            losses = gofs  #* self.weights[skey]
+            mismatch = losses.sum()
+            fit += mismatch
+
+        return fit
+
+    def worker(self):
+        """ Run a single worker """
+        if self.verbose:
+            op.logging.set_verbosity(op.logging.DEBUG)
+        else:
+            op.logging.set_verbosity(op.logging.ERROR)
+        study = op.load_study(storage=self.run_args.storage, study_name=self.run_args.name, sampler = self.run_args.sampler)
+        output = study.optimize(self.run_trial, n_trials=self.run_args.n_trials, callbacks=None)
+        return output
+
+    def run_workers(self):
+        """ Run multiple workers in parallel """
+        if self.run_args.n_workers > 1 and not self.run_args.debug: # Normal use case: run in parallel
+            output = sc.parallelize(self.worker, iterarg=self.run_args.n_workers)
+        else: # Special case: just run one
+            output = [self.worker()]
+        return output
+
+    def remove_db(self):
+        """ Remove the database file if keep_db is false and the path exists """
+        try:
+            if 'sqlite' in self.run_args.storage:
+                # Delete the file from disk
+                if os.path.exists(self.run_args.db_name):
+                    os.remove(self.run_args.db_name)
+                if self.verbose: print(f'Removed existing calibration file {self.run_args.db_name}')
+            else:
+                # Delete the study from the database e.g., mysql
+                op.delete_study(study_name=self.run_args.name, storage=self.run_args.storage)
+                if self.verbose: print(f'Deleted study {self.run_args.name} in {self.run_args.storage}')
+        except Exception as E:
+            if self.verbose:
+                print('Could not delete study, skipping...')
+                print(str(E))
+        return
+
+    def make_study(self):
+        """ Make a study, deleting one if it already exists """
+        if not self.run_args.keep_db:
+            self.remove_db()
+        if self.run_args.rand_seed is not None:
+            sampler = op.samplers.RandomSampler(self.run_args.rand_seed)
+            sampler.reseed_rng()
+            raise NotImplementedError('Implemented but does not work')
+        else:
+            sampler = None
+        if self.verbose: print(self.run_args.storage)
+        output = op.create_study(storage=self.run_args.storage, study_name=self.run_args.name, sampler=sampler)
+        return output
+
+    def calibrate(self, calib_pars=None, confirm_fit=False, load=False, tidyup=True, **kwargs):
+        """
+        Perform calibration.
+
+        Args:
+            calib_pars (dict): if supplied, overwrite stored calib_pars
+            confirm_fit (bool): if True, run simulations with parameters from before and after calibration
+            load (bool): whether to load existing trials from the database (if rerunning the same calibration)
+            tidyup (bool): whether to delete temporary files from trial runs
+            verbose (bool): whether to print output from each trial
+            kwargs (dict): if supplied, overwrite stored run_args (n_trials, n_workers, etc.)
+        """
+        # Load and validate calibration parameters
+        if calib_pars is not None:
+            self.calib_pars = calib_pars
+        self.run_args.update(kwargs) # Update optuna settings
+
+        # Run the optimization
+        t0 = sc.tic()
+        self.make_study()
+        self.run_workers()
+        study = op.load_study(storage=self.run_args.storage, study_name=self.run_args.name, sampler = self.run_args.sampler)
+        self.best_pars = sc.objdict(study.best_params)
+        self.elapsed = sc.toc(t0, output=True)
+
+        self.sim_results = []
+        if load:
+            if self.verbose: print('Loading saved results...')
+            for trial in study.trials:
+                n = trial.number
+                try:
+                    filename = self.tmp_filename % trial.number
+                    results = sc.load(filename)
+                    self.sim_results.append(results)
+                    if tidyup:
+                        try:
+                            os.remove(filename)
+                            if self.verbose: print(f'    Removed temporary file {filename}')
+                        except Exception as E:
+                            errormsg = f'Could not remove {filename}: {str(E)}'
+                            if self.verbose: print(errormsg)
+                    if self.verbose: print(f'  Loaded trial {n}')
+                except Exception as E:
+                    errormsg = f'Warning, could not load trial {n}: {str(E)}'
+                    if self.verbose: print(errormsg)
+
+        # Compare the results
+        self.parse_study(study)
+
+        if self.verbose: print('Best pars:', self.best_pars)
+
+        # Tidy up
+        self.calibrated = True
+        if not self.run_args.keep_db:
+            self.remove_db()
+
+        # Optionally compute the sims before and after the fit
+        if confirm_fit:
+            self.confirm_fit()
+
+        return self
+
+    def confirm_fit(self):
+        """ Run before and after simulations to validate the fit """
+
+        if self.verbose: print('\nConfirming fit...')
+
+        before_pars = sc.dcp(self.calib_pars)
+        for spec in before_pars.values():
+            spec['value'] = spec['guess'] # Use guess values
+
+        after_pars = sc.dcp(self.calib_pars)
+        for parname, spec in after_pars.items():
+            spec['value'] = self.best_pars[parname]
+
+        self.before_sim = self.run_sim(calib_pars=before_pars, label='Before calibration')
+        self.after_sim  = self.run_sim(calib_pars=after_pars, label='After calibration')
+        self.before_fit = self.compute_fit(self.before_sim)
+        self.after_fit  = self.compute_fit(self.after_sim)
+
+        # Add the data to the sims
+        for sim in [self.before_sim, self.after_sim]:
+            sim.init_data(self.data)
+
+        print(f'Fit with original pars: {self.before_fit:n}')
+        print(f'Fit with best-fit pars: {self.after_fit:n}')
+        if self.after_fit <= self.before_fit:
+            print('✓ Calibration improved fit')
+        else:
+            print('✗ Calibration did not improve fit, but this sometimes happens stochastically and is not necessarily an error')
+
+        return self.before_fit, self.after_fit
+
+    def parse_study(self, study):
+        """Parse the study into a data frame -- called automatically """
+        best = study.best_params
+        self.best_pars = best
+
+        if self.verbose: print('Making results structure...')
+        results = []
+        n_trials = len(study.trials)
+        failed_trials = []
+        for trial in study.trials:
+            data = {'index':trial.number, 'mismatch': trial.value}
+            for key,val in trial.params.items():
+                data[key] = val
+            if data['mismatch'] is None:
+                failed_trials.append(data['index'])
+            else:
+                results.append(data)
+        if self.verbose: print(f'Processed {n_trials} trials; {len(failed_trials)} failed')
+
+        keys = ['index', 'mismatch'] + list(best.keys())
+        data = sc.objdict().make(keys=keys, vals=[])
+        for i,r in enumerate(results):
+            for key in keys:
+                if key not in r:
+                    warnmsg = f'Key {key} is missing from trial {i}, replacing with default'
+                    print(warnmsg)
+                    r[key] = best[key]
+                data[key].append(r[key])
+        self.study_data = data
+        self.df = sc.dataframe.from_dict(data)
+        self.df = self.df.sort_values(by=['mismatch']) # Sort
+        return
+
+    def to_json(self, filename=None, indent=2, **kwargs):
+        """ Convert the results to JSON """
+        order = np.argsort(self.df['mismatch'])
+        json = []
+        for o in order:
+            row = self.df.iloc[o,:].to_dict()
+            rowdict = dict(index=row.pop('index'), mismatch=row.pop('mismatch'), pars={})
+            for key,val in row.items():
+                rowdict['pars'][key] = val
+            json.append(rowdict)
+        self.json = json
+        if filename:
+            return sc.savejson(filename, json, indent=indent, **kwargs)
+        else:
+            return json
+
+    def plot_sims(self, **kwargs):
+        """
+        Plot sims, before and after calibration.
+
+        Args:
+            kwargs (dict): passed to MultiSim.plot()
+        """
+        if self.before_sim is None:
+            self.confirm_fit()
+        msim = ss.MultiSim([self.before_sim, self.after_sim])
+        fig = msim.plot(**kwargs)
+        return ss.return_fig(fig)
+
+    def plot_trend(self, best_thresh=None, fig_kw=None):
+        """
+        Plot the trend in best mismatch over time.
+
+        Args:
+            best_thresh (int): Define the threshold for the "best" fits, relative to the lowest mismatch value (if None, show all)
+            fig_kw (dict): passed to plt.figure()
+        """
+        df = self.df.sort_values('index') # Make a copy of the dataframe, sorted by trial number
+        mismatch = sc.dcp(df['mismatch'].values)
+        best_mismatch = np.zeros(len(mismatch))
+        for i in range(len(mismatch)):
+            best_mismatch[i] = mismatch[:i+1].min()
+        smoothed_mismatch = sc.smooth(mismatch)
+        fig = plt.figure(**sc.mergedicts(fig_kw))
+
+        ax1 = plt.subplot(2,1,1)
+        plt.plot(mismatch, alpha=0.2, label='Original')
+        plt.plot(smoothed_mismatch, lw=3, label='Smoothed')
+        plt.plot(best_mismatch, lw=3, label='Best')
+
+        ax2 = plt.subplot(2,1,2)
+        max_mismatch = mismatch.min()*best_thresh if best_thresh is not None else np.inf
+        inds = sc.findinds(mismatch<=max_mismatch)
+        plt.plot(best_mismatch, lw=3, label='Best')
+        plt.scatter(inds, mismatch[inds], c=mismatch[inds], label='Trials')
+        for ax in [ax1, ax2]:
+            plt.sca(ax)
+            plt.grid(True)
+            plt.legend()
+            sc.setylim()
+            sc.setxlim()
+            plt.xlabel('Trial number')
+            plt.ylabel('Mismatch')
+        sc.figlayout()
+        return ss.return_fig(fig)
\ No newline at end of file
diff --git a/starsim/demographics.py b/starsim/demographics.py
index 56af1f8..fd981c0 100644
--- a/starsim/demographics.py
+++ b/starsim/demographics.py
@@ -1,12 +1,14 @@
 """
 Define pregnancy, deaths, migration, etc.
 """
-
 import numpy as np
 import starsim as ss
 import sciris as sc
 import pandas as pd
 
+ss_float_ = ss.dtypes.float
+ss_int_ = ss.dtypes.int
+
 __all__ = ['Demographics', 'Births', 'Deaths', 'Pregnancy']
 
 
@@ -16,35 +18,24 @@ class Demographics(ss.Module):
     place at the start of the timestep, before networks are updated and before
     any disease modules are executed.
     """
-    def init_pre(self, sim):
-        super().init_pre(sim)
-        self.init_results()
-        return
-
-    def init_results(self):
-        pass
-
-    def update(self):
-        pass
-
-    def update_results(self):
-        pass
+    pass
 
 
 class Births(Demographics):
     """ Create births based on rates, rather than based on pregnancy """
     def __init__(self, pars=None, metadata=None, **kwargs):
         super().__init__()
-        self.default_pars(
-            birth_rate = 30,
+        self.define_pars(
+            unit = 'year',
+            birth_rate = ss.peryear(20),
             rel_birth = 1,
-            units = 1e-3,  # assumes birth rates are per 1000. If using percentages, switch this to 1
+            rate_units = 1e-3,  # assumes birth rates are per 1000. If using percentages, switch this to 1
         )
         self.update_pars(pars, **kwargs)
 
         # Process metadata. Defaults here are the labels used by UN data
         self.metadata = sc.mergedicts(
-            sc.objdict(data_cols=dict(year='Year', cbr='CBR')),
+            sc.objdict(data_cols=dict(year='Year', value='CBR')),
             metadata,
         )
 
@@ -60,45 +51,56 @@ class Births(Demographics):
         if isinstance(self.pars.birth_rate, pd.DataFrame):
             br_year = self.pars.birth_rate[self.metadata.data_cols['year']]
             br_val = self.pars.birth_rate[self.metadata.data_cols['cbr']]
-            all_birth_rates = np.interp(sim.yearvec, br_year, br_val)
+            all_birth_rates = np.interp(self.timevec, br_year, br_val) # This assumes a year timestep -- probably ok?
             self.pars.birth_rate = all_birth_rates
         return
 
     def standardize_birth_data(self):
         """ Standardize/validate birth rates - handled in an external file due to shared functionality """
         birth_rate = ss.standardize_data(data=self.pars.birth_rate, metadata=self.metadata)
+        if isinstance(birth_rate, (pd.Series, pd.DataFrame)):
+            return birth_rate.xs(0,level='age')
         return birth_rate
 
     def init_results(self):
-        npts = self.sim.npts
-        self.results += [
-            ss.Result(self.name, 'new', npts, dtype=int, scale=True),
-            ss.Result(self.name, 'cumulative', npts, dtype=int, scale=True),
-            ss.Result(self.name, 'cbr', npts, dtype=int, scale=False),
-        ]
+        super().init_results()
+        self.define_results(
+            ss.Result('new',        dtype=int,   scale=True,  label='New births'),
+            ss.Result('cumulative', dtype=int,   scale=True,  label='Cumulative births'),
+            ss.Result('cbr',        dtype=float, scale=False, label='Crude birth rate'),
+        )
         return
 
-    def update(self):
-        new_uids = self.add_births()
-        self.n_births = len(new_uids)
-        return new_uids
-
     def get_births(self):
         """
         Extract the right birth rates to use and translate it into a number of people to add.
         """
         sim = self.sim
         p = self.pars
-        if sc.isnumber(p.birth_rate):
+
+        if isinstance(p.birth_rate, (pd.Series, pd.DataFrame)):
+            available_years = p.birth_rate.index
+            year_ind = sc.findnearest(available_years, sim.t.now('year'))
+            nearest_year = available_years[year_ind]
+            this_birth_rate = p.birth_rate.loc[nearest_year]
+        else:
             this_birth_rate = p.birth_rate
-        elif sc.checktype(p.birth_rate, 'arraylike'):
-            this_birth_rate = p.birth_rate[sim.ti]
 
-        scaled_birth_prob = this_birth_rate * p.units * p.rel_birth * sim.pars.dt
+        if isinstance(this_birth_rate, ss.TimePar):
+            factor = 1.0
+        else:
+            factor = ss.time_ratio(unit1=self.t.unit, dt1=self.t.dt, unit2='year', dt2=1.0)
+
+        scaled_birth_prob = this_birth_rate * p.rate_units * p.rel_birth * factor
         scaled_birth_prob = np.clip(scaled_birth_prob, a_min=0, a_max=1)
-        n_new = int(np.floor(sim.people.alive.count() * scaled_birth_prob))
+        n_new = int(sc.randround(sim.people.alive.count() * scaled_birth_prob))
         return n_new
 
+    def step(self):
+        new_uids = self.add_births()
+        self.n_births = len(new_uids)
+        return new_uids
+
     def add_births(self):
         """ Add n_new births to each state in the sim """
         people = self.sim.people
@@ -108,14 +110,19 @@ class Births(Demographics):
         return new_uids
 
     def update_results(self):
-        self.results['new'][self.sim.ti] = self.n_births
+        # New births -- already calculated
+        self.results.new[self.ti] = self.n_births
+
+        # Calculate crude birth rate (CBR)
+        inv_rate_units = 1.0/self.pars.rate_units
+        births_per_year = self.n_births/self.sim.t.dt_year
+        denom = self.sim.people.alive.sum()
+        self.results.cbr[self.ti] = inv_rate_units*births_per_year/denom
         return
 
     def finalize(self):
         super().finalize()
-        res = self.sim.results
-        self.results.cumulative = np.cumsum(self.results.new)
-        self.results.cbr = 1/self.pars.units*np.divide(self.results.new/self.sim.dt, res.n_alive, where=res.n_alive>0)
+        self.results.cumulative[:] = np.cumsum(self.results.new)
         return
 
 
@@ -142,17 +149,18 @@ class Deaths(Demographics):
             pars: dict with arguments including:
                 rel_death: constant used to scale all death rates
                 death_rate: float, dict, or pandas dataframe/series containing mortality data
-                units: units for death rates (see in-line comment on par dict below)
+                rate_units: units for death rates (see in-line comment on par dict below)
 
             metadata: data about the data contained within the data input.
                 "data_cols" is is a dictionary mapping standard keys, like "year" to the
                 corresponding column name in data. Similar for "sex_keys". Finally,
         """
         super().__init__()
-        self.default_pars(
+        self.define_pars(
+            unit = 'year',
             rel_death = 1,
-            death_rate = 20,  # Default = a fixed rate of 2%/year, overwritten if data provided
-            units = 1e-3,  # assumes death rates are per 1000. If using percentages, switch this to 1
+            death_rate = ss.peryear(20),  # Default = a fixed rate of 2%/year, overwritten if data provided
+            rate_units = 1e-3,  # assumes death rates are per 1000. If using percentages, switch this to 1
         )
         self.update_pars(pars, **kwargs)
 
@@ -160,7 +168,7 @@ class Deaths(Demographics):
         self.metadata = sc.mergedicts(
             sc.objdict(
                 data_cols = dict(year='Time', sex='Sex', age='AgeGrpStart', value='mx'),
-                sex_keys = dict(f='Female', m='Male'),
+                sex_keys = {'Female':'f', 'Male':'m'},
             ),
             metadata
         )
@@ -171,86 +179,86 @@ class Deaths(Demographics):
         self.pars.death_rate = ss.bernoulli(p=self.make_death_prob_fn)
         self.n_deaths = 0 # For results tracking
         return
-    
+
     def standardize_death_data(self):
         """ Standardize/validate death rates - handled in an external file due to shared functionality """
         death_rate = ss.standardize_data(data=self.pars.death_rate, metadata=self.metadata)
+        if isinstance(death_rate, (pd.Series, pd.DataFrame)):
+            death_rate = death_rate.unstack(level='age')
+            assert not death_rate.isna().any(axis=None) # For efficiency, we assume that the age bins are the same for all years in the input dataset
         return death_rate
 
     @staticmethod # Needs to be static since called externally, although it sure looks like a class method!
     def make_death_prob_fn(self, sim, uids):
         """ Take in the module, sim, and uids, and return the probability of death for each UID on this timestep """
-
         drd = self.death_rate_data
-        if sc.isnumber(drd) or isinstance(drd, ss.Dist):
+        if sc.isnumber(drd) or isinstance(drd, ss.TimePar):
             death_rate = drd
 
+        # Process data
         else:
             ppl = sim.people
-            data_cols = sc.objdict(self.metadata.data_cols)
-            year_label = data_cols.year
-            age_label  = data_cols.age
-            sex_label  = data_cols.sex
-            val_label  = data_cols.value
-            sex_keys = self.metadata.sex_keys
 
-            available_years = self.death_rate_data[year_label].unique()
-            year_ind = sc.findnearest(available_years, sim.year)
+            # Performance optimization - the Deaths module checks for deaths for all agents
+            # Therefore the UIDs requested should match all UIDs
+            assert len(uids) == len(ppl.auids)
+
+            available_years = drd.index.get_level_values('year')
+            year_ind = sc.findnearest(available_years, sim.t.now('year')) # TODO: make work with different timesteps
             nearest_year = available_years[year_ind]
 
-            df = self.death_rate_data.loc[self.death_rate_data[year_label] == nearest_year]
-            age_bins = df[age_label].unique()
+            death_rate = np.empty(uids.shape, dtype=ss_float_)
 
-            f_arr = df[val_label].loc[df[sex_label] == sex_keys['f']].values
-            m_arr = df[val_label].loc[df[sex_label] == sex_keys['m']].values
-
-            # Initialize
-            death_rate_df = pd.Series(index=uids)
-            f_uids = uids.intersect(ppl.female.uids) # TODO: reduce duplication
-            m_uids = uids.intersect(ppl.male.uids)
-            f_age_inds = np.digitize(ppl.age[f_uids], age_bins) - 1
-            m_age_inds = np.digitize(ppl.age[m_uids], age_bins) - 1
-            death_rate_df[f_uids] = f_arr[f_age_inds]
-            death_rate_df[m_uids] = m_arr[m_age_inds]
-            unborn_inds = uids.intersect((sim.people.age < 0).uids)
-            death_rate_df[unborn_inds] = 0  # Don't use background death rates for unborn babies
-
-            death_rate = death_rate_df.values
+            if 'sex' in drd.index.names:
+                s = drd.loc[nearest_year, 'f']
+                binned_ages = np.digitize(ppl.age[ppl.female], s.index)-1 # Negative ages will be in the first bin - do *not* subtract 1 so that this bin is 0
+                death_rate[ppl.female] = s.values[binned_ages]
+                s = drd.loc[nearest_year, 'm']
+                binned_ages = np.digitize(ppl.age[ppl.male], s.index)-1 # Negative ages will be in the first bin - do *not* subtract 1 so that this bin is 0
+                death_rate[ppl.male] = s.values[binned_ages]
+            else:
+                s = drd.loc[nearest_year]
+                binned_ages = np.digitize(ppl.age, s.index)-1 # Negative ages will be in the first bin - do *not* subtract 1 so that this bin is 0
+                death_rate[:] = s.values[binned_ages]
 
         # Scale from rate to probability. Consider an exponential here.
-        death_prob = death_rate * (self.pars.units * self.pars.rel_death * sim.pars.dt)
+        if isinstance(death_rate, ss.TimePar):
+            factor = self.t.dt # TODO: figure out why this isn't 1.0
+        else:
+            factor = ss.time_ratio(unit1=self.t.unit, dt1=self.t.dt, unit2='year', dt2=1.0)
+        death_prob = death_rate * self.pars.rate_units * self.pars.rel_death * factor
         death_prob = np.clip(death_prob, a_min=0, a_max=1)
 
         return death_prob
 
     def init_results(self):
-        npts = self.sim.npts
-        self.results += [
-            ss.Result(self.name, 'new', npts, dtype=int, scale=True),
-            ss.Result(self.name, 'cumulative', npts, dtype=int, scale=True),
-            ss.Result(self.name, 'cmr', npts, dtype=int, scale=False),
-        ]
+        super().init_results()
+        self.define_results(
+            ss.Result('new',        dtype=int,   scale=True,  label='Deaths', auto_plot=False), # Use sim deaths instead
+            ss.Result('cumulative', dtype=int,   scale=True,  label='Cumulative deaths', auto_plot=False),
+            ss.Result('cmr',        dtype=float, scale=False, label='Crude mortality rate'),
+        )
         return
 
-    def update(self):
-        self.n_deaths = self.apply_deaths()
-        return
-
-    def apply_deaths(self):
+    def step(self):
         """ Select people to die """
         death_uids = self.pars.death_rate.filter()
         self.sim.people.request_death(death_uids)
-        return len(death_uids)
+        self.n_deaths = len(death_uids)
+        return self.n_deaths
 
     def update_results(self):
-        self.results['new'][self.sim.ti] = self.n_deaths
+        self.results['new'][self.ti] = self.n_deaths
         return
 
     def finalize(self):
         super().finalize()
-        n_alive = self.sim.results.n_alive
-        self.results.cumulative = np.cumsum(self.results.new)
-        self.results.cmr = 1/self.pars.units*np.divide(self.results.new / self.sim.dt, n_alive, where=n_alive>0)
+        self.results.cumulative[:] = np.cumsum(self.results.new)
+        units = self.pars.rate_units*self.sim.t.dt_year
+        inds = self.match_time_inds()
+        n_alive = self.sim.results.n_alive[inds]
+        deaths = np.divide(self.results.new, n_alive, where=n_alive>0)
+        self.results.cmr[:] = deaths/units
         return
 
 
@@ -258,30 +266,37 @@ class Pregnancy(Demographics):
     """ Create births via pregnancies """
     def __init__(self, pars=None, metadata=None, **kwargs):
         super().__init__()
-        self.default_pars(
-            dur_pregnancy = 0.75,   # Duration for pre-natal transmission
-            dur_postpartum = ss.lognorm_ex(0.5, 0.5),   # Duration for post-natal transmission (e.g. via breastfeeding)
-            fertility_rate = 0,     # See make_fertility_prob_function
+        self.define_pars(
+            unit = 'year',
+            dur_pregnancy = ss.years(0.75), # Duration for pre-natal transmission
+            dur_postpartum = ss.lognorm_ex(mean=ss.years(0.5), std=ss.years(0.5)), # Duration for post-natal transmission (e.g. via breastfeeding)
+            fertility_rate = 0, # Can be a number of Pandas DataFrame
             rel_fertility = 1,
-            maternal_death_prob = ss.bernoulli(0),
+            p_maternal_death = ss.bernoulli(0),
+            p_neonatal_death = ss.bernoulli(0),
             sex_ratio = ss.bernoulli(0.5), # Ratio of babies born female
             min_age = 15, # Minimum age to become pregnant
             max_age = 50, # Maximum age to become pregnant
-            units = 1e-3, # Assumes fertility rates are per 1000. If using percentages, switch this to 1
+            rate_units = 1e-3, # Assumes fertility rates are per 1000. If using percentages, switch this to 1
+            burnin = True, # Should we seed pregnancies that would have happened before the start of the simulation?
+            slot_scale = 5, # Random slots will be assigned to newborn agents between min=n_agents and max=slot_scale*n_agents
+            min_slots  = 100, # Minimum number of slots, useful if the population size is very small
         )
         self.update_pars(pars, **kwargs)
-        
+
+        self.pars.p_fertility = ss.bernoulli(p=0) # Placeholder, see make_fertility_prob_fn
+
         # Other, e.g. postpartum, on contraception...
-        self.add_states(
-            ss.BoolArr('infertile'),  # Applies to girls and women outside the fertility window
-            ss.BoolArr('fecund', default=True),  # Applies to girls and women inside the fertility window
-            ss.BoolArr('pregnant'),  # Currently pregnant
-            ss.BoolArr('postpartum'),  # Currently post-partum
-            ss.FloatArr('dur_postpartum'),  # Duration of postpartum phase
-            ss.FloatArr('ti_pregnant'),  # Time pregnancy begins
-            ss.FloatArr('ti_delivery'),  # Time of delivery
-            ss.FloatArr('ti_postpartum'),  # Time postpartum ends
-            ss.FloatArr('ti_dead'),  # Maternal mortality
+        self.define_states(
+            ss.State('fecund', default=True, label='Female of childbearing age'),
+            ss.State('pregnant', label='Pregnant'),  # Currently pregnant
+            ss.State('postpartum', label="Post-partum"),  # Currently post-partum
+            ss.FloatArr('child_uid', label='UID of children, from embryo through postpartum'),
+            ss.FloatArr('dur_postpartum', label='Post-partum duration'),  # Duration of postpartum phase
+            ss.FloatArr('ti_pregnant', label='Time of pregnancy'),  # Time pregnancy begins
+            ss.FloatArr('ti_delivery', label='Time of delivery'),  # Time of delivery
+            ss.FloatArr('ti_postpartum', label='Time post-partum ends'),  # Time postpartum ends
+            ss.FloatArr('ti_dead', label='Time of maternal death'),  # Maternal mortality
         )
 
         # Process metadata. Defaults here are the labels used by UN data
@@ -289,12 +304,7 @@ class Pregnancy(Demographics):
             sc.objdict(data_cols=dict(year='Time', age='AgeGrp', value='ASFR')),
             metadata,
         )
-        self.choose_slots = None # Distribution for choosing slots; set in self.initialize()
-
-        # Process data, which may be provided as a number, dict, dataframe, or series
-        # If it's a number it's left as-is; otherwise it's converted to a dataframe
-        self.fertility_rate_data = self.standardize_fertility_data()
-        self.pars.fertility_rate = ss.bernoulli(self.make_fertility_prob_fn)
+        self.choose_slots = None # Distribution for choosing slots; set in self.init()
 
         # For results tracking
         self.n_pregnancies = 0
@@ -305,64 +315,75 @@ class Pregnancy(Demographics):
     def make_fertility_prob_fn(self, sim, uids):
         """ Take in the module, sim, and uids, and return the conception probability for each UID on this timestep """
 
-        if sc.isnumber(self.fertility_rate_data):
-            fertility_rate = pd.Series(index=uids, data=self.fertility_rate_data)
+        age = sim.people.age[uids]
 
+        frd = self.fertility_rate_data
+        fertility_rate = np.zeros(len(sim.people.uid.raw), dtype=ss_float_)
+
+        time_factor = ss.time_ratio(unit1=self.t.unit, dt1=self.t.dt, unit2='year', dt2=1.0)
+        if sc.isnumber(frd):
+            fertility_rate[uids] = self.fertility_rate_data
+            if isinstance(frd, ss.TimePar):
+                time_factor = 1 # Time conversion performed automatically by TimePar
         else:
-            # Abbreviate key variables
-            data_cols = sc.objdict(self.metadata.data_cols)
-            year_label = data_cols.year
-            age_label  = data_cols.age
-            val_label  = data_cols.value
+            year_ind = sc.findnearest(frd.index, self.t.now('year')-self.pars.dur_pregnancy.to('year')) # TODO: make time-unit-aware
+            nearest_year = frd.index[year_ind]
 
-            available_years = self.fertility_rate_data[year_label].unique()
-            year_ind = sc.findnearest(available_years, sim.year-self.pars.dur_pregnancy)
-            nearest_year = available_years[year_ind]
+            # Assign agents to age bins
+            age_bins = self.fertility_rate_data.columns.values
+            age_bin_all = np.digitize(age, age_bins) - 1
+            new_rate = self.fertility_rate_data.loc[nearest_year].values.copy()  # Initialize array with new rates
 
-            df = self.fertility_rate_data.loc[self.fertility_rate_data[year_label] == nearest_year]
-            df_arr = df[val_label].values  # Pull out dataframe values
-            df_arr = np.append(df_arr, 0)  # Add zeros for those outside data range
+            if (~self.fecund).any():
+                # Scale the new rate to convert the denominator from all women to fecund women
+                v, c = np.unique(age_bin_all, return_counts=True)
+                age_counts = np.zeros(len(age_bins))
+                age_counts[v] = c
 
-            # Process age data
-            age_bins = df[age_label].unique()
-            age_bins = np.append(age_bins, age_bins[-1]+1) # WARNING: Assumes one year age bins! TODO: More robust handling.
-            age_inds = np.digitize(sim.people.age[uids], age_bins) - 1
-            age_inds[age_inds == len(age_bins)-1] = -1  # This ensures women outside the data range will get a value of 0
+                age_bin_infecund = np.digitize(sim.people.age[~self.fecund], age_bins) - 1
+                v, c = np.unique(age_bin_infecund, return_counts=True)
+                infecund_age_counts = np.zeros(len(age_bins))
+                infecund_age_counts[v] = c
 
-            # Adjust rates: rates are based on the entire population, but we need to remove
-            # anyone already pregnant and then inflate the rates for the remainder
-            pregnant_uids = self.pregnant.uids # Find agents who are already pregnant
-            pregnant_age_counts, _ = np.histogram(sim.people.age[pregnant_uids], age_bins)  # Count them by age
-            age_counts, _ = np.histogram(sim.people.age[uids], age_bins)  # Count overall number per age bin
-            new_denom = age_counts - pregnant_age_counts  # New denominator for rates
-            num_to_make = df_arr[:-1]*age_counts  # Number that we need to make pregnant
-            new_percent = sc.dcp(df_arr)  # Initialize array with new rates
-            inds_to_rescale = new_denom > 0  # Rescale any non-zero age bins
-            new_percent[:-1][inds_to_rescale] = num_to_make[inds_to_rescale] / new_denom[inds_to_rescale]  # New rates
+                num_to_make = new_rate * age_counts  # Number that we need to make pregnant
+                new_denom = age_counts - infecund_age_counts  # New denominator for rates
+                np.divide(num_to_make, new_denom, where=new_denom>0, out=new_rate)
 
-            # Make array of fertility rates
-            fertility_rate = pd.Series(index=uids)
-            fertility_rate[uids] = new_percent[age_inds]
+            fertility_rate[uids] = new_rate[age_bin_all]
 
         # Scale from rate to probability
-        age = self.sim.people.age[uids]
         invalid_age = (age < self.pars.min_age) | (age > self.pars.max_age)
-        fertility_prob = fertility_rate * (self.pars.units * self.pars.rel_fertility * sim.pars.dt)
-        fertility_prob[self.pregnant.uids] = 0 # Currently pregnant women cannot become pregnant again
+        fertility_prob = fertility_rate * (self.pars.rate_units * self.pars.rel_fertility) * time_factor
+        fertility_prob[(~self.fecund).uids] = 0 # Currently infecund women cannot become pregnant
         fertility_prob[uids[invalid_age]] = 0 # Women too young or old cannot become pregnant
-        fertility_prob = np.clip(fertility_prob, a_min=0, a_max=1)
-
+        fertility_prob = np.clip(fertility_prob[uids], a_min=0, a_max=1)
         return fertility_prob
 
     def standardize_fertility_data(self):
-        """ Standardize/validate fertility rates - handled in an external file due to shared functionality """
+        """
+        Standardize/validate fertility rates
+        """
         fertility_rate = ss.standardize_data(data=self.pars.fertility_rate, metadata=self.metadata)
+        if isinstance(fertility_rate, (pd.Series, pd.DataFrame)):
+            fertility_rate = fertility_rate.unstack()
+            # Interpolate to 1 year increments
+            fertility_rate = fertility_rate.reindex(np.arange(fertility_rate.index.min(), fertility_rate.index.max() + 1)).interpolate()
+            max_age = fertility_rate.columns.max()
+            fertility_rate[max_age + 1] = 0
+            assert not fertility_rate.isna().any(axis=None) # For efficiency, we assume that the age bins are the same for all years in the input dataset
         return fertility_rate
 
     def init_pre(self, sim):
         super().init_pre(sim)
+
+        # Process data, which may be provided as a number, dict, dataframe, or series
+        # If it's a number it's left as-is; otherwise it's converted to a dataframe
+        self.fertility_rate_data = self.standardize_fertility_data()
+        self.pars.p_fertility.set(p=self.make_fertility_prob_fn)
+
         low = sim.pars.n_agents + 1
-        high = int(sim.pars.slot_scale*sim.pars.n_agents)
+        high = int(self.pars.slot_scale*sim.pars.n_agents)
+        high = np.maximum(high, self.pars.min_slots) # Make sure there are at least min_slots slots to avoid artifacts related to small populations
         self.choose_slots = ss.randint(low=low, high=high, sim=sim, module=self)
         return
 
@@ -372,26 +393,36 @@ class Pregnancy(Demographics):
         Still unclear whether this logic should live in the pregnancy module, the
         individual disease modules, the connectors, or the sim.
         """
-        npts = self.sim.npts
-        self.results += [
-            ss.Result(self.name, 'pregnancies', npts, dtype=int, scale=True),
-            ss.Result(self.name, 'births', npts, dtype=int, scale=True),
-            ss.Result(self.name, 'cbr', npts, dtype=int, scale=False),
-        ]
+        super().init_results()
+        self.define_results(
+            ss.Result('pregnancies', dtype=int,   scale=True,  label='New pregnancies'),
+            ss.Result('births',      dtype=int,   scale=True,  label='New births'),
+            ss.Result('cbr',         dtype=float, scale=False, label='Crude birth rate'),
+        )
         return
 
-    def update(self):
+    def step(self):
+        if self.ti == 0 and self.pars.burnin: # TODO: refactor
+            dtis = np.arange(np.ceil(-1 * self.pars.dur_pregnancy), 0, 1).astype(int)
+            for dti in dtis:
+                self.t.ti = dti
+                self.do_step()
+            self.t.ti = 0
+        new_uids = self.do_step()
+        return new_uids
+
+    def do_step(self):
         """ Perform all updates """
         self.update_states()
         conceive_uids = self.make_pregnancies()
-        self.n_pregnancies = len(conceive_uids)
-        self.make_embryos(conceive_uids)
-        return
+        self.n_pregnancies += len(conceive_uids) # += to handle burn-in
+        new_uids = self.make_embryos(conceive_uids)
+        return new_uids
 
     def update_states(self):
         """ Update states """
         # Check for new deliveries
-        ti = self.sim.ti
+        ti = self.ti
         deliveries = self.pregnant & (self.ti_delivery <= ti)
         self.n_births = np.count_nonzero(deliveries)
         self.pregnant[deliveries] = False
@@ -407,27 +438,28 @@ class Pregnancy(Demographics):
                 prenatalnet = [nw for nw in self.sim.networks.values() if nw.prenatal][0]
 
                 # Find the prenatal connections that are ending
-                prenatal_ending = prenatalnet.edges.end<=self.sim.ti
+                prenatal_ending = prenatalnet.edges.end <= ti
                 new_mother_uids = prenatalnet.edges.p1[prenatal_ending]
                 new_infant_uids = prenatalnet.edges.p2[prenatal_ending]
 
                 # Validation
-                if not np.array_equal(new_mother_uids, deliveries.uids):
-                    errormsg = f'IDs of new mothers do not match IDs of new deliveries.'
+                if not set(new_mother_uids) == set(deliveries.uids): # Not sure why sometimes out of order
+                    errormsg = 'IDs of new mothers do not match IDs of new deliveries'
                     raise ValueError(errormsg)
 
                 # Create durations and start dates, and add connections
                 durs = self.dur_postpartum[new_mother_uids]
-                start = np.full(self.n_births, fill_value=self.sim.ti)
+                start = np.full(self.n_births, fill_value=ti)
 
                 # # Remove pairs from prenatal network and add to postnatal
                 prenatalnet.end_pairs()
                 layer.add_pairs(new_mother_uids, new_infant_uids, dur=durs, start=start)
 
         # Check for new women emerging from post-partum
-        postpartum = ~self.pregnant & (self.ti_postpartum <= ti)
+        postpartum = self.postpartum & (self.ti_postpartum <= ti)
         self.postpartum[postpartum] = False
         self.fecund[postpartum] = True
+        self.child_uid[postpartum] = np.nan
 
         # Maternal deaths
         maternal_deaths = (self.ti_dead <= ti).uids
@@ -439,17 +471,19 @@ class Pregnancy(Demographics):
         # People eligible to become pregnant. We don't remove pregnant people here, these
         # are instead handled in the fertility_dist logic as the rates need to be adjusted
         eligible_uids = self.sim.people.female.uids
-        conceive_uids = self.pars.fertility_rate.filter(eligible_uids)
+        conceive_uids = self.pars.p_fertility.filter(eligible_uids)
+
+        if len(conceive_uids) == 0:
+            return ss.uids()
 
         # Validation
         if np.any(self.pregnant[conceive_uids]):
             which_uids = conceive_uids[self.pregnant[conceive_uids]]
-            errormsg = f'New conceptions registered in {len(which_uids)} pregnant agent(s) at timestep {self.sim.ti}.'
+            errormsg = f'New conceptions registered in {len(which_uids)} pregnant agent(s) at timestep {self.ti}.'
             raise ValueError(errormsg)
 
         # Set prognoses for the pregnancies
-        if len(conceive_uids) > 0:
-            self.set_prognoses(conceive_uids)
+        self.set_prognoses(conceive_uids)
         return conceive_uids
 
     def make_embryos(self, conceive_uids):
@@ -465,17 +499,22 @@ class Pregnancy(Demographics):
 
             # Grow the arrays and set properties for the unborn agents
             new_uids = people.grow(len(new_slots), new_slots)
-            people.age[new_uids] = -self.pars.dur_pregnancy
+            people.age[new_uids] = -self.pars.dur_pregnancy.to('year')
             people.slot[new_uids] = new_slots  # Before sampling female_dist
             people.female[new_uids] = self.pars.sex_ratio.rvs(conceive_uids)
+            people.parent[new_uids] = conceive_uids
+            self.child_uid[conceive_uids] = new_uids
 
             # Add connections to any prenatal transmission layers
             for lkey, layer in self.sim.networks.items():
                 if layer.prenatal:
                     durs = np.full(n_unborn, fill_value=self.pars.dur_pregnancy)
-                    start = np.full(n_unborn, fill_value=self.sim.ti)
+                    start = np.full(n_unborn, fill_value=self.ti)
                     layer.add_pairs(conceive_uids, new_uids, dur=durs, start=start)
 
+        if self.ti < 0:
+            people.age[new_uids] += -self.ti * self.sim.t.dt_year # Age to ti=0
+
         return new_uids
 
     def set_prognoses(self, uids):
@@ -487,32 +526,66 @@ class Pregnancy(Demographics):
         """
 
         # Change states for the newly pregnant woman
-        ti = self.sim.ti
-        dt = self.sim.dt
+        ti = self.ti
         self.fecund[uids] = False
         self.pregnant[uids] = True
         self.ti_pregnant[uids] = ti
 
         # Outcomes for pregnancies
-        dur_preg = np.full(len(uids), self.pars.dur_pregnancy)  # Duration in years
+        dur_preg = np.ones(len(uids))*self.pars.dur_pregnancy
         dur_postpartum = self.pars.dur_postpartum.rvs(uids)
-        dead = self.pars.maternal_death_prob.rvs(uids)
-        self.ti_delivery[uids] = ti + dur_preg/dt # Currently assumes maternal deaths still result in a live baby
-        self.ti_postpartum[uids] = self.ti_delivery[uids] + dur_postpartum/dt
+        dead = self.pars.p_maternal_death.rvs(uids)
+        self.ti_delivery[uids] = ti + dur_preg # Currently assumes maternal deaths still result in a live baby
+        self.ti_postpartum[uids] = self.ti_delivery[uids] + dur_postpartum
         self.dur_postpartum[uids] = dur_postpartum
 
         if np.any(dead): # NB: 100x faster than np.sum(), 10x faster than np.count_nonzero()
             self.ti_dead[uids[dead]] = ti + dur_preg[dead]
         return
 
+    def finish_step(self):
+        super().finish_step()
+        death_uids = ss.uids(self.sim.people.ti_dead <= self.ti)
+        if len(death_uids) == 0:
+            return
+
+        # Any pregnant? Consider death of the neonate
+        mother_death_uids = death_uids[self.pregnant[death_uids]]
+        if len(mother_death_uids):
+            neonate_uids = ss.uids(self.child_uid[mother_death_uids])
+            neonatal_death_uids = self.pars.p_neonatal_death.filter(neonate_uids)
+            if len(neonatal_death_uids):
+                self.sim.people.request_death(neonatal_death_uids)
+
+        # Any prenatal? Handle changes to pregnancy
+        is_prenatal = self.sim.people.age[death_uids] < 0
+        prenatal_death_uids = death_uids[is_prenatal]
+        if len(prenatal_death_uids):
+            mother_uids = self.sim.people.parent[prenatal_death_uids]
+            self.pregnant[mother_uids] = False # Baby lost, mother no longer pregnant
+            self.fecund[mother_uids] = True # Or wait?
+            self.postpartum[mother_uids] = False
+            self.child_uid[mother_uids] = np.nan
+            self.ti_delivery[mother_uids] = np.nan
+            self.ti_postpartum[mother_uids] = np.nan
+        return
+
     def update_results(self):
-        ti = self.sim.ti
+        ti = self.ti
         self.results['pregnancies'][ti] = self.n_pregnancies
         self.results['births'][ti] = self.n_births
+
+        # Reset for the next step
+        self.n_pregnancies = 0
+        self.n_births = 0
+
         return
 
     def finalize(self):
         super().finalize()
-        n_alive = self.sim.results.n_alive
-        self.results['cbr'] = 1/self.pars.units * np.divide(self.results['births'] / self.sim.dt, n_alive, where=n_alive>0)
+        units = self.pars.rate_units*self.sim.t.dt_year
+        inds = self.match_time_inds()
+        n_alive = self.sim.results.n_alive[inds]
+        births = np.divide(self.results['births'], n_alive, where=n_alive>0)
+        self.results['cbr'][:] = births/units
         return
diff --git a/starsim/disease.py b/starsim/disease.py
index 21fd504..e340b34 100644
--- a/starsim/disease.py
+++ b/starsim/disease.py
@@ -1,7 +1,6 @@
 """
 Base classes for diseases
 """
-
 import numpy as np
 import sciris as sc
 import starsim as ss
@@ -9,56 +8,67 @@ import networkx as nx
 from operator import itemgetter
 import pandas as pd
 
+ss_int_ = ss.dtypes.int
+
 __all__ = ['Disease', 'Infection', 'InfectionLog']
 
 
 class Disease(ss.Module):
     """ Base module class for diseases """
 
-    def __init__(self, log=True, *args, **kwargs):
+    def __init__(self, pars=None, *args, **kwargs):
         super().__init__(*args, **kwargs)
+        self.define_pars(
+            log = False,
+        )
+        self.update_pars(pars, **kwargs)
         self.results = ss.Results(self.name)
-        self.log = InfectionLog() if log else None  # See below for definition
         return
 
     @property
-    def _boolean_states(self):
+    def _disease_states(self):
         """
-        Iterator over states with boolean type
+        Iterator over disease states with boolean type
 
         For diseases, these states typically represent attributes like 'susceptible',
-        'infectious', 'diagnosed' etc. These variables are typically useful to
+        'infectious', 'diagnosed' etc. These variables are typically useful to store
+        results for.
         """
         for state in self.states:
-            if state.dtype == bool:
+            if isinstance(state, ss.State):
                 yield state
         return
 
     def init_pre(self, sim):
         """ Link the disease to the sim, create objects, and initialize results; see Module.init_pre() for details """
         super().init_pre(sim)
-        self.init_results()
+        if self.pars.log:
+            self.log = InfectionLog()
         return
 
     def init_results(self):
         """
         Initialize results
 
-        By default, diseases all report on counts for any boolean states e.g., if
+        By default, diseases all report on counts for any explicitly defined "States", e.g. if
         a disease contains a boolean state 'susceptible' it will automatically contain a
-        Result for 'n_susceptible'
+        Result for 'n_susceptible'.
         """
-        for state in self._boolean_states:
-            self.results += ss.Result(self.name, f'n_{state.name}', self.sim.npts, dtype=int, scale=True)
+        super().init_results()
+        results = sc.autolist()
+        for state in self._disease_states:
+            results += ss.Result(f'n_{state.name}', dtype=int, scale=True, label=state.label)
+        self.define_results(*results)
         return
 
-    def update_pre(self):
+    def step_state(self):
         """
-        Carry out autonomous updates at the start of the timestep (prior to transmission)
+        Carry out updates at the start of the timestep (prior to transmission);
+        these are typically state changes
         """
         pass
 
-    def update_death(self, uids):
+    def step_die(self, uids):
         """
         Carry out state changes upon death
 
@@ -70,14 +80,18 @@ class Disease(ss.Module):
         to undo any state changes that have already been applied (because they only run via this
         function if the death actually occurs).
 
+        Unlike other methods during the integration loop, this method is not called directly
+        by the sim; instead, it is called by people.step_die(), which reconciles the UIDs of
+        the agents who will die.
+
         Depending on the module and the results it produces, it may or may not be necessary
         to implement this.
         """
         pass
 
-    def make_new_cases(self):
+    def step(self):
         """
-        Add new cases of the disease
+        Handle the main disease updates, e.g. add new cases
 
         This method is agnostic as to the mechanism by which new cases occur. This
         could be through transmission (parametrized in different ways, which may or
@@ -89,16 +103,17 @@ class Disease(ss.Module):
         """
         pass
 
-    def set_prognoses(self, uids, source_uids=None):
+    def set_prognoses(self, uids, sources=None):
         """
         Set prognoses upon infection/acquisition
 
         This function assigns state values upon infection or acquisition of
         the disease. It would normally be called somewhere towards the end of
-        `Disease.make_new_cases()`. Infections will automatically be added to
-        the log as part of this operation.
+        `Disease.make_new_cases()`. Infections will optionally be added to
+        the log as part of this operation if logging is enabled (in the
+        `Disease` parameters)
 
-        The from_uids are relevant for infectious diseases, but would be left
+        The `sources` are relevant for infectious diseases, but would be left
         as `None` for NCDs.
 
         Args:
@@ -106,14 +121,13 @@ class Disease(ss.Module):
             uids (array): UIDs for agents to assign disease progoses to
             from_uids (array): Optionally specify the infecting agent
         """
-        if self.log is not None:
-            sim = self.sim
-            if source_uids is None:
-                for target in uids:
-                    self.log.append(np.nan, target, sim.year)
-            else:
-                for target, source in zip(uids, source_uids):
-                    self.log.append(source, target, sim.year)
+        # Track infections
+        if self.pars.log:
+            self.log_infections(uids, sources)
+        return
+
+    def log_infections(self, uids, sources=None):
+        self.log.add_entries(uids, sources, self.now)
         return
 
     def update_results(self):
@@ -124,9 +138,8 @@ class Disease(ss.Module):
         This allows result updates at this point to capture outcomes dependent on multiple
         modules, where relevant.
         """
-        sim = self.sim
-        for state in self._boolean_states:
-            self.results[f'n_{state.name}'][sim.ti] = np.count_nonzero(state & sim.people.alive)
+        for state in self._disease_states:
+            self.results[f'n_{state.name}'][self.ti] = state.sum()
         return
 
 
@@ -139,47 +152,28 @@ class Infection(Disease):
     operate on to capture co-infection
     """
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, pars=None, *args, **kwargs):
         super().__init__(*args, **kwargs)
-        self.add_states(
-            ss.BoolArr('susceptible', default=True),
-            ss.BoolArr('infected'),
-            ss.FloatArr('rel_sus', default=1.0),
-            ss.FloatArr('rel_trans', default=1.0),
-            ss.FloatArr('ti_infected'),
+        self.define_states(
+            ss.State('susceptible', default=True, label='Susceptible'),
+            ss.State('infected', label='Infectious'),
+            ss.FloatArr('rel_sus', default=1.0, label='Relative susceptibility'),
+            ss.FloatArr('rel_trans', default=1.0, label='Relative transmission'),
+            ss.FloatArr('ti_infected', label='Time of infection' ),
         )
 
-        # Define random number generators for make_new_cases
-        self.rng_target = ss.random(name='target')
-        self.rng_source = ss.random(name='source')
+        self.define_pars(
+            init_prev = None, # Replace None with a ss.bernoulli to seed infections
+        )
+        self.update_pars(pars, **kwargs)
+
+        # Define random number generator for determining transmission
+        self.trans_rng = ss.multi_random('source', 'target')
         return
-    
+
     def init_pre(self, sim):
         super().init_pre(sim)
-        self.validate_beta()
-        return
-    
-    def validate_beta(self):
-        """
-        Perform any parameter validation
-        """
-        networks = self.sim.networks
-        if networks is not None and len(networks) > 0:
-            
-            if 'beta' not in self.pars:
-                errormsg = f'Disease {self.name} is missing beta; pars are: {sc.strjoin(self.pars.keys())}'
-                raise sc.KeyNotFoundError(errormsg)
-
-            # If beta is a scalar, apply this bi-directionally to all networks
-            if sc.isnumber(self.pars.beta):
-                β = self.pars.beta
-                self.pars.beta = sc.objdict({k:[β,β] for k in networks.keys()})
-
-            # If beta is a dict, check all entries are bi-directional
-            elif isinstance(self.pars.beta, dict):
-                for k,β in self.pars.beta.items():
-                    if sc.isnumber(β):
-                        self.pars.beta[k] = [β,β]
+        self.validate_beta(run_checks=True)
         return
 
     @property
@@ -197,127 +191,163 @@ class Infection(Disease):
         i.e., creating their dynamic array, linking them to a People instance. That should have already
         taken place by the time this method is called.
         """
+        super().init_post()
         if self.pars.init_prev is None:
             return
 
         initial_cases = self.pars.init_prev.filter()
-        self.set_prognoses(initial_cases)  # TODO: sentinel value to indicate seeds?
-        return
+        if len(initial_cases):
+            self.set_prognoses(initial_cases)  # TODO: sentinel value to indicate seeds?
+
+        # Exclude initial cases from results -- disabling for now since it disrupts counting of new infections, e.g. test_diseases.py
+        # self.ti_infected[self.ti_infected == self.ti] = -1
+        return initial_cases
 
     def init_results(self):
         """
         Initialize results
         """
         super().init_results()
+        self.define_results(
+            ss.Result('prevalence',     dtype=float, scale=False, label='Prevalence'),
+            ss.Result('new_infections', dtype=int,   scale=True,  label='New infections'),
+            ss.Result('cum_infections', dtype=int,   scale=True,  label='Cumulative infections'),
+        )
+        return
+
+    def validate_beta(self, run_checks=False):
+        """ Validate beta and return as a map to match the networks """
         sim = self.sim
-        self.results += [
-            ss.Result(self.name, 'prevalence',     sim.npts, dtype=float, scale=False),
-            ss.Result(self.name, 'new_infections', sim.npts, dtype=int, scale=True),
-            ss.Result(self.name, 'cum_infections', sim.npts, dtype=int, scale=True),
-        ]
-        return
+        β = self.pars.beta
 
-    def _check_betas(self):
-        """ Check that there's a network for each beta key """
-        # Ensure keys are lowercase
-        if isinstance(self.pars.beta, dict): # TODO: check if needed
-            self.pars.beta = {k.lower(): v for k, v in self.pars.beta.items()}
+        def scalar_beta(β):
+            return isinstance(β, ss.TimePar) or sc.isnumber(β)
 
-        # Create a mapping between beta and networks, and populate it
-        betapars = self.pars.beta
-        betamap = sc.objdict()
-        netkeys = list(self.sim.networks.keys())
-        if netkeys: # Skip if no networks
-            for bkey in betapars.keys():
-                orig_bkey = bkey[:]
-                if bkey in netkeys: # TODO: CK: could tidy up logic
-                    betamap[bkey] = betapars[orig_bkey]
+        if run_checks:
+            scalar_warn = f'Beta is defined as a number ({β}); convert it to a rate to handle timestep conversions'
+
+            if 'beta' not in self.pars:
+                errormsg = f'Disease {self.name} is missing beta; pars are: {sc.strjoin(self.pars.keys())}'
+                raise sc.KeyNotFoundError(errormsg)
+
+            if sc.isnumber(β):
+                ss.warn(scalar_warn)
+            elif isinstance(β, dict):
+                for netbeta in β.values():
+                    if sc.isnumber(netbeta):
+                        ss.warn(scalar_warn)
+                    elif isinstance(netbeta, (list, tuple)):
+                        for thisbeta in netbeta:
+                            if sc.isnumber(netbeta):
+                                ss.warn(scalar_warn)
+
+        # If beta is a scalar, apply this bi-directionally to all networks
+        if scalar_beta(β):
+            betamap = {ss.standardize_netkey(k):[β,β] for k in sim.networks.keys()}
+
+        # If beta is a dict, check all entries are bi-directional
+        elif isinstance(β, dict):
+            betamap = dict()
+            for k,thisbeta in β.items():
+                nkey = ss.standardize_netkey(k)
+                if scalar_beta(thisbeta):
+                    betamap[nkey] = [thisbeta, thisbeta]
                 else:
-                    if 'net' not in bkey:
-                        bkey += 'net'  # Add 'net' suffix if not already there
-                    if bkey in netkeys:
-                        betamap[bkey] = betapars[orig_bkey]
-                    else:
-                        errormsg = f'No network for beta parameter "{bkey}"; your beta should match network keys:\n{sc.newlinejoin(netkeys)}'
-                        raise ValueError(errormsg)
+                    betamap[nkey] = thisbeta
+
+        else:
+            errormsg = f'Invalid type {type(β)} for beta'
+            raise TypeError(errormsg)
+
+        # Check that it matches the network
+        netkeys = [ss.standardize_netkey(k) for k in list(sim.networks.keys())]
+        if set(betamap.keys()) != set(netkeys):
+            errormsg = f'Network keys ({netkeys}) and beta keys ({betamap.keys()}) do not match'
+            raise ValueError(errormsg)
+
         return betamap
 
-    def make_new_cases(self):
+    def step(self):
         """
-        Add new cases of module, through transmission, incidence, etc.
-        
-        Common-random-number-safe transmission code works by mapping edges onto
-        slots.
+        Perform key infection updates, including infection and setting prognoses
         """
+        # Create new cases
+        new_cases, sources, networks = self.infect() # TODO: store outputs in self or use objdict rather than 3 returns
+
+        # Set prognoses
+        if len(new_cases):
+            self.set_outcomes(new_cases, sources)
+
+        return new_cases, sources, networks
+
+    @staticmethod # In future, consider: @nb.njit(fastmath=True, parallel=True, cache=True), but no faster it seems
+    def compute_transmission(src, trg, rel_trans, rel_sus, beta_per_dt, randvals):
+        """ Compute the probability of a->b transmission """
+        p_transmit = rel_trans[src] * rel_sus[trg] * beta_per_dt
+        transmitted = p_transmit > randvals
+        target_uids = trg[transmitted]
+        source_uids = src[transmitted]
+        return target_uids, source_uids
+
+    def infect(self):
+        """ Determine who gets infected on this timestep via transmission on the network """
         new_cases = []
         sources = []
-        betamap = self._check_betas()
+        networks = []
+        betamap = self.validate_beta()
 
-        for nkey,net in self.sim.networks.items():
-            if not len(net):
-                break
+        rel_trans = self.rel_trans.asnew(self.infectious * self.rel_trans)
+        rel_sus   = self.rel_sus.asnew(self.susceptible * self.rel_sus)
 
-            nbetas = betamap[nkey]
-            edges = net.edges
+        for i, (nkey,net) in enumerate(self.sim.networks.items()):
+            nk = ss.standardize_netkey(nkey)
+            if isinstance(net, ss.Network) and len(net): # Skip networks with no edges
+                edges = net.edges
+                p1p2b0 = [edges.p1, edges.p2, betamap[nk][0]] # Person 1, person 2, beta 0
+                p2p1b1 = [edges.p2, edges.p1, betamap[nk][1]] # Person 2, person 1, beta 1
+                for src, trg, beta in [p1p2b0, p2p1b1]:
+                    if beta: # Skip networks with no transmission
+                        beta_per_dt = net.net_beta(disease_beta=beta) # Compute beta for this network and timestep
+                        randvals = self.trans_rng.rvs(src, trg) # Generate a new random number based on the two other random numbers
+                        args = (src, trg, rel_trans, rel_sus, beta_per_dt, randvals) # Set up the arguments to calculate transmission
+                        target_uids, source_uids = self.compute_transmission(*args) # Actually calculate it
+                        new_cases.append(target_uids)
+                        sources.append(source_uids)
+                        networks.append(np.full(len(target_uids), dtype=ss_int_, fill_value=i))
 
-            rel_trans = self.rel_trans.asnew(self.infectious * self.rel_trans)
-            rel_sus   = self.rel_sus.asnew(self.susceptible * self.rel_sus)
-            p1p2b0 = [edges.p1, edges.p2, nbetas[0]]
-            p2p1b1 = [edges.p2, edges.p1, nbetas[1]]
-            for src, trg, beta in [p1p2b0, p2p1b1]:
-
-                # Skip networks with no transmission
-                if beta == 0:
-                    continue
-
-                # Calculate probability of a->b transmission.
-                beta_per_dt = net.beta_per_dt(disease_beta=beta, dt=self.sim.dt)
-                p_transmit = rel_trans[src] * rel_sus[trg] * beta_per_dt
-
-                # Generate a new random number based on the two other random numbers -- 3x faster than `rvs = np.remainder(rvs_s + rvs_t, 1)`
-                rvs_s = self.rng_source.rvs(src)
-                rvs_t = self.rng_target.rvs(trg)
-                rvs = rvs_s + rvs_t
-                inds = np.where(rvs>1.0)[0]
-                rvs[inds] -= 1
-                
-                new_cases_bool = rvs < p_transmit
-                new_cases.append(trg[new_cases_bool])
-                sources.append(src[new_cases_bool])
-                
-        # Tidy up
+        # Finalize
         if len(new_cases) and len(sources):
             new_cases = ss.uids.cat(new_cases)
-            sources = ss.uids.cat(sources)
+            new_cases, inds = new_cases.unique(return_index=True)
+            sources = ss.uids.cat(sources)[inds]
+            networks = np.concatenate(networks)[inds]
         else:
-            new_cases = np.empty(0, dtype=int)
-            sources = np.empty(0, dtype=int)
-            
-        if len(new_cases):
-            self._set_cases(new_cases, sources)
-            
-        return new_cases, sources
+            new_cases = ss.uids()
+            sources = ss.uids()
+            networks = np.empty(0, dtype=ss_int_)
 
-    def _set_cases(self, target_uids, source_uids=None):
+        return new_cases, sources, networks
+
+    def set_outcomes(self, uids, sources=None):
         sim = self.sim
-        congenital = sim.people.age[target_uids] <= 0
+        congenital = sim.people.age[uids] <= 0
         if np.count_nonzero(congenital):
-            src_c = source_uids[congenital] if source_uids is not None else None
-            self.set_congenital(target_uids[congenital], src_c)
-        src_p = source_uids[~congenital] if source_uids is not None else None
-        self.set_prognoses(target_uids[~congenital], src_p)
+            src_c = sources[congenital] if sources is not None else None
+            self.set_congenital(uids[congenital], src_c)
+        src_p = sources[~congenital] if sources is not None else None
+        self.set_prognoses(uids[~congenital], src_p)
         return
 
-    def set_congenital(self, target_uids, source_uids=None):
+    def set_congenital(self, uids, sources=None):
         pass
 
     def update_results(self):
         super().update_results()
         res = self.results
-        ti = self.sim.ti
+        ti = self.ti
         res.prevalence[ti] = res.n_infected[ti] / np.count_nonzero(self.sim.people.alive)
         res.new_infections[ti] = np.count_nonzero(self.ti_infected == ti)
-        res.cum_infections[ti] = np.sum(res['new_infections'][:ti+1])
+        res.cum_infections[ti] = np.sum(res['new_infections'][:ti+1]) # TODO: can compute at end
         return
 
 
@@ -349,9 +379,14 @@ class InfectionLog(nx.MultiDiGraph):
 
     A table of outcomes can be returned using `InfectionLog.line_list()`
     """
-
-    # Add entries
-    # Add items to the most recent infection for an agent
+    def add_entries(self, uids, sources=None, time=np.nan):
+        if sources is None:
+            for target in uids:
+                self.append(np.nan, target, time)
+        else:
+            for target, source in zip(uids, sources):
+                self.append(source, target, time)
+        return
 
     def add_data(self, uids, **kwargs):
         """
@@ -360,21 +395,19 @@ class InfectionLog(nx.MultiDiGraph):
         This method can be used to add data to an existing transmission event.
         The most recent transmission event will be used
 
-        :param uid: The UID of the target node (the agent that was infected)
-        :param kwargs: Remaining arguments are stored as edge data
+        Args:
+            uid: The UID of the target node (the agent that was infected)
+            kwargs: Remaining arguments are stored as edge data
         """
-        for uid in sc.promotetoarray(uids):
-            source, target, key = max(self.in_edges(uid, keys=True),
-                                      key=itemgetter(2, 0))  # itemgetter twice as fast as lambda apparently
+        for uid in sc.toarray(uids):
+            source, target, key = max(self.in_edges(uid, keys=True), key=itemgetter(2, 0))  # itemgetter twice as fast as lambda apparently
             self[source][target][key].update(**kwargs)
-
         return
 
     def append(self, source, target, t, **kwargs):
         self.add_edge(source, target, key=t, **kwargs)
         return
 
-    @property
     def line_list(self):
         """
         Return a tabular representation of the log
diff --git a/starsim/diseases/cholera.py b/starsim/diseases/cholera.py
index 8f897bd..ccaf251 100644
--- a/starsim/diseases/cholera.py
+++ b/starsim/diseases/cholera.py
@@ -17,41 +17,41 @@ class Cholera(ss.Infection):
     def __init__(self, pars=None, *args, **kwargs):
         """ Initialize with parameters """
         super().__init__()
-        self.default_pars(
+        self.define_pars(
             # Initial conditions and beta
-            beta = 1.0, # Placeholder value
+            beta = ss.beta(1.0), # Placeholder value
             init_prev = ss.bernoulli(0.005),
-            
+
             # Natural history parameters, all specified in days
-            dur_exp2inf   = ss.lognorm_ex(mean=2.772, stdev=4.737), # Calculated from Azman et al. estimates https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3677557/
-            dur_asymp2rec = ss.uniform(low=1, high=10), # From WHO cholera fact sheet, asymptomatic individuals shed bacteria for 1-10 days (https://www.who.int/news-room/fact-sheets/detail/cholera)
-            dur_symp2rec  = ss.lognorm_ex(mean=5, stdev=1.8), # According to Fung most modelling studies assume 5 days of symptoms (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3926264/), but found a range of 2.9-14 days. Distribution approximately fit to these values
-            dur_symp2dead = ss.lognorm_ex(mean=1, stdev=0.5), # There does not appear to be differences in timing/duration of mild vs severe disease, but death from severe disease happens rapidly https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5767916/
+            dur_exp2inf   = ss.days(ss.lognorm_ex(mean=2.772, std=4.737)), # Calculated from Azman et al. estimates https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3677557/
+            dur_asymp2rec = ss.days(ss.uniform(low=1, high=10)), # From WHO cholera fact sheet, asymptomatic individuals shed bacteria for 1-10 days (https://www.who.int/news-room/fact-sheets/detail/cholera)
+            dur_symp2rec  = ss.days(ss.lognorm_ex(mean=5, std=1.8)), # According to Fung most modelling studies assume 5 days of symptoms (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3926264/), but found a range of 2.9-14 days. Distribution approximately fit to these values
+            dur_symp2dead = ss.days(ss.lognorm_ex(mean=1, std=0.5)), # There does not appear to be differences in timing/duration of mild vs severe disease, but death from severe disease happens rapidly https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5767916/
             p_death       = ss.bernoulli(p=0.005), # Probability of death is typically less than 1% when treated
             p_symp        = ss.bernoulli(p=0.5), # Proportion of infected which are symptomatic, mid range of ~25% and 57% estimates from Jaclson et al (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3795095/) and Nelson et al (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3842031/), respectively
             asymp_trans   = 0.01, # Reduction in transmission probability for asymptomatic infection, asymptomatic carriers shed 100-1000 times less bacteria than symptomatic carriers (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3084143/ and https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3842031/). Previous models assume a 10% relative transmissibility (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4238032/)
 
             # Environmental parameters
-            beta_env = 0.5 / 3, # Scaling factor for transmission from environment,
+            beta_env = ss.beta(0.5 / 3), # Scaling factor for transmission from environment,
             half_sat_rate = 1_000_000, # Infectious dose in water sufficient to produce infection in 50% of  exposed, from Mukandavire et al. (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3102413/)
-            shedding_rate = 10, # Rate at which infectious people shed bacteria to the environment (per day), from Mukandavire et al. (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3102413/)
-            decay_rate = 0.033, # Rate at which bacteria in the environment dies (per day), from Chao et al. and Mukandavire et al. citing https://pubmed.ncbi.nlm.nih.gov/8882180/
+            shedding_rate = ss.rate(10, unit='day'), # Rate at which infectious people shed bacteria to the environment (per day), from Mukandavire et al. (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3102413/)
+            decay_rate = ss.rate(0.033, unit='day'), # Rate at which bacteria in the environment dies (per day), from Chao et al. and Mukandavire et al. citing https://pubmed.ncbi.nlm.nih.gov/8882180/
             p_env_transmit = ss.bernoulli(p=0), # Probability of environmental transmission - filled out later
         )
         self.update_pars(pars, **kwargs)
 
         # Boolean states
-        self.add_states(
+        self.define_states(
             # Susceptible & infected are added automatically, here we add the rest
-            ss.BoolArr('exposed'),
-            ss.BoolArr('symptomatic'),
-            ss.BoolArr('recovered'),
-    
+            ss.State('exposed', label='Exposed'),
+            ss.State('symptomatic', label='Symptomatic'),
+            ss.State('recovered', label='Recovered'),
+
             # Timepoint states
-            ss.FloatArr('ti_exposed'),
-            ss.FloatArr('ti_symptomatic'),
-            ss.FloatArr('ti_recovered'),
-            ss.FloatArr('ti_dead'),
+            ss.FloatArr('ti_exposed', label='Time of exposure'),
+            ss.FloatArr('ti_symptomatic', label='Time of symptoms'),
+            ss.FloatArr('ti_recovered', label='Time of recovery'),
+            ss.FloatArr('ti_dead', label='Time of death'),
         )
         return
 
@@ -64,26 +64,23 @@ class Cholera(ss.Infection):
         return self.infected & ~self.symptomatic
 
     def init_results(self):
-        """
-        Initialize results
-        """
+        """ Initialize results """
         super().init_results()
-        npts = self.sim.npts
-        self.results += [
-            ss.Result(self.name, 'new_deaths', npts, dtype=int),
-            ss.Result(self.name, 'cum_deaths', npts, dtype=int),
-            ss.Result(self.name, 'env_prev', npts, dtype=float),
-            ss.Result(self.name, 'env_conc', npts, dtype=float),
-        ]
+        self.define_results(
+            ss.Result('new_deaths', dtype=int,   label='Deaths'),
+            ss.Result('cum_deaths', dtype=int,   label='Cumulative deaths'),
+            ss.Result('env_prev',   dtype=float, label='Environmental prevalence'),
+            ss.Result('env_conc',   dtype=float, label='Environmental concentration'),
+        )
         return
 
-    def update_pre(self):
+    def step_state(self):
         """
         Adapted from https://github.com/optimamodel/gavi-outbreaks/blob/main/stisim/gavi/cholera.py
         Original version by Dom Delport
         """
         # Progress exposed -> infected
-        ti = self.sim.ti
+        ti = self.ti
         infected = (self.exposed & (self.ti_infected <= ti)).uids
         self.infected[infected] = True
 
@@ -114,7 +111,7 @@ class Cholera(ss.Infection):
         """
         p = self.pars
         r = self.results
-        ti = self.sim.ti
+        ti = self.ti
 
         n_symptomatic = self.symptomatic.sum()
         n_asymptomatic = self.asymptomatic.sum()
@@ -127,11 +124,10 @@ class Cholera(ss.Infection):
         r.env_conc[ti] = r.env_prev[ti] / (r.env_prev[ti] + p.half_sat_rate)
         return
 
-    def set_prognoses(self, uids, source_uids=None):
+    def set_prognoses(self, uids, sources=None):
         """ Set prognoses for those who get infected """
-        super().set_prognoses(uids, source_uids)
-        ti = self.sim.ti
-        dt = self.sim.dt
+        super().set_prognoses(uids, sources)
+        ti = self.ti
 
         self.susceptible[uids] = False
         self.exposed[uids] = True
@@ -140,7 +136,7 @@ class Cholera(ss.Infection):
         p = self.pars
 
         # Determine when exposed become infected
-        self.ti_infected[uids] = ti + p.dur_exp2inf.rvs(uids) / dt
+        self.ti_infected[uids] = ti + p.dur_exp2inf.rvs(uids)
 
         # Determine who becomes symptomatic and when
         symp_uids = p.p_symp.filter(uids)
@@ -148,13 +144,13 @@ class Cholera(ss.Infection):
 
         # Determine who dies and when
         dead_uids = p.p_death.filter(symp_uids)
-        self.ti_dead[dead_uids] = self.ti_symptomatic[dead_uids] + p.dur_symp2dead.rvs(dead_uids) / dt
+        self.ti_dead[dead_uids] = self.ti_symptomatic[dead_uids] + p.dur_symp2dead.rvs(dead_uids)
         symp_rev_uids = np.setdiff1d(symp_uids, dead_uids)
         asymp_uids = np.setdiff1d(uids, symp_uids)
 
         # Determine when agents recover
-        self.ti_recovered[symp_rev_uids] = self.ti_exposed[symp_rev_uids] + p.dur_symp2rec.rvs(symp_rev_uids) / dt
-        self.ti_recovered[asymp_uids] = self.ti_exposed[asymp_uids] + p.dur_asymp2rec.rvs(asymp_uids) / dt
+        self.ti_recovered[symp_rev_uids] = self.ti_exposed[symp_rev_uids] + p.dur_symp2rec.rvs(symp_rev_uids)
+        self.ti_recovered[asymp_uids] = self.ti_exposed[asymp_uids] + p.dur_asymp2rec.rvs(asymp_uids)
 
         return
 
@@ -162,18 +158,18 @@ class Cholera(ss.Infection):
         """ Add indirect transmission """
         # Make new cases via direct transmission
         super().make_new_cases()
-        
+
         # Make new cases via indirect transmission
         pars = self.pars
         res = self.results
-        p_transmit = res.env_conc[self.sim.ti] * pars.beta_env
+        p_transmit = res.env_conc[self.ti] * pars.beta_env
         pars.p_env_transmit.set(p=p_transmit)
         new_cases = pars.p_env_transmit.filter(self.sim.people.uid[self.susceptible]) # TODO: make syntax nicer
         if new_cases.any():
             self.set_prognoses(new_cases, source_uids=None)
         return
 
-    def update_death(self, uids):
+    def step_die(self, uids):
         """ Reset infected/recovered flags for dead agents """
         for state in ['susceptible', 'exposed', 'infected', 'symptomatic', 'recovered']:
             self.statesdict[state][uids] = False
@@ -182,7 +178,7 @@ class Cholera(ss.Infection):
     def update_results(self):
         super().update_results()
         res = self.results
-        ti = self.sim.ti
+        ti = self.ti
         res.new_deaths[ti] = np.count_nonzero(self.ti_dead == ti)
         res.cum_deaths[ti] = np.sum(res.new_deaths[:ti+1])
         return
diff --git a/starsim/diseases/ebola.py b/starsim/diseases/ebola.py
index eeb3c01..ffc9181 100644
--- a/starsim/diseases/ebola.py
+++ b/starsim/diseases/ebola.py
@@ -16,40 +16,40 @@ class Ebola(SIR):
     def __init__(self, pars=None, *args, **kwargs):
         """ Initialize with parameters """
         super().__init__()
-        self.default_pars(
+        self.define_pars(
             # Initial conditions and beta
             init_prev       = ss.bernoulli(p=0.005),
-            beta            = 1.0, # Placeholder value
+            beta            = ss.beta(1.0), # Placeholder value
             sev_factor      = 2.2,
             unburied_factor = 2.1,
-            
+
             # Natural history parameters, all specified in days
-            dur_exp2symp    = ss.lognorm_ex(mean=12.7), # Add source
-            dur_symp2sev    = ss.lognorm_ex(mean=6), # Add source
-            dur_sev2dead    = ss.lognorm_ex(mean=1.5), # Add source
-            dur_dead2buried = ss.lognorm_ex(mean=2), # Add source
-            dur_symp2rec    = ss.lognorm_ex(mean=10), # Add source
-            dur_sev2rec     = ss.lognorm_ex(mean=10.4), # Add source
+            dur_exp2symp    = ss.lognorm_ex(mean=ss.days(12.7)), # Add source
+            dur_symp2sev    = ss.lognorm_ex(mean=ss.days(6)), # Add source
+            dur_sev2dead    = ss.lognorm_ex(mean=ss.days(1.5)), # Add source
+            dur_dead2buried = ss.lognorm_ex(mean=ss.days(2)), # Add source
+            dur_symp2rec    = ss.lognorm_ex(mean=ss.days(10)), # Add source
+            dur_sev2rec     = ss.lognorm_ex(mean=ss.days(10.4)), # Add source
             p_sev           = ss.bernoulli(p=0.7), # Add source
             p_death         = ss.bernoulli(p=0.55), # Add source
             p_safe_bury     = ss.bernoulli(p=0.25), # Probability of a safe burial - should be linked to diagnoses
         )
         self.update_pars(pars=pars, **kwargs)
-        
+
         # Boolean states
-        self.add_states(
+        self.define_states(
             # SIR are added automatically, here we add E
-            ss.BoolArr('exposed'),
-            ss.BoolArr('severe'),
-            ss.BoolArr('recovered'),
-            ss.BoolArr('buried'),
-    
+            ss.State('exposed', label='Exposed'),
+            ss.State('severe', label='Severe'),
+            ss.State('recovered', label='Recovered'),
+            ss.State('buried', label='Buried'),
+
             # Timepoint states
-            ss.FloatArr('ti_exposed'),
-            ss.FloatArr('ti_severe'),
-            ss.FloatArr('ti_recovered'),
-            ss.FloatArr('ti_dead'),
-            ss.FloatArr('ti_buried'),
+            ss.FloatArr('ti_exposed', label='Time of exposure'),
+            ss.FloatArr('ti_severe', label='Time of severe symptoms'),
+            ss.FloatArr('ti_recovered', label='Time of recovery'),
+            ss.FloatArr('ti_dead', label='Time of death'),
+            ss.FloatArr('ti_buried', label='Time of burial'),
         )
         return
 
@@ -57,10 +57,10 @@ class Ebola(SIR):
     def infectious(self):
         return self.infected | self.exposed
 
-    def update_pre(self):
+    def step_state(self):
 
         # Progress exposed -> infected
-        ti = self.sim.ti
+        ti = self.ti
         infected = (self.exposed & (self.ti_infected <= ti)).uids
         self.exposed[infected] = False
         self.infected[infected] = True
@@ -87,7 +87,7 @@ class Ebola(SIR):
         # Progress dead -> buried
         buried = (self.ti_buried <= ti).uids
         self.buried[buried] = True
-        
+
         return
 
     def set_prognoses(self, uids, source_uids=None):
@@ -95,8 +95,7 @@ class Ebola(SIR):
         # Do not call set_prognoses on the parent
         #super().set_prognoses(sim, uids, source_uids)
 
-        ti = self.sim.ti
-        dt = self.sim.dt
+        ti = self.ti
         self.susceptible[uids] = False
         self.exposed[uids] = True
         self.ti_exposed[uids] = ti
@@ -104,25 +103,25 @@ class Ebola(SIR):
         p = self.pars
 
         # Determine when exposed become infected
-        self.ti_infected[uids] = ti + p.dur_exp2symp.rvs(uids) / dt
+        self.ti_infected[uids] = ti + p.dur_exp2symp.rvs(uids)
 
         # Determine who progresses to sever and when
         sev_uids = p.p_sev.filter(uids)
-        self.ti_severe[sev_uids] = self.ti_infected[sev_uids] + p.dur_symp2sev.rvs(sev_uids) / dt
+        self.ti_severe[sev_uids] = self.ti_infected[sev_uids] + p.dur_symp2sev.rvs(sev_uids)
 
         # Determine who dies and who recovers and when
         dead_uids = p.p_death.filter(sev_uids)
-        self.ti_dead[dead_uids] = self.ti_severe[dead_uids] + p.dur_sev2dead.rvs(dead_uids) / dt
+        self.ti_dead[dead_uids] = self.ti_severe[dead_uids] + p.dur_sev2dead.rvs(dead_uids)
         rec_sev_uids = np.setdiff1d(sev_uids, dead_uids)
-        self.ti_recovered[rec_sev_uids] = self.ti_severe[rec_sev_uids] + p.dur_sev2rec.rvs(rec_sev_uids) / dt
+        self.ti_recovered[rec_sev_uids] = self.ti_severe[rec_sev_uids] + p.dur_sev2rec.rvs(rec_sev_uids)
         rec_symp_uids = np.setdiff1d(uids, sev_uids)
-        self.ti_recovered[rec_symp_uids] = self.ti_infected[rec_symp_uids] + p.dur_symp2rec.rvs(rec_symp_uids) / dt
+        self.ti_recovered[rec_symp_uids] = self.ti_infected[rec_symp_uids] + p.dur_symp2rec.rvs(rec_symp_uids)
 
         # Determine time of burial - either immediate (safe burials) or after a delay (unsafe)
         safe_buried = p.p_safe_bury.filter(dead_uids)
         unsafe_buried = np.setdiff1d(dead_uids, safe_buried)
         self.ti_buried[safe_buried] = self.ti_dead[safe_buried]
-        self.ti_buried[unsafe_buried] = self.ti_dead[unsafe_buried] + p.dur_dead2buried.rvs(unsafe_buried) / dt
+        self.ti_buried[unsafe_buried] = self.ti_dead[unsafe_buried] + p.dur_dead2buried.rvs(unsafe_buried)
 
         # Change rel_trans values
         self.rel_trans[self.infectious] = 1
@@ -131,7 +130,7 @@ class Ebola(SIR):
         self.rel_trans[unburied_uids] = self.pars['unburied_factor']  # Change for unburied
         return
 
-    def update_death(self, uids):
+    def step_die(self, uids):
         # Reset infected/recovered flags for dead agents
         for state in ['susceptible', 'exposed', 'infected', 'severe', 'recovered']:
             self.statesdict[state][uids] = False
diff --git a/starsim/diseases/gonorrhea.py b/starsim/diseases/gonorrhea.py
index fb63f9e..31c2d8a 100644
--- a/starsim/diseases/gonorrhea.py
+++ b/starsim/diseases/gonorrhea.py
@@ -13,53 +13,55 @@ class Gonorrhea(ss.Infection):
     def __init__(self, pars=None, *args, **kwargs):
         # Parameters
         super().__init__()
-        self.default_pars(
-            beta = 1.0, # Placeholder value
-            dur_inf_in_days = ss.lognorm_ex(mean=10, stdev=0.6),  # median of 10 days (IQR 7–15 days) https://sti.bmj.com/content/96/8/556
+        self.define_pars(
+            beta = ss.beta(1.0), # Placeholder value
+            dur_inf_in_days = ss.lognorm_ex(mean=ss.days(10), std=ss.days(0.6)),  # median of 10 days (IQR 7–15 days) https://sti.bmj.com/content/96/8/556
             p_symp    = ss.bernoulli(p=0.5),  # Share of infections that are symptomatic. Placeholder value
             p_clear   = ss.bernoulli(p=0.2),  # Share of infections that spontaneously clear: https://sti.bmj.com/content/96/8/556
             init_prev = ss.bernoulli(p=0.1),
         )
         self.update_pars(pars=pars, **kwargs)
-        
+
         # States additional to the default disease states (see base class)
         # Additional states dependent on parameter values, e.g. self.p_symp?
         # These might be useful for connectors to target, e.g. if HIV reduces p_clear
-        self.add_states(
-            ss.BoolArr('symptomatic'),
-            ss.FloatArr('ti_clearance'),
-            ss.FloatArr('p_symp', default=1),
+        self.define_states(
+            ss.State('symptomatic', label='Symptomatic'),
+            ss.FloatArr('ti_clearance', label='Time of clearance'),
+            ss.FloatArr('p_symp', default=1, label='Probability of symptoms'),
         )
-        
+
         return
 
     def init_results(self):
         """ Initialize results """
         super().init_results()
-        self.results += ss.Result(self.name, 'new_clearances', self.sim.npts, dtype=int)
+        self.define_results(
+            ss.Result('new_clearances', dtype=int, label='New clearances')
+        )
         return
 
     def update_results(self):
         super().update_results()
-        ti = self.sim.ti
+        ti = self.ti
         self.results.n_symptomatic[ti] = self.symptomatic.count()
         self.results.new_clearances[ti] = np.count_nonzero(self.ti_clearance == ti)
         return
 
-    def update_pre(self):
+    def step_state(self):
         """ Natural clearance """
-        clearances = self.ti_clearance <= self.sim.ti
+        clearances = self.ti_clearance <= self.ti
         self.susceptible[clearances] = True
         self.infected[clearances] = False
         self.symptomatic[clearances] = False
-        self.ti_clearance[clearances] = self.sim.ti
+        self.ti_clearance[clearances] = self.ti
 
         return
 
-    def set_prognoses(self, uids, source_uids=None):
+    def set_prognoses(self, uids, sources=None):
         """ Natural history of gonorrhea for adult infection """
-        super().set_prognoses(uids, source_uids)
-        ti = self.sim.ti
+        super().set_prognoses(uids, sources)
+        ti = self.ti
 
         # Set infection status
         self.susceptible[uids] = False
@@ -72,6 +74,6 @@ class Gonorrhea(ss.Infection):
 
         # Set natural clearance
         clear_uids = self.pars.p_clear.filter(uids)
-        dur = ti + self.pars.dur_inf_in_days.rvs(clear_uids)/365/self.sim.dt # Convert from days to years and then adjust for dt
+        dur = ti + self.pars.dur_inf_in_days.rvs(clear_uids) # Convert from days to years and then adjust for dt automatically # TODO: check!
         self.ti_clearance[clear_uids] = dur
         return
\ No newline at end of file
diff --git a/starsim/diseases/hiv.py b/starsim/diseases/hiv.py
index bf45197..caac68f 100644
--- a/starsim/diseases/hiv.py
+++ b/starsim/diseases/hiv.py
@@ -13,8 +13,9 @@ class HIV(ss.Infection):
 
     def __init__(self, pars=None, *args, **kwargs):
         super().__init__()
-        self.default_pars(
-            beta = 1.0, # Placeholder value
+        self.define_pars(
+            unit = 'year',
+            beta = ss.beta(1.0), # Placeholder value
             cd4_min = 100,
             cd4_max = 500,
             cd4_rate = 5,
@@ -22,27 +23,27 @@ class HIV(ss.Infection):
             art_efficacy = 0.96,
             init_prev = ss.bernoulli(p=0.05),
             death_dist = ss.bernoulli(p=self.death_prob_func), # Uses p_death by default, modulated by CD4
-            p_death = 0.05,
+            p_death = ss.rate(0.05), # NB: this is death per unit time, not death per infection
         )
         self.update_pars(pars=pars, **kwargs)
 
         # States
-        self.add_states(
-            ss.BoolArr('on_art'),
-            ss.FloatArr('ti_art'),
-            ss.FloatArr('ti_dead'), # Time of HIV-cause death
-            ss.FloatArr('cd4', default=500),
+        self.define_states(
+            ss.State('on_art', label='On ART'),
+            ss.FloatArr('ti_art', label='Time of ART initiation'),
+            ss.FloatArr('ti_dead', label='Time of death'), # Time of HIV-caused death
+            ss.FloatArr('cd4', default=500, label='CD4 count'),
         )
         return
 
     @staticmethod
     def death_prob_func(module, sim, uids):
         p = module.pars
-        out = sim.dt * p.p_death / (p.cd4_min - p.cd4_max)**2 *  (module.cd4[uids] - p.cd4_max)**2
+        out = p.p_death / (p.cd4_min - p.cd4_max)**2 *  (module.cd4[uids] - p.cd4_max)**2
         out = np.array(out)
         return out
 
-    def update_pre(self):
+    def step_state(self):
         """ Update CD4 """
         people = self.sim.people
         self.cd4[people.alive & self.infected & self.on_art] += (self.pars.cd4_max - self.cd4[people.alive & self.infected & self.on_art])/self.pars.cd4_rate
@@ -52,28 +53,30 @@ class HIV(ss.Infection):
 
         can_die = people.hiv.infected.uids
         hiv_deaths = self.pars.death_dist.filter(can_die)
-        
+
         people.request_death(hiv_deaths)
-        self.ti_dead[hiv_deaths] = self.sim.ti
+        self.ti_dead[hiv_deaths] = self.ti
         return
 
     def init_results(self):
         """ Initialize results """
         super().init_results()
-        self.results += ss.Result(self.name, 'new_deaths', self.sim.npts, dtype=int)
+        self.define_results(
+            ss.Result('new_deaths', dtype=int, label='Deaths')
+        )
         return
 
     def update_results(self):
         super().update_results()
-        ti = self.sim.ti
+        ti = self.ti
         self.results['new_deaths'][ti] = np.count_nonzero(self.ti_dead == ti)
-        return 
+        return
 
     def set_prognoses(self, uids, source_uids=None):
         super().set_prognoses(uids, source_uids)
         self.susceptible[uids] = False
         self.infected[uids] = True
-        self.ti_infected[uids] = self.sim.ti
+        self.ti_infected[uids] = self.ti
         return
 
     def set_congenital(self, uids, source_uids):
@@ -84,38 +87,49 @@ class HIV(ss.Infection):
 
 class ART(ss.Intervention):
 
-    def __init__(self, year: np.array, coverage: np.array, **kwargs):
+    def __init__(self, year, coverage, pars=None, **kwargs):
         self.requires = HIV
-        self.year = sc.promotetoarray(year)
-        self.coverage = sc.promotetoarray(coverage)
+        self.year = sc.toarray(year)
+        self.coverage = sc.toarray(coverage)
+        super().__init__()
+        self.define_pars(
+            art_delay = ss.constant(v=ss.years(1.0)) # Value in years
+        )
+        self.update_pars(pars=pars, **kwargs)
 
-        super().__init__(**kwargs)
-
-        self.prob_art_at_infection = ss.bernoulli(p=lambda self, sim, uids: np.interp(sim.year, self.year, self.coverage))
+        prob_art = lambda self, sim, uids: np.interp(sim.year, self.year, self.coverage)
+        self.prob_art_at_infection = ss.bernoulli(p=prob_art)
         return
 
     def init_pre(self, sim):
         super().init_pre(sim)
-        self.results += ss.Result(self.name, 'n_art', sim.npts, dtype=int)
         self.initialized = True
         return
 
-    def apply(self, sim):
+    def init_results(self):
+        super().init_results()
+        self.define_results(ss.Result('n_art', dtype=int, label='Number on ART'))
+        return
+
+    def step(self):
+        sim = self.sim
         if sim.year < self.year[0]:
             return
 
-        ti_delay = 1 # 1 time step delay TODO
-        recently_infected = ss.true((sim.people.hiv.ti_infected == sim.ti-ti_delay) & sim.people.alive)
+        hiv = sim.people.hiv
+        infected = hiv.infected.uids
+        ti_delay = np.round(self.pars.art_delay.rvs(infected)).astype(int)
+        recently_infected = infected[hiv.ti_infected[infected] == sim.ti-ti_delay]
 
         n_added = 0
         if len(recently_infected) > 0:
             inds = self.prob_art_at_infection.filter(recently_infected)
-            sim.people.hiv.on_art[inds] = True
-            sim.people.hiv.ti_art[inds] = sim.ti
+            hiv.on_art[inds] = True
+            hiv.ti_art[inds] = sim.ti
             n_added = len(inds)
 
         # Add result
-        self.results['n_art'][sim.ti] = np.count_nonzero(sim.people.alive & sim.people.hiv.on_art)
+        self.results['n_art'][sim.ti] = np.count_nonzero(hiv.on_art)
 
         return n_added
 
@@ -131,9 +145,10 @@ class CD4_analyzer(ss.Analyzer):
 
     def init_pre(self, sim):
         super().init_pre(sim)
-        self.cd4 = np.zeros((sim.npts, sim.people.n), dtype=int)
+        self.cd4 = np.zeros((self.npts, sim.people.n), dtype=int)
         return
 
-    def apply(self, sim):
+    def step(self):
+        sim = self.sim
         self.cd4[sim.t] = sim.people.hiv.cd4
         return
diff --git a/starsim/diseases/measles.py b/starsim/diseases/measles.py
index e3f058b..3fa3821 100644
--- a/starsim/diseases/measles.py
+++ b/starsim/diseases/measles.py
@@ -15,22 +15,22 @@ class Measles(SIR):
     def __init__(self, pars=None, *args, **kwargs):
         """ Initialize with parameters """
         super().__init__()
-        self.default_pars(
+        self.define_pars(
             # Initial conditions and beta
             beta = 1.0, # Placeholder value
             init_prev = ss.bernoulli(p=0.005),
-            
+
             # Natural history parameters, all specified in days
-            dur_exp = ss.normal(loc=8),        # (days) - source: US CDC
-            dur_inf = ss.normal(loc=11),       # (days) - source: US CDC
+            dur_exp = ss.normal(loc=ss.days(8)),        # (days) - source: US CDC
+            dur_inf = ss.normal(loc=ss.days(11)),       # (days) - source: US CDC
             p_death = ss.bernoulli(p=0.005), # Probability of death
         )
         self.update_pars(pars=pars, **kwargs)
 
         # SIR are added automatically, here we add E
-        self.add_states(
-            ss.BoolArr('exposed'),
-            ss.FloatArr('ti_exposed'),
+        self.define_states(
+            ss.State('exposed', label='Exposed'),
+            ss.FloatArr('ti_exposed', label='Time of exposure'),
         )
 
         return
@@ -39,9 +39,9 @@ class Measles(SIR):
     def infectious(self):
         return self.infected | self.exposed
 
-    def update_pre(self):
+    def step_state(self):
         # Progress exposed -> infected
-        ti = self.sim.ti
+        ti = self.ti
         infected = (self.exposed & (self.ti_infected <= ti)).uids
         self.exposed[infected] = False
         self.infected[infected] = True
@@ -60,8 +60,7 @@ class Measles(SIR):
     def set_prognoses(self, uids, source_uids=None):
         """ Set prognoses for those who get infected """
         super().set_prognoses(uids, source_uids)
-        ti = self.sim.ti
-        dt = self.sim.dt
+        ti = self.ti
 
         self.susceptible[uids] = False
         self.exposed[uids] = True
@@ -70,7 +69,7 @@ class Measles(SIR):
         p = self.pars
 
         # Determine when exposed become infected
-        self.ti_infected[uids] = ti + p.dur_exp.rvs(uids) / dt
+        self.ti_infected[uids] = ti + p.dur_exp.rvs(uids)
 
         # Sample duration of infection, being careful to only sample from the
         # distribution once per timestep.
@@ -80,12 +79,12 @@ class Measles(SIR):
         will_die = p.p_death.rvs(uids)
         dead_uids = uids[will_die]
         rec_uids = uids[~will_die]
-        self.ti_dead[dead_uids] = self.ti_infected[dead_uids] + dur_inf[will_die] / dt
-        self.ti_recovered[rec_uids] = self.ti_infected[rec_uids] + dur_inf[~will_die] / dt
+        self.ti_dead[dead_uids] = self.ti_infected[dead_uids] + dur_inf[will_die]
+        self.ti_recovered[rec_uids] = self.ti_infected[rec_uids] + dur_inf[~will_die]
 
         return
 
-    def update_death(self, uids):
+    def step_die(self, uids):
         # Reset infected/recovered flags for dead agents
         for state in ['susceptible', 'exposed', 'infected', 'recovered']:
             self.statesdict[state][uids] = False
diff --git a/starsim/diseases/ncd.py b/starsim/diseases/ncd.py
index daa9bd2..5f32867 100644
--- a/starsim/diseases/ncd.py
+++ b/starsim/diseases/ncd.py
@@ -19,18 +19,18 @@ class NCD(ss.Disease):
     """
     def __init__(self, pars=None, **kwargs):
         super().__init__()
-        self.default_pars(
+        self.define_pars(
             initial_risk = ss.bernoulli(p=0.3), # Initial prevalence of risk factors
-            dur_risk = ss.expon(scale=10),
-            prognosis = ss.weibull(c=2, scale=5), # Time in years between first becoming affected and death
+            dur_risk = ss.expon(scale=ss.dur(10)),
+            prognosis = ss.weibull(c=ss.years(2), scale=5), # Time in years between first becoming affected and death
         )
         self.update_pars(pars=pars, **kwargs)
-        
-        self.add_states(
-            ss.BoolArr('at_risk'),
-            ss.BoolArr('affected'),
-            ss.FloatArr('ti_affected'),
-            ss.FloatArr('ti_dead'),
+
+        self.define_states(
+            ss.State('at_risk', label='At risk'),
+            ss.State('affected', label='Affected'),
+            ss.FloatArr('ti_affected', label='Time of becoming affected'),
+            ss.FloatArr('ti_dead', label='Time of death'),
         )
         return
 
@@ -48,23 +48,24 @@ class NCD(ss.Disease):
         super().init_post()
         initial_risk = self.pars['initial_risk'].filter()
         self.at_risk[initial_risk] = True
-        self.ti_affected[initial_risk] = self.sim.ti + sc.randround(self.pars['dur_risk'].rvs(initial_risk) / self.sim.dt)
+        self.ti_affected[initial_risk] = self.ti + sc.randround(self.pars['dur_risk'].rvs(initial_risk))
         return initial_risk
 
-    def update_pre(self):
-        ti = self.sim.ti
+    def step_state(self):
+        ti = self.ti
         deaths = (self.ti_dead == ti).uids
         self.sim.people.request_death(deaths)
-        self.log.add_data(deaths, died=True)
+        if self.pars.log:
+            self.log.add_data(deaths, died=True)
         self.results.new_deaths[ti] = len(deaths) # Log deaths attributable to this module
         return
 
-    def make_new_cases(self):
-        ti = self.sim.ti
+    def step(self):
+        ti = self.ti
         new_cases = (self.ti_affected == ti).uids
         self.affected[new_cases] = True
         prog_years = self.pars.prognosis.rvs(new_cases)
-        self.ti_dead[new_cases] = ti + sc.randround(prog_years / self.sim.dt)
+        self.ti_dead[new_cases] = ti + sc.randround(prog_years / self.t.dt) # TODO: update to allow non-year units
         super().set_prognoses(new_cases)
         return new_cases
 
@@ -73,17 +74,16 @@ class NCD(ss.Disease):
         Initialize results
         """
         super().init_results()
-        npts = self.sim.npts
-        self.results += [
-            ss.Result(self.name, 'n_not_at_risk', npts, dtype=int),
-            ss.Result(self.name, 'prevalence', npts, dtype=float),
-            ss.Result(self.name, 'new_deaths', npts, dtype=int),
-        ]
+        self.define_results(
+            ss.Result('n_not_at_risk', dtype=int,   label='Not at risk'),
+            ss.Result('prevalence',    dtype=float, label='Prevalence'),
+            ss.Result('new_deaths',    dtype=int,   label='Deaths'),
+        )
         return
 
     def update_results(self):
         super().update_results()
-        ti = self.sim.ti
+        ti = self.ti
         self.results.n_not_at_risk[ti] = np.count_nonzero(self.not_at_risk)
         self.results.prevalence[ti]    = np.count_nonzero(self.affected)/len(self.sim.people)
         self.results.new_deaths[ti]    = np.count_nonzero(self.ti_dead == ti)
diff --git a/starsim/diseases/sir.py b/starsim/diseases/sir.py
index a21c40c..ad938a1 100644
--- a/starsim/diseases/sir.py
+++ b/starsim/diseases/sir.py
@@ -3,7 +3,8 @@ Define SIR and SIS disease modules
 """
 
 import numpy as np
-import matplotlib.pyplot as pl
+import sciris as sc
+import matplotlib.pyplot as plt
 import starsim as ss
 
 
@@ -19,22 +20,27 @@ class SIR(ss.Infection):
     """
     def __init__(self, pars=None, **kwargs):
         super().__init__()
-        self.default_pars(
-            beta = 0.1,
+        self.define_pars(
+            beta = ss.beta(0.1),
             init_prev = ss.bernoulli(p=0.01),
-            dur_inf = ss.lognorm_ex(mean=6),
+            dur_inf = ss.lognorm_ex(mean=ss.dur(6)),
             p_death = ss.bernoulli(p=0.01),
         )
         self.update_pars(pars, **kwargs)
 
-        self.add_states(
-            ss.BoolArr('recovered'),
-            ss.FloatArr('ti_recovered'),
-            ss.FloatArr('ti_dead'),
+        self.define_states(
+            ss.State('susceptible', default=True, label='Susceptible'),
+            ss.State('infected', label='Infectious'),
+            ss.State('recovered', label='Recovered'),
+            ss.FloatArr('ti_infected', label='Time of infection'),
+            ss.FloatArr('ti_recovered', label='Time of recovery'),
+            ss.FloatArr('ti_dead', label='Time of death'),
+            ss.FloatArr('rel_sus', default=1.0, label='Relative susceptibility'),
+            ss.FloatArr('rel_trans', default=1.0, label='Relative transmission'),
         )
         return
 
-    def update_pre(self):
+    def step_state(self):
         # Progress infectious -> recovered
         sim = self.sim
         recovered = (self.infected & (self.ti_recovered <= sim.ti)).uids
@@ -47,11 +53,10 @@ class SIR(ss.Infection):
             sim.people.request_death(deaths)
         return
 
-    def set_prognoses(self, uids, source_uids=None):
+    def set_prognoses(self, uids, sources=None):
         """ Set prognoses """
-        super().set_prognoses(uids, source_uids)
-        ti = self.sim.ti
-        dt = self.sim.dt
+        super().set_prognoses(uids, sources)
+        ti = self.t.ti
         self.susceptible[uids] = False
         self.infected[uids] = True
         self.ti_infected[uids] = ti
@@ -66,25 +71,32 @@ class SIR(ss.Infection):
         will_die = p.p_death.rvs(uids)
         dead_uids = uids[will_die]
         rec_uids = uids[~will_die]
-        self.ti_dead[dead_uids] = ti + dur_inf[will_die] / dt # Consider rand round, but not CRN safe
-        self.ti_recovered[rec_uids] = ti + dur_inf[~will_die] / dt
+        self.ti_dead[dead_uids] = ti + dur_inf[will_die] # Consider rand round, but not CRN safe
+        self.ti_recovered[rec_uids] = ti + dur_inf[~will_die]
         return
 
-    def update_death(self, uids):
+    def step_die(self, uids):
         """ Reset infected/recovered flags for dead agents """
         self.susceptible[uids] = False
         self.infected[uids] = False
         self.recovered[uids] = False
         return
 
-    def plot(self):
+    def plot(self, **kwargs):
         """ Default plot for SIR model """
-        fig = pl.figure()
-        for rkey in ['susceptible', 'infected', 'recovered']:
-            pl.plot(self.results['n_'+rkey], label=rkey.title())
-        pl.legend()
-        return fig
-    
+        fig = plt.figure()
+        kw = sc.mergedicts(dict(lw=2, alpha=0.8), kwargs)
+        res = self.results
+        for rkey in ['n_susceptible', 'n_infected', 'n_recovered']:
+            plt.plot(res.timevec, res[rkey], label=res[rkey].label, **kw)
+        plt.legend(frameon=False)
+        plt.xlabel('Time')
+        plt.ylabel('Number of people')
+        plt.ylim(bottom=0)
+        sc.boxoff()
+        sc.commaticks()
+        return ss.return_fig(fig)
+
 
 class SIS(ss.Infection):
     """
@@ -96,70 +108,79 @@ class SIS(ss.Infection):
     """
     def __init__(self, pars=None, *args, **kwargs):
         super().__init__()
-        self.default_pars(
-            beta = 0.05,
+        self.define_pars(
+            beta = ss.beta(0.05),
             init_prev = ss.bernoulli(p=0.01),
-            dur_inf = ss.lognorm_ex(mean=10),
-            waning = 0.05,
+            dur_inf = ss.lognorm_ex(mean=ss.dur(10)),
+            waning = ss.rate(0.05),
             imm_boost = 1.0,
         )
         self.update_pars(pars=pars, *args, **kwargs)
 
-        self.add_states(
+        self.define_states(
             ss.FloatArr('ti_recovered'),
             ss.FloatArr('immunity', default=0.0),
         )
         return
 
-    def update_pre(self):
+    def step_state(self):
         """ Progress infectious -> recovered """
-        recovered = (self.infected & (self.ti_recovered <= self.sim.ti)).uids
+        recovered = (self.infected & (self.ti_recovered <= self.ti)).uids
         self.infected[recovered] = False
         self.susceptible[recovered] = True
         self.update_immunity()
         return
-    
+
     def update_immunity(self):
         has_imm = (self.immunity > 0).uids
-        self.immunity[has_imm] = (self.immunity[has_imm])*(1 - self.pars.waning*self.sim.dt)
+        self.immunity[has_imm] = (self.immunity[has_imm])*(1 - self.pars.waning)
         self.rel_sus[has_imm] = np.maximum(0, 1 - self.immunity[has_imm])
         return
 
-    def set_prognoses(self, uids, source_uids=None):
+    def set_prognoses(self, uids, sources=None):
         """ Set prognoses """
-        super().set_prognoses(uids, source_uids)
+        super().set_prognoses(uids, sources)
         self.susceptible[uids] = False
         self.infected[uids] = True
-        self.ti_infected[uids] = self.sim.ti
+        self.ti_infected[uids] = self.ti
         self.immunity[uids] += self.pars.imm_boost
 
         # Sample duration of infection
         dur_inf = self.pars.dur_inf.rvs(uids)
 
         # Determine when people recover
-        self.ti_recovered[uids] = self.sim.ti + dur_inf / self.sim.dt
+        self.ti_recovered[uids] = self.ti + dur_inf
 
         return
-    
+
     def init_results(self):
         """ Initialize results """
         super().init_results()
-        self.results += ss.Result(self.name, 'rel_sus', self.sim.npts, dtype=float)
+        self.define_results(
+            ss.Result('rel_sus', dtype=float, label='Relative susceptibility')
+        )
         return
 
     def update_results(self):
         """ Store the population immunity (susceptibility) """
         super().update_results()
-        self.results['rel_sus'][self.sim.ti] = self.rel_sus.mean()
-        return 
+        self.results['rel_sus'][self.ti] = self.rel_sus.mean()
+        return
 
-    def plot(self):
+    def plot(self, **kwargs):
         """ Default plot for SIS model """
-        fig = pl.figure()
-        for rkey in ['susceptible', 'infected']:
-            pl.plot(self.results['n_'+rkey], label=rkey.title())
-        pl.legend()
-        return fig
+        fig = plt.figure()
+        kw = sc.mergedicts(dict(lw=2, alpha=0.8), kwargs)
+        res = self.results
+        for rkey in ['n_susceptible', 'n_infected']:
+            plt.plot(res.timevec, res[rkey], label=res[rkey].label, **kw)
+        plt.legend(frameon=False)
+        plt.xlabel('Time')
+        plt.ylabel('Number of people')
+        plt.ylim(bottom=0)
+        sc.boxoff()
+        sc.commaticks()
+        return ss.return_fig(fig)
 
 
 # %% Interventions
@@ -169,27 +190,27 @@ __all__ += ['sir_vaccine']
 class sir_vaccine(ss.Vx):
     """
     Create a vaccine product that affects the probability of infection.
-    
-    The vaccine can be either "leaky", in which everyone who receives the vaccine 
-    receives the same amount of protection (specified by the efficacy parameter) 
+
+    The vaccine can be either "leaky", in which everyone who receives the vaccine
+    receives the same amount of protection (specified by the efficacy parameter)
     each time they are exposed to an infection. The alternative (leaky=False) is
     that the efficacy is the probability that the vaccine "takes", in which case
     that person is 100% protected (and the remaining people are 0% protected).
-    
+
     Args:
         efficacy (float): efficacy of the vaccine (0<=efficacy<=1)
         leaky (bool): see above
     """
     def __init__(self, pars=None, *args, **kwargs):
         super().__init__()
-        self.default_pars(
+        self.define_pars(
             efficacy = 0.9,
             leaky = True
         )
         self.update_pars(pars, **kwargs)
         return
 
-    def administer(self, people, uids):        
+    def administer(self, people, uids):
         if self.pars.leaky:
             people.sir.rel_sus[uids] *= 1-self.pars.efficacy
         else:
diff --git a/starsim/diseases/syphilis.py b/starsim/diseases/syphilis.py
index b75b80b..c7b503c 100644
--- a/starsim/diseases/syphilis.py
+++ b/starsim/diseases/syphilis.py
@@ -4,8 +4,8 @@ Define default syphilis disease module
 
 import numpy as np
 import sciris as sc
-from sciris import randround as rr # Since used frequently
 import starsim as ss
+rr = sc.randround # Since used frequently
 
 
 __all__ = ['Syphilis']
@@ -15,17 +15,17 @@ class Syphilis(ss.Infection):
     def __init__(self, pars=None, **kwargs):
         # Parameters
         super().__init__()
-        self.default_pars(
+        self.define_pars(
             # Initial conditions
             beta = 1.0, # Placeholder
             init_prev = ss.bernoulli(p=0.03),
-            
+
             # Adult syphilis natural history, all specified in years
-            dur_exposed = ss.lognorm_ex(mean=1 / 12, stdev=1 / 36),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
-            dur_primary = ss.lognorm_ex(mean=1.5 / 12, stdev=1 / 36),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
+            dur_exposed = ss.lognorm_ex(mean=1 / 12, std=1 / 36),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
+            dur_primary = ss.lognorm_ex(mean=1.5 / 12, std=1 / 36),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
             dur_secondary = ss.normal(loc=3.6 / 12, scale=1.5 / 12),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
-            dur_latent_temp = ss.lognorm_ex(mean=1, stdev=6 / 12),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
-            dur_latent_long = ss.lognorm_ex(mean=20, stdev=8),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
+            dur_latent_temp = ss.lognorm_ex(mean=1, std=6 / 12),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
+            dur_latent_long = ss.lognorm_ex(mean=20, std=8),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
             p_latent_temp = ss.bernoulli(p=0.25),  # https://pubmed.ncbi.nlm.nih.gov/9101629/
             p_tertiary = ss.bernoulli(p=0.35),  # https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4917057/
 
@@ -54,30 +54,30 @@ class Syphilis(ss.Infection):
         )
         self.update_pars(pars, **kwargs)
 
-        self.add_states(
+        self.define_states(
             # Adult syphilis states
-            ss.BoolArr('exposed'),  # AKA incubating. Free of symptoms, not transmissible
-            ss.BoolArr('primary'),  # Primary chancres
-            ss.BoolArr('secondary'),  # Inclusive of those who may still have primary chancres
-            ss.BoolArr('latent_temp'),  # Relapses to secondary (~1y)
-            ss.BoolArr('latent_long'),  # Can progress to tertiary or remain here
-            ss.BoolArr('tertiary'),  # Includes complications (cardio/neuro/disfigurement)
-            ss.BoolArr('immune'),  # After effective treatment people may acquire temp immunity
-            ss.BoolArr('ever_exposed'),  # Anyone ever exposed - stays true after treatment
-            ss.BoolArr('congenital'),  # Congenital syphilis states
-    
+            ss.State('exposed', label='Exposed'),  # AKA incubating. Free of symptoms, not transmissible
+            ss.State('primary', label='Primary'),  # Primary chancres
+            ss.State('secondary', label="Secondary"),  # Inclusive of those who may still have primary chancres
+            ss.State('latent_temp', label="Latent temporary"),  # Relapses to secondary (~1y)
+            ss.State('latent_long', label="Latent long"),  # Can progress to tertiary or remain here
+            ss.State('tertiary', label="Tertiary"),  # Includes complications (cardio/neuro/disfigurement)
+            ss.State('immune', label="Immune"),  # After effective treatment people may acquire temp immunity
+            ss.State('ever_exposed', label="Ever exposed"),  # Anyone ever exposed - stays true after treatment
+            ss.State('congenital', label="Congenital"),  # Congenital syphilis states
+
             # Timestep of state changes
-            ss.FloatArr('ti_exposed'),
-            ss.FloatArr('ti_primary'),
-            ss.FloatArr('ti_secondary'),
-            ss.FloatArr('ti_latent_temp'),
-            ss.FloatArr('ti_latent_long'),
-            ss.FloatArr('ti_tertiary'),
-            ss.FloatArr('ti_immune'),
-            ss.FloatArr('ti_miscarriage'),
-            ss.FloatArr('ti_nnd'),
-            ss.FloatArr('ti_stillborn'),
-            ss.FloatArr('ti_congenital'),
+            ss.FloatArr('ti_exposed', label='Time of exposure'),
+            ss.FloatArr('ti_primary', label='Time of primary'),
+            ss.FloatArr('ti_secondary', label='Time of secondary'),
+            ss.FloatArr('ti_latent_temp', label='Time of latent_temp'),
+            ss.FloatArr('ti_latent_long', label='Time of latent_long'),
+            ss.FloatArr('ti_tertiary', label='Time of tertiary'),
+            ss.FloatArr('ti_immune', label='Time of immunity'),
+            ss.FloatArr('ti_miscarriage', label='Time of miscarriage'),
+            ss.FloatArr('ti_nnd', label='Time of neonatal death'),
+            ss.FloatArr('ti_stillborn', label='Time of stillborn'),
+            ss.FloatArr('ti_congenital', label='Time of congenital syphilis'),
         )
 
         return
@@ -110,19 +110,18 @@ class Syphilis(ss.Infection):
     def init_results(self):
         """ Initialize results """
         super().init_results()
-        npts = self.sim.npts
-        self.results += [
-            ss.Result(self.name, 'new_nnds',       npts, dtype=int, scale=True),
-            ss.Result(self.name, 'new_stillborns', npts, dtype=int, scale=True),
-            ss.Result(self.name, 'new_congenital', npts, dtype=int, scale=True),
-        ]
+        self.define_results(
+            ss.Result('new_nnds',       dtype=int, label='New neonatal deaths'),
+            ss.Result('new_stillborns', dtype=int, label='New stillborns'),
+            ss.Result('new_congenital', dtype=int, label='New congenital syphilis'),
+        )
         return
 
-    def update_pre(self):
+    def step_state(self):
         """ Updates prior to interventions """
 
         # Primary
-        ti = self.sim.ti
+        ti = self.ti
         primary = self.exposed & (self.ti_primary <= ti)
         self.primary[primary] = True
         self.exposed[primary] = False
@@ -136,10 +135,6 @@ class Syphilis(ss.Infection):
             self.set_secondary_prognoses(secondary_from_primary)
             self.rel_trans[secondary_from_primary] = self.pars.rel_trans['secondary']
 
-        # Hack to reset the MultiRNGs in set_secondary_prognoses so that they can be called again in this timestep. TODO: Refactor
-        self.pars.p_latent_temp.jump(ti+1)
-        self.pars.dur_secondary.jump(ti+1)
-
         # Secondary reactivation from latent
         secondary_from_latent = (self.latent_temp & (self.ti_secondary <= ti)).uids
         if len(secondary_from_latent) > 0:
@@ -185,7 +180,7 @@ class Syphilis(ss.Infection):
 
     def update_results(self):
         super().update_results()
-        ti = self.sim.ti
+        ti = self.ti
         self.results.new_nnds[ti]       = np.count_nonzero(self.ti_nnd == ti)
         self.results.new_stillborns[ti] = np.count_nonzero(self.ti_stillborn == ti)
         self.results.new_congenital[ti] = np.count_nonzero(self.ti_congenital == ti)
@@ -195,10 +190,8 @@ class Syphilis(ss.Infection):
         """
         Set initial prognoses for adults newly infected with syphilis
         """
-        super().set_prognoses(uids, source_uids)
-        
-        ti = self.sim.ti
-        dt = self.sim.dt
+
+        ti = self.ti
 
         self.susceptible[uids] = False
         self.ever_exposed[uids] = True
@@ -210,17 +203,16 @@ class Syphilis(ss.Infection):
         # Set future dates and probabilities
         # Exposed to primary
         dur_exposed = self.pars.dur_exposed.rvs(uids)
-        self.ti_primary[uids] = ti + rr(dur_exposed / dt)
+        self.ti_primary[uids] = ti + rr(dur_exposed)
 
         # Primary to secondary
         dur_primary = self.pars.dur_primary.rvs(uids)
-        self.ti_secondary[uids] = self.ti_primary[uids] + rr(dur_primary / dt)
+        self.ti_secondary[uids] = self.ti_primary[uids] + rr(dur_primary)
         return
 
     def set_secondary_prognoses(self, uids):
         """ Set prognoses for people who have just progressed to secondary infection """
 
-        dt = self.sim.dt
         dur_secondary = self.pars.dur_secondary.rvs(uids)
 
         # Secondary to latent_temp or latent_long
@@ -229,42 +221,41 @@ class Syphilis(ss.Infection):
         latent_long_uids = uids[~latent_temp]
 
         dur_secondary_temp = dur_secondary[latent_temp]
-        self.ti_latent_temp[latent_temp_uids] = self.ti_secondary[latent_temp_uids] + rr(dur_secondary_temp / dt)
+        self.ti_latent_temp[latent_temp_uids] = self.ti_secondary[latent_temp_uids] + rr(dur_secondary_temp)
 
         dur_secondary_long = dur_secondary[~latent_temp]
-        self.ti_latent_long[latent_long_uids] = self.ti_secondary[latent_long_uids] + rr(dur_secondary_long / dt)
+        self.ti_latent_long[latent_long_uids] = self.ti_secondary[latent_long_uids] + rr(dur_secondary_long)
 
         return
 
     def set_latent_temp_prognoses(self, uids):
         # Primary to secondary
         dur_latent_temp = self.pars.dur_latent_temp.rvs(uids)
-        self.ti_secondary[uids] = self.ti_latent_temp[uids] + rr(dur_latent_temp / self.sim.dt)
+        self.ti_secondary[uids] = self.ti_latent_temp[uids] + rr(dur_latent_temp)
         return
 
     def set_latent_long_prognoses(self, uids):
-        dt = self.sim.dt
         dur_latent = self.pars.dur_latent_long.rvs(uids)
 
         # Primary to secondary
         dur_latent_long = dur_latent
-        self.ti_secondary[uids] = self.ti_latent_temp[uids] + rr(dur_latent_long / dt)
+        self.ti_secondary[uids] = self.ti_latent_temp[uids] + rr(dur_latent_long)
 
         # Latent_long to tertiary
         tertiary = self.pars.p_tertiary.rvs(uids)
         tertiary_uids = uids[tertiary]
-        self.ti_tertiary[tertiary_uids] = self.ti_latent_long[tertiary_uids] + rr(dur_latent_long[tertiary] / dt)
+        self.ti_tertiary[tertiary_uids] = self.ti_latent_long[tertiary_uids] + rr(dur_latent_long[tertiary])
 
         return
 
-    def set_congenital(self, uids, source_uids=None):
+    def set_congenital(self, uids, sources=None):
         """ Natural history of syphilis for congenital infection """
         sim = self.sim
 
         # Determine outcomes
         for state in ['active', 'latent']:
 
-            source_state_inds = getattr(self, state)[source_uids].nonzero()[0]
+            source_state_inds = getattr(self, state)[sources].nonzero()[0]
             state_uids = uids[source_state_inds]
 
             if len(state_uids) > 0:
@@ -275,12 +266,13 @@ class Syphilis(ss.Infection):
                 time_to_birth = -sim.people.age.raw # TODO: make nicer
 
                 # Schedule events
+                ratio = ss.time_ratio(unit1='year', dt1=1.0, unit2=self.t.unit, dt2=self.t.dt) # TODO: think about simplifying
                 for oi, outcome in enumerate(self.pars.birth_outcome_keys):
                     o_uids = state_uids[assigned_outcomes == oi]
                     if len(o_uids) > 0:
                         ti_outcome = f'ti_{outcome}'
                         vals = getattr(self, ti_outcome)
-                        vals[o_uids] = sim.ti + rr(time_to_birth[o_uids] / sim.dt)
+                        vals[o_uids] = sim.ti + rr(time_to_birth[o_uids] * ratio)
                         setattr(self, ti_outcome, vals)
 
         return
@@ -334,23 +326,24 @@ class syph_screening(ss.routine_screening):
         else:
             return products[product]
 
-    def check_eligibility(self, sim):
+    def check_eligibility(self):
         """
         Return an array of indices of agents eligible for screening at time t, i.e. sexually active
         females in age range, plus any additional user-defined eligibility
         """
+        sim = self.sim
         if self.eligibility is not None:
             is_eligible = self.eligibility(sim)
         else:
             is_eligible = sim.people.auids  # Probably not required
         return is_eligible
 
-    def init_pre(self, sim):
-        super().init_pre(sim)
-        self.results += [
-            ss.Result('syphilis', 'n_screened', sim.npts, dtype=int, scale=True),
-            ss.Result('syphilis', 'n_dx', sim.npts, dtype=int, scale=True),
-        ]
+    def init_results(self):
+        super().init_results()
+        self.define_results(
+            ss.Result('n_screened', dtype=int, label='Number screened'),
+            ss.Result('n_dx',       dtype=int, label='Number diagnosed'),
+        )
         return
 
 
@@ -369,12 +362,15 @@ class syph_treatment(ss.treat_num):
         else:
             return products[product]
 
-    def init_pre(self, sim):
-        super().init_pre(sim)
-        self.results += ss.Result('syphilis', 'n_tx', sim.npts, dtype=int, scale=True)
+    def init_results(self):
+        super().init_results()
+        self.define_results(
+            ss.Result('n_tx', dtype=int, label='Number treated')
+        )
         return
 
-    def apply(self, sim):
-        treat_inds = super().apply(sim)
+    def step(self):
+        sim = self.sim
+        treat_inds = super().step()
         sim.people.syphilis.infected[treat_inds] = False
         self.results['n_tx'][sim.ti] += len(treat_inds)
diff --git a/starsim/distributions.py b/starsim/distributions.py
index 2d65c0a..759fd0e 100644
--- a/starsim/distributions.py
+++ b/starsim/distributions.py
@@ -1,49 +1,39 @@
 """
 Define random-number-safe distributions.
 """
-
-import numpy as np
 import sciris as sc
+import numpy as np
+import numba as nb
 import scipy.stats as sps
 import starsim as ss
-import matplotlib.pyplot as pl
+import matplotlib.pyplot as plt
 
-__all__ = ['find_dists', 'link_dists', 'make_dist', 'dist_list', 'Dists', 'Dist']
+__all__ = ['link_dists', 'make_dist', 'dist_list', 'Dists', 'Dist']
 
 
-def str2int(string, modulo=1_000_000):
+def str2int(string, modulo=1_000_000_000):
     """
-    Convert a string to an int
-    
-    Cannot use Python's built-in hash() since it's randomized for strings, but
-    this is almost as fast (and 5x faster than hashlib).
-    """
-    return int.from_bytes(string.encode(), byteorder='big') % modulo
-
+    Convert a string to an int to use as a random seed; not for the user
 
-def find_dists(obj, verbose=False, **kwargs):
-    """ Find all Dist objects in a parent object """
-    out = sc.objdict()
-    tree = sc.iterobj(obj, depthfirst=False, flatten=True, **kwargs)
-    if verbose: print(f'Found {len(tree)} objects')
-    for trace,val in tree.items():
-        if isinstance(val, Dist):
-            out[trace] = val
-            if verbose: print(f'  {trace} is a dist ({len(out)})')
-    return out
+    Cannot use Python's built-in hash() since it's randomized for strings. Hashlib
+    (sc.sha) is 5x slower than int.from_bytes(string.encode(), byteorder='big'), but should
+    only add a couple milliseconds to a typical sim.
+    """
+    integer = sc.sha(string, asint=True) # Hash the string to an integer
+    seed = integer % modulo # Ensure a user-friendly representation user-friendly
+    return seed
 
 
-def link_dists(obj, sim, module=None, overwrite=False, init=False, **kwargs):
-    """ Link distributions to the sim and the module; used in module.initialize() and people.initialize() """
+def link_dists(obj, sim, module=None, overwrite=False, init=False, **kwargs): # TODO: actually link the distributions to the modules! Currently this only does the opposite, but should have mod.dists as well
+    """ Link distributions to the sim and the module; used in module.init() and people.init() """
     if module is None and isinstance(obj, ss.Module):
         module = obj
-    dists = ss.find_dists(obj, **kwargs) # Important that this comes first, before the sim is linked to the dist!
-    for key,val in dists.items():
-        if isinstance(val, ss.Dist):
-            val.link_sim(sim, overwrite=overwrite)
-            val.link_module(module, overwrite=overwrite)
-            if init: # Usually this is false since usually these are initialized centrally by the sim
-                val.initialize()
+    dists = sc.search(obj, type=Dist, **kwargs)
+    for dist in dists.values():
+        dist.link_sim(sim, overwrite=overwrite)
+        dist.link_module(module, overwrite=overwrite)
+        if init: # Usually this is false since usually these are initialized centrally by the sim
+            dist.init()
     return
 
 
@@ -75,10 +65,10 @@ class Dists(sc.prettyobj):
         self.initialized = False
         return
 
-    def initialize(self, obj=None, base_seed=None, sim=None, force=False):
+    def init(self, obj=None, base_seed=None, sim=None, force=False):
         """
         Set the base seed, find and initialize all distributions in an object
-        
+
         In practice, the object is usually a Sim, but can be anything.
         """
         if base_seed:
@@ -92,18 +82,28 @@ class Dists(sc.prettyobj):
         if obj is None:
             errormsg = 'Must supply a container that contains one or more Dist objects, typically the sim'
             raise ValueError(errormsg)
-        self.dists = find_dists(obj)
+
+        # Do not look for distributions in the people states, since they shadow the "real" states
+        skip = dict(
+            ids=id(sim.people._states) if sim is not None else None,
+            keys='module',
+        )
+
+        # Find and initialize the distributions
+        self.dists = sc.search(obj, type=Dist, skip=skip, flatten=True)
         for trace,dist in self.dists.items():
             if not dist.initialized or force:
-                dist.initialize(trace=trace, seed=base_seed, sim=sim, force=force)
+                dist.init(trace=trace, seed=base_seed, sim=sim, force=force)
+
+        # Confirm the seeds are unique
         self.check_seeds()
         self.initialized = True
         return self
-    
+
     def check_seeds(self):
         """ Check that no two distributions share the same seed """
         checked = dict()
-        for trace,dist in self.dists.items():
+        for dist in self.dists.values():
             seed = dist.seed
             if seed in checked.keys():
                 raise DistSeedRepeatError(checked[seed], dist)
@@ -111,8 +111,8 @@ class Dists(sc.prettyobj):
                 checked[seed] = dist
         return
 
-    def jump(self, to=None, delta=1):
-        """ Advance all RNGs, e.g. to timestep "to", by jumping """
+    def jump(self, to=None, delta=1, force=False):
+        """ Advance all RNGs, e.g. to call "to", by jumping """
         out = sc.autolist()
 
         # Do not jump if centralized
@@ -120,7 +120,24 @@ class Dists(sc.prettyobj):
             return out
 
         for dist in self.dists.values():
-            out += dist.jump(to=to, delta=delta)
+            out += dist.jump(to=to, delta=delta, force=force)
+        return out
+
+    def jump_dt(self, ti=None, force=False): # Could this be simplified with jump(), or nice to have the parallel with Dist?
+        """
+        Advance all RNGs to the next timestep
+
+        Args:
+            ti (int): if specified, jump to this timestep (default: current sim timestep)
+        """
+        out = sc.autolist()
+
+        # Do not jump if centralized
+        if ss.options._centralized:
+            return out
+
+        for dist in self.dists.values():
+            out += dist.jump_dt(ti=ti, force=force)
         return out
 
     def reset(self):
@@ -130,22 +147,34 @@ class Dists(sc.prettyobj):
             out += dist.reset()
         return out
 
+    def copy_to_module(self, module):
+        """ Copy the Sim's Dists object to the specified module """
+        matches = {key:dist for key,dist in self.dists.items() if id(dist.module) == id(module)} # Find which dists belong to this module
+        if len(matches):
+            new = Dists() # Create an empty Dists object
+            new.__dict__.update(self.__dict__) # Shallow-copy all values over
+            new.obj = module # Replace the module
+            new.dists = sc.objdict(matches) # Replace the dists with a shallow copy the matching dists
+            module.dists = new # Copy to the module
+        else:
+            new = None
+        return new
 
 class Dist:
     """
     Base class for tracking one random number generator associated with one distribution,
     i.e. one decision per timestep.
-    
+
     See ss.dist_list for a full list of supported distributions.
-    
+
     Although it's possible in theory to define a custom distribution (i.e., not
     one from NumPy or SciPy), in practice this is difficult. The distribution needs
-    to have both a way to return random variables (easy), as well as the probability
+    to have both a way to return random variates (easy), as well as the probability
     point function (inverse CDF). In addition, the distribution must be able to
     take a NumPy RNG as its bit generator. It's easier to just use a default Dist
-    (e.g., ss.random()), and then take its output as input (i.e., quantiles) for 
+    (e.g., ss.random()), and then take its output as input (i.e., quantiles) for
     whatever custom distribution you want to create.
-    
+
     Args:
         dist (rv_generic): optional; a scipy.stats distribution (frozen or not) to get the ppf from
         distname (str): the name for this class of distribution (e.g. "uniform")
@@ -157,13 +186,13 @@ class Dist:
         sim (Sim): usually determined on initialization; the sim to use as input to callable parameters
         module (Module): usually determined on initialization; the module to use as input to callable parameters
         kwargs (dict): parameters of the distribution
-        
+
     **Examples**::
-        
+
         dist = ss.Dist(sps.norm, loc=3)
         dist.rvs(10) # Return 10 normally distributed random numbers
     """
-    def __init__(self, dist=None, distname=None, name=None, seed=None, offset=None, 
+    def __init__(self, dist=None, distname=None, name=None, seed=None, offset=None,
                  strict=True, auto=True, sim=None, module=None, debug=False, **kwargs):
         # If a string is provided as "dist" but there's no distname, swap the dist and the distname
         if isinstance(dist, str) and distname is None:
@@ -172,7 +201,7 @@ class Dist:
         self.dist = dist # The type of distribution
         self.distname = distname
         self.name = name
-        self.pars = sc.dictobj(kwargs) # The user-defined kwargs
+        self.pars = sc.objdict(kwargs) # The user-defined kwargs
         self.seed = seed # Usually determined once added to the container
         self.offset = offset
         self.module = module
@@ -181,8 +210,8 @@ class Dist:
         self.strict = strict
         self.auto = auto
         self.debug = debug
-        
-        # Auto-generated 
+
+        # Auto-generated
         self.rvs_func = None # The default function to call in make_rvs() to generate the random numbers
         self.dynamic_pars = None # Whether or not the distribution has array or callable parameters
         self._pars = None # Validated and transformed (if necessary) parameters
@@ -190,8 +219,9 @@ class Dist:
         self._size = None # Internal variable to keep track of actual number of random variates asked for
         self._uids = None # Internal variable to track currently-in-use UIDs
         self._slots = None # Internal variable to track currently-in-use slots
-        
+
         # History and random state
+        self.dt_jump_size = 1000 # How much to advance the RNG for each timestep (must be larger than the number times dist is called per timestep)
         self.rng = None # The actual RNG generator for generating random numbers
         self.trace = None # The path of this object within the parent
         self.ind = 0 # The index of the RNG (usually updated on each timestep)
@@ -200,32 +230,19 @@ class Dist:
         self.ready = True
         self.initialized = False
         if not strict: # Otherwise, wait for a sim
-            self.initialize()
+            self.init()
         return
-    
+
     def __repr__(self):
         """ Custom display to show state of object """
-        tracestr = '<no trace>' if self.trace is None else f"{self.trace}"
-        classname = self.__class__.__name__
-        diststr = ''
-        if classname == 'Dist':
-            if self.dist is not None:
-                try:
-                    diststr = f'dist={self.dist.name}, '
-                except:
-                    try: # What is wrong with you, SciPy -- after initialization, it moves here
-                        diststr = f'dist={self.dist.dist.name}, '
-                    except:
-                        diststr = f'dist={type(self.dist)}'
-            elif self.distname is not None:
-                diststr = f'dist={self.distname}, '
-        string = f'ss.{classname}({tracestr}, {diststr}pars={dict(self.pars)})'
+        j = sc.dictobj(self.to_json())
+        string = f'ss.{j.classname}({j.tracestr}, {j.diststr}pars={j.pars})'
         return string
-    
+
     def disp(self):
         """ Return full display of object """
         return sc.pr(self)
-    
+
     def show_state(self, output=False):
         """ Show the state of the object """
         keys = ['pars', 'trace', 'offset', 'seed', 'ind', 'called', 'ready', 'state_int']
@@ -238,11 +255,11 @@ class Dist:
         else:
             print(s)
             return
-    
+
     def __call__(self, n=1):
         """ Alias to self.rvs() """
         return self.rvs(n=n)
-    
+
     def set(self, *args, dist=None, **kwargs):
         """ Set (change) the distribution type, or one or more parameters of the distribution """
         if dist:
@@ -265,23 +282,23 @@ class Dist:
     def bitgen(self):
         try:    return self.rng._bit_generator
         except: return None
-    
+
     @property
     def state(self):
         """ Get the current state """
         try:    return self.bitgen.state
         except: return None
-        
+
     @property
     def state_int(self):
         """ Get the integer corresponding to the current state """
         try:    return self.state['state']['state']
         except: return None
-    
+
     def get_state(self):
         """ Return a copy of the state """
         return self.state.copy()
-    
+
     def make_history(self, reset=False):
         """ Store the current state in history """
         if reset:
@@ -292,12 +309,12 @@ class Dist:
     def reset(self, state=0):
         """
         Restore state, allowing the same numbers to be resampled
-        
+
         Use 0 for original state, -1 for most recent state.
-        
+
         **Example**::
-            
-            dist = ss.random(seed=5).initialize()
+
+            dist = ss.random(seed=5).init()
             r1 = dist(5)
             r2 = dist(5)
             dist.reset(-1)
@@ -314,37 +331,57 @@ class Dist:
         self.ready = True
         return self.state
 
-    def jump(self, to=None, delta=1):
+    def jump(self, to=None, delta=1, force=False):
         """ Advance the RNG, e.g. to timestep "to", by jumping """
-        
-        # Do not jump if centralized
+
+        # Do not jump if centralized # TODO: remove
         if ss.options._centralized:
             return self.state
 
+        # Validation
         jumps = to if (to is not None) else self.ind + delta
+        if self.ind >= jumps and not force:
+            errormsg = f'You tried to jump the distribution "{self}" to state {jumps}, but the ' \
+                       f'RNG state is already at state {self.ind}, meaning you will draw the same ' \
+                        'random numbers twice. If you are sure you want to do this, set force=True.'
+            raise DistSeedRepeatError(msg=errormsg)
+
+        # Do the jumping
         self.ind = jumps
         self.reset() # First reset back to the initial state (used in case of different numbers of calls)
         if jumps: # Seems to randomize state if jumps=0
             self.bitgen.state = self.bitgen.jumped(jumps=jumps).state # Now take "jumps" number of jumps
         return self.state
-    
-    def initialize(self, trace=None, seed=None, module=None, sim=None, slots=None, force=False):
+
+    def jump_dt(self, ti=None, force=False):
+        """
+        Automatically jump on the next value of dt
+
+        Args:
+            ti (int): if specified, jump to this timestep (default: current module timestep plus one)
+        """
+        if ti is None:
+            ti = self.module.t.ti + 1
+        to = self.dt_jump_size*ti
+        return self.jump(to=to, force=force)
+
+    def init(self, trace=None, seed=None, module=None, sim=None, slots=None, force=False):
         """ Calculate the starting seed and create the RNG """
-        
+
         if self.initialized is True and not force: # Don't warn if we have a partially initialized distribution
             msg = f'Distribution {self} is already initialized, use force=True if intentional'
             ss.warn(msg)
-        
+
         # Calculate the offset (starting seed)
         self.process_seed(trace, seed)
-        
+
         # Create the actual RNG
         if ss.options._centralized:
             self.rng = np.random.mtrand._rand # If _centralized, return the centralized numpy random number instance
         else:
             self.rng = np.random.default_rng(seed=self.seed)
         self.make_history(reset=True)
-        
+
         # Handle the sim, module, and slots
         self.link_sim(sim)
         self.link_module(module)
@@ -356,7 +393,7 @@ class Dist:
                 ss.warn(warnmsg)
         if slots is not None:
             self.slots = slots
-            
+
         # Initialize the distribution and finalize
         self.process_dist()
         self.process_pars(call=False)
@@ -371,21 +408,21 @@ class Dist:
         else:
             self.initialized = True
         return self
-    
+
     def link_sim(self, sim=None, overwrite=False):
-        """ Shortcut for linking the sim, only overwriting an existing one if overwrite=True """
+        """ Shortcut for linking the sim, only overwriting an existing one if overwrite=True; not for the user """
         if (not self.sim or overwrite) and sim is not None:
             self.sim = sim
         return
-    
+
     def link_module(self, module=None, overwrite=False):
         """ Shortcut for linking the module """
         if (not self.module or overwrite) and module is not None:
             self.module = module
         return
-    
+
     def process_seed(self, trace=None, seed=None):
-        """ Obtain the seed offset by hashing the path to this distribution; called automatically """
+        """ Obtain the seed offset by hashing the path to this distribution; not for the user """
         unique_name = trace or self.trace or self.name
         if unique_name:
             if not self.name:
@@ -396,34 +433,35 @@ class Dist:
             self.offset = self.offset or 0
         self.seed = self.offset + (seed or self.seed or 0)
         return
-    
+
     def process_dist(self):
-        """ Ensure the distribution works """
-        
+        """ Ensure the distribution works; not for the user """
+
         # Handle a SciPy distribution, if provided
         if self.dist is not None:
-            
+
             # Pull out parameters of an already-frozen distribution
             if isinstance(self.dist, sps._distn_infrastructure.rv_frozen):
                 if not self.initialized: # Don't do this more than once
                     self.pars = sc.dictobj(sc.mergedicts(self.pars, self.dist.kwds))
-            
+
             # Convert to a frozen distribution
             if isinstance(self.dist, sps._distn_infrastructure.rv_generic):
                 spars = self.process_pars(call=False)
-                self.dist = self.dist(**spars) 
-                
+                spars.pop('dtype', None) # Not a valid arg for SciPy distributions
+                self.dist = self.dist(**spars)
+
             # Override the default random state with the correct one
-            self.dist.random_state = self.rng 
-            
+            self.dist.random_state = self.rng
+
         # Set the default function for getting the rvs
         if self.distname is not None and hasattr(self.rng, self.distname): # Don't worry if it doesn't, it's probably being manually overridden
             self.rvs_func = self.distname # e.g. self.rng.uniform -- can't use the actual function because can become linked to the wrong RNG
-        
+
         return
-    
+
     def process_size(self, n=1):
-        """ Handle an input of either size or UIDs and calculate size, UIDs, and slots """
+        """ Handle an input of either size or UIDs and calculate size, UIDs, and slots; not for the user """
         if np.isscalar(n) or isinstance(n, tuple):  # If passing a non-scalar size, interpret as dimension rather than UIDs iff a tuple
             uids = None
             slots = None
@@ -431,6 +469,9 @@ class Dist:
         else:
             uids = ss.uids(n)
             if len(uids):
+                if self.slots is None:
+                    errormsg = f'Could not find any slots in {self}. Did you remember to initialize the distribution with the sim?'
+                    raise ValueError(errormsg)
                 slots = self.slots[uids]
                 if len(slots): # Handle case where uids is boolean
                     size = slots.max() + 1
@@ -439,83 +480,115 @@ class Dist:
             else:
                 slots = np.array([])
                 size = 0
-        
+
         self._n = n
         self._size = size
         self._uids = uids
         self._slots = slots
         return size, slots
-    
+
     def process_pars(self, call=True):
-        """ Ensure the supplied dist and parameters are valid, and initialize them; called automatically """
+        """ Ensure the supplied dist and parameters are valid, and initialize them; not for the user """
+        self._timepar = None # Time rescalings need to be done after distributions are calculated; store the correction factor here
         self._pars = sc.cp(self.pars) # The actual keywords; shallow copy, modified below for special cases
         if call:
             self.call_pars() # Convert from function to values if needed
         spars = self.sync_pars() # Synchronize parameters between the NumPy and SciPy distributions
         return spars
-    
+
+    def preprocess_timepar(self, key, timepar):
+        """ Method to handle how timepars are processed; not for the user. By default, scales the output of the distribution. """
+        if self._timepar is None: # Store this here for later use
+            self._timepar = sc.dcp(timepar) # Make a copy to avoid modifying the original
+        elif timepar.factor != self._timepar.factor:
+            errormsg = f'Cannot have time parameters in the same distribution with inconsistent unit/dt values: {self._pars}'
+            raise ValueError(errormsg)
+        self._pars[key] = timepar.v # Use the raw value, since it could be anything (including a function)
+        return timepar.v # Also use this for the rest of the loop
+
+    def convert_callable(self, key, val, size, uids):
+        """ Method to handle how callable parameters are processed; not for the user """
+        size_par = uids if uids is not None else size
+        out = val(self.module, self.sim, size_par)
+        val = np.asarray(out) # Necessary since FloatArrs don't allow slicing # TODO: check if this is correct
+        self._pars[key] = val
+        return val
+
+    def call_par(self, key, val, size, uids):
+        """ Check if this parameter needs to be called to be turned into an array; not for the user """
+        if isinstance(val, ss.TimePar): # If it's a time parameter, transform it to a float now
+            val = self.preprocess_timepar(key, val)
+        if callable(val) and not isinstance(val, type): # If the parameter is callable, then call it (types can appear as callable)
+            val = self.convert_callable(key, val, size, uids)
+        return val
+
     def call_pars(self):
-        """ Check if any parameters need to be called to be turned into arrays """
-        
+        """ Check if any parameters need to be called to be turned into arrays; not for the user """
+
         # Initialize
         size, uids = self._size, self._uids
         if self.dynamic_pars != False: # Allow "False" to prevent ever using dynamic pars (used in ss.choice())
             self.dynamic_pars = None
-        
+
         # Check each parameter
         for key,val in self._pars.items():
-            
-            # If the parameter is callable, then call it
-            if callable(val): 
-                size_par = uids if uids is not None else size
-                out = val(self.module, self.sim, size_par) # TODO: swap order to sim, module, size?
-                val = np.asarray(out) # Necessary since UIDArrays don't allow slicing # TODO: check if this is correct
-                self._pars[key] = val
-            
+            val = self.call_par(key, val, size, uids)
+
             # If it's iterable and UIDs are provided, then we need to use array-parameter logic
             if self.dynamic_pars is None and np.iterable(val) and uids is not None:
                 self.dynamic_pars = True
         return
-    
+
     def sync_pars(self):
-        """ Perform any necessary synchronizations or transformations on distribution parameters """
+        """ Perform any necessary synchronizations or transformations on distribution parameters; not for the user """
         self.update_dist_pars()
         return self._pars
-    
+
     def update_dist_pars(self, pars=None):
-        """ Update SciPy distribution parameters """
+        """ Update SciPy distribution parameters; not for the user """
         if self.dist is not None:
             pars = pars if pars is not None else self._pars
             self.dist.kwds = pars
         return
-    
+
     def rand(self, size):
         """ Simple way to get simple random numbers """
-        return self.rng.random(size)
-    
+        return self.rng.random(size, dtype=ss.dtypes.float) # Up to 2x faster with float32
+
     def make_rvs(self):
-        """ Return default random numbers for scalar parameters """
+        """ Return default random numbers for scalar parameters; not for the user """
         if self.rvs_func is not None:
             rvs_func = getattr(self.rng, self.rvs_func) # Can't store this because then it references the wrong RNG after copy
-            rvs = rvs_func(**self._pars, size=self._size)
+            rvs = rvs_func(size=self._size, **self._pars)
         elif self.dist is not None:
             rvs = self.dist.rvs(self._size)
         else:
             errormsg = 'Dist.rvs() failed: no valid NumPy/SciPy function found in this Dist. Has it been created and initialized correctly?'
             raise ValueError(errormsg)
         return rvs
-    
+
     def ppf(self, rands):
-        """ Return default random numbers for array parameters """
+        """ Return default random numbers for array parameters; not for the user """
         rvs = self.dist.ppf(rands)
         return rvs
-    
+
+    def postprocess_timepar(self, rvs):
+        """ Scale random variates after generation; not for the user """
+        timepar = self._timepar # Shorten
+        self._timepar = None # Remove the timepar which is no longer needed
+        timepar.v = rvs # Replace the base value with the random variates
+        timepar.update_cached() # Recalculate the factor and values with the time scaling
+        rvs = timepar.values # Replace the rvs with the scaled version
+        if isinstance(rvs, np.ndarray): # This can be false when converting values for a Bernoulli distribution (in which case rvs are actually dist parameters)
+            rvs = rvs.astype(rvs.dtype) # Replace the random variates with the scaled version, and preserve type
+        return rvs
+
     def rvs(self, n=1, reset=False):
         """
-        Get random variables
-        
+        Get random variates -- use this!
+
         Args:
-            n (int/tuple/arr): if an int or tuple, return this many random variables; if an array, treat as UIDs
+            n (int/tuple/arr): if an int or tuple, return this many random variates; if an array, treat as UIDs
             reset (bool): whether to automatically reset the random number distribution state after being called
         """
         # Check for readiness
@@ -523,32 +596,36 @@ class Dist:
             raise DistNotInitializedError(self)
         if not self.ready and self.strict and not ss.options._centralized:
             raise DistNotReadyError(self)
-        
+
         # Figure out size, UIDs, and slots
         size, slots = self.process_size(n)
-        
+
         # Check if size is 0, then we can return
         if size == 0:
-            return np.array([], dtype=int) # int dtype allows use as index, e.g. when filtering
+            return np.array([], dtype=ss.dtypes.int) # int dtype allows use as index, e.g. when filtering
         elif isinstance(size, ss.uids) and self.initialized == 'partial': # This point can be reached if and only if strict=False and UIDs are used as input
             errormsg = f'Distribution {self} is only partially initialized; cannot generate random numbers to match UIDs'
             raise ValueError(errormsg)
-        
+
         # Store the state
         self.make_history() # Store the pre-call state
-        
+
         # Check if any keywords are callable -- parameters shouldn't need to be reprocessed otherwise
         self.process_pars()
-        
+
         # Actually get the random numbers
         if self.dynamic_pars:
-            rands = self.rand(size)[slots] # Get random values 
+            rands = self.rand(size)[slots] # Get random values
             rvs = self.ppf(rands) # Convert to actual values via the PPF
         else:
             rvs = self.make_rvs() # Or, just get regular values
             if self._slots is not None:
                 rvs = rvs[self._slots]
-        
+
+        # Scale by time if needed
+        if self._timepar is not None:
+            rvs = self.postprocess_timepar(rvs)
+
         # Tidy up
         self.called += 1
         if reset:
@@ -558,55 +635,101 @@ class Dist:
         elif self.strict:
             self.ready = False
         if self.debug:
-            simstr = f'on ti={self.sim.ti} ' if self.sim else ''
+            tistr   = f'on ti={self.module.ti} ' if self.module else ''
             sizestr = f'with size={self._size}, '
             slotstr = f'Σ(slots)={self._slots.sum()}, ' if self._slots else '<no slots>, '
-            rvstr = f'Σ(rvs)={rvs.sum():0.2f}, |rvs|={rvs.mean():0.4f}'
+            rvstr   = f'Σ(rvs)={rvs.sum():0.2f}, |rvs|={rvs.mean():0.4f}'
             pre_state = str(self.history[-1]['state']['state'])[-5:]
             post_state = str(self.state_int)[-5:]
             statestr = f"state {pre_state}→{post_state}"
-            print(f'Debug: {self} called {simstr}{sizestr}{slotstr}{rvstr}, {statestr}')
+            print(f'Debug: {self} called {tistr}{sizestr}{slotstr}{rvstr}, {statestr}')
             assert pre_state != post_state # Always an error if the state doesn't change after drawing random numbers
-            
+
         return rvs
 
+    def to_json(self):
+        """ Return a dictionary representation of the Dist """
+        tracestr = '<no trace>' if self.trace is None else f"{self.trace}"
+        classname = self.__class__.__name__
+        diststr = ''
+        if classname == 'Dist':
+            if self.dist is not None:
+                try:
+                    diststr = f'dist={self.dist.name}, '
+                except:
+                    try: # What is wrong with you, SciPy -- after initialization, it moves here
+                        diststr = f'dist={self.dist.dist.name}, '
+                    except:
+                        diststr = f'dist={type(self.dist)}'
+            elif self.distname is not None:
+                diststr = f'dist={self.distname}, '
+        out = dict(
+            type = 'Dist',
+            classname = classname,
+            tracestr = tracestr,
+            diststr = diststr,
+            pars = dict(self.pars),
+        )
+        return out
+
 
     def plot_hist(self, n=1000, bins=None, fig_kw=None, hist_kw=None):
         """ Plot the current state of the RNG as a histogram """
-        pl.figure(**sc.mergedicts(fig_kw))
+        plt.figure(**sc.mergedicts(fig_kw))
         rvs = self.rvs(n)
         self.reset(-1) # As if nothing ever happened
-        pl.hist(rvs, bins=bins, **sc.mergedicts(hist_kw))
-        pl.title(str(self))
-        pl.xlabel('Value')
-        pl.ylabel(f'Count ({n} total)')
+        plt.hist(rvs, bins=bins, **sc.mergedicts(hist_kw))
+        plt.title(str(self))
+        plt.xlabel('Value')
+        plt.ylabel(f'Count ({n} total)')
         return rvs
-        
+
 
 #%% Specific distributions
 
 # Add common distributions so they can be imported directly; assigned to a variable since used in help messages
 dist_list = ['random', 'uniform', 'normal', 'lognorm_ex', 'lognorm_im', 'expon',
-             'poisson', 'weibull', 'constant', 'randint', 'bernoulli', 'choice']
+             'poisson', 'weibull', 'gamma', 'constant', 'randint', 'rand_raw', 'bernoulli',
+             'choice', 'histogram']
 __all__ += dist_list
+__all__ += ['multi_random'] # Not a dist in the same sense as the others
 
 
 class random(Dist):
-    """ Random distribution, values on interval (0,1) """
+    """ Random distribution, with values on the interval (0, 1) """
     def __init__(self, **kwargs):
-        super().__init__(distname='random', **kwargs)
+        super().__init__(distname='random', dtype=ss.dtypes.float, **kwargs)
         return
-    
+
     def ppf(self, rands):
         return rands
 
 
 class uniform(Dist):
-    """ Uniform distribution, values on interval (low, high) """
-    def __init__(self, low=0.0, high=1.0, **kwargs):
+    """
+    Uniform distribution, values on interval (low, high)
+
+    Args:
+        low (float): the lower bound of the distribution (default 0.0)
+        high (float): the upper bound of the distribution (default 1.0)
+    """
+    def __init__(self, low=None, high=None, **kwargs):
+        if high is None and low is not None: # One argument, swap
+            high = low
+            low = 0.0
+        if low is None:
+            low = 0.0
+        if high is None:
+            high = 1.0
         super().__init__(distname='uniform', low=low, high=high, **kwargs)
         return
-    
+
+    def make_rvs(self):
+        """ Specified here because uniform() doesn't take a dtype argument """
+        p = self._pars
+        rvs = self.rand(self._size) * (p.high - p.low) + p.low
+        return rvs
+
     def ppf(self, rands):
         p = self._pars
         rvs = rands * (p.high - p.low) + p.low
@@ -614,8 +737,15 @@ class uniform(Dist):
 
 
 class normal(Dist):
-    """ Normal distribution, with mean=loc and stdev=scale """
-    def __init__(self, loc=0.0, scale=1.0, **kwargs):
+    """
+    Normal distribution
+
+    Args:
+        loc (float): the mean of the distribution (default 0.0)
+        scale (float) the standard deviation of the distribution (default 1.0)
+
+    """
+    def __init__(self, loc=0.0, scale=1.0, **kwargs): # Does not accept dtype
         super().__init__(distname='normal', dist=sps.norm, loc=loc, scale=scale, **kwargs)
         return
 
@@ -623,21 +753,27 @@ class normal(Dist):
 class lognorm_im(Dist):
     """
     Lognormal distribution, parameterized in terms of the "implicit" (normal)
-    distribution, with mean=loc and stdev=scale (see lognorm_ex for comparison).
-    
+    distribution, with mean=loc and std=scale (see lognorm_ex for comparison).
+
     Note: the "loc" parameter here does *not* correspond to the mean of the resulting
     random variates!
-    
+
+    Args:
+        mean (float): the mean of the underlying normal distribution (not this distribution) (default 0.0)
+        sigma (float): the standard deviation of the underlying normal distribution (not this distribution) (default 1.0)
+
     **Example**::
-        
-        ss.lognorm_im(mean=2, sigma=1).rvs(1000).mean() # Should be roughly 10
+
+        ss.lognorm_im(mean=2, sigma=1, strict=False).rvs(1000).mean() # Should be roughly 10
     """
-    def __init__(self, mean=0.0, sigma=1.0, **kwargs):
+    def __init__(self, mean=0.0, sigma=1.0, **kwargs): # Does not accept dtype
         super().__init__(distname='lognormal', dist=sps.lognorm, mean=mean, sigma=sigma, **kwargs)
         return
-    
-    def sync_pars(self):
+
+    def sync_pars(self, call=True):
         """ Translate between NumPy and SciPy parameters """
+        if call:
+            self.call_pars()
         p = self._pars
         spars = sc.dictobj()
         spars.s = p.sigma
@@ -645,21 +781,32 @@ class lognorm_im(Dist):
         spars.loc = 0
         self.update_dist_pars(spars)
         return spars
-    
+
+    def preprocess_timepar(self, key, val):
+        """ Not valid since incorrect time units """
+        errormsg = f'Cannot use timepars with a lognorm_im distribution ({self}) since its units are not time. Use lognorm_ex instead.'
+        raise NotImplementedError(errormsg)
+
 
 class lognorm_ex(Dist):
     """
     Lognormal distribution, parameterized in terms of the "explicit" (lognormal)
-    distribution, with mean=mean and stdev=stdev (see lognorm_im for comparison).
-    
+    distribution, with mean=mean and std=std for this distribution (see lognorm_im for comparison).
+    Note that a mean ≤ 0.0 is impossible, since this is the parameter of the distribution
+    after the log transform.
+
+    Args:
+        mean (float): the mean of this distribution (not the underlying distribution) (default 1.0)
+        std (float): the standard deviation of this distribution (not the underlying distribution) (default 1.0)
+
     **Example**::
-        
-        ss.lognorm_ex(mean=2, stdev=1).rvs(1000).mean() # Should be close to 2
+
+        ss.lognorm_ex(mean=2, std=1, strict=False).rvs(1000).mean() # Should be close to 2
     """
-    def __init__(self, mean=1.0, stdev=1.0, **kwargs):
-        super().__init__(distname='lognormal', dist=sps.lognorm, mean=mean, stdev=stdev, **kwargs)
+    def __init__(self, mean=1.0, std=1.0, **kwargs): # Does not accept dtype
+        super().__init__(distname='lognormal', dist=sps.lognorm, mean=mean, std=std, **kwargs)
         return
-    
+
     def convert_ex_to_im(self):
         """
         Lognormal distributions can be specified in terms of the mean and standard
@@ -671,58 +818,157 @@ class lognorm_ex(Dist):
         self.call_pars() # Since can't work with functions
         p = self._pars
         mean = p.pop('mean')
-        stdev = p.pop('stdev')
+        std = p.pop('std')
         if np.isscalar(mean) and mean <= 0:
             errormsg = f'Cannot create a lognorm_ex distribution with mean≤0 (mean={mean}); did you mean to use lognorm_im instead?'
             raise ValueError(errormsg)
-        std2 = stdev**2
+        std2 = std**2
         mean2 = mean**2
-        sigma_im = np.sqrt(np.log(std2/mean2 + 1)) # Computes stdev for the underlying normal distribution
+        sigma_im = np.sqrt(np.log(std2/mean2 + 1)) # Computes std for the underlying normal distribution
         mean_im  = np.log(mean2 / np.sqrt(std2 + mean2)) # Computes the mean of the underlying normal distribution
         p.mean = mean_im
         p.sigma = sigma_im
         return mean_im, sigma_im
-    
+
     def sync_pars(self):
         """ Convert from overlying to underlying parameters, then translate to SciPy """
         self.convert_ex_to_im()
-        spars = lognorm_im.sync_pars(self) # Borrow sync_pars from lognorm_im
+        spars = lognorm_im.sync_pars(self, call=False) # Borrow sync_pars from lognorm_im
         return spars
-    
+
 
 class expon(Dist):
-    """ Exponential distribution """
+    """
+    Exponential distribution
+
+    Args:
+        scale (float): the scale of the distribution (default 1.0)
+
+    """
     def __init__(self, scale=1.0, **kwargs):
         super().__init__(distname='exponential', dist=sps.expon, scale=scale, **kwargs)
         return
 
 
-class poisson(Dist):
-    """ Exponential distribution """
+class poisson(Dist): # TODO: does not currently scale correctly with dt
+    """
+    Poisson distribution
+
+    Args:
+        lam (float): the scale of the distribution (default 1.0)
+    """
     def __init__(self, lam=1.0, **kwargs):
         super().__init__(distname='poisson', dist=sps.poisson, lam=lam, **kwargs)
         return
-    
+
     def sync_pars(self):
         """ Translate between NumPy and SciPy parameters """
         spars = dict(mu=self._pars.lam)
         self.update_dist_pars(spars)
         return spars
 
+    def preprocess_timepar(self, key, timepar):
+        """ Try to update the timepar before calculating array parameters, but raise an exception if this isn't possible """
+        try:
+            timepar.update_cached()
+        except Exception as E:
+            errormsg = f'Could not process timepar {timepar} for {self}. Note that Poisson distributions are not compatible with both callable parameters and timepars, since this would change the shape in an unknowable way.'
+            raise ValueError(errormsg) from E
+
+        self._pars[key] = timepar.values # Use the raw value, since it could be anything (including a function)
+        return timepar.values # Also use this for the rest of the loop
+
 
 class randint(Dist):
-    """ Random integers, values on the interval [low, high-1] (i.e. "high" is excluded) """
-    def __init__(self, low=0, high=2,  **kwargs):
-        super().__init__(distname='integers', dist=sps.randint, low=low, high=high, **kwargs)
+    """
+    Random integer distribution, on the interval [low, high)
+
+    Args:
+        low (int): the lower bound of the distribution (default 0)
+        high (int): the upper bound of the distribution (default of maximum integer size: 9,223,372,036,854,775,807)
+        allow_time (bool): allow time parameters to be specified as high/low values (disabled by default since introduces rounding error)
+    """
+    def __init__(self, *args, low=None, high=None, dtype=ss.dtypes.rand_int, allow_time=False, **kwargs):
+        # Handle input arguments # TODO: reconcile with how this is handled in uniform()
+        self.allow_time = allow_time
+        if len(args):
+            if len(args) == 1:
+                high = args[0]
+            elif len(args) == 2:
+                low,high = args
+            else:
+                errormsg = f'ss.randint() takes one or two arguments, not {len(args)}'
+                raise ValueError(errormsg)
+        if low is None:
+            low = 0
+        if high is None:
+            high = np.iinfo(ss.dtypes.rand_int).max
+
+        if ss.options._centralized: # randint because we're accessing via numpy.random
+            super().__init__(distname='randint', low=low, high=high, dtype=dtype, **kwargs)
+        else: # integers instead of randint because interfacing a numpy.random.Generator
+            super().__init__(distname='integers', low=low, high=high, dtype=dtype, **kwargs)
         return
-    
+
+    def ppf(self, rands):
+        p = self._pars
+        rvs = rands * (p.high + 1 - p.low) + p.low
+        rvs = rvs.astype(self.dtype)
+        return rvs
+
+    def preprocess_timepar(self, key, timepar):
+        """ Not valid due to a rounding error """
+        if self.allow_time:
+            return super().preprocess_timepar(key, timepar)
+        else:
+            errormsg = f'Cannot use timepars with a randint distribution ({self}) since the values may be rounded incorrectly. Use uniform() instead and convert to int yourself, or set allow_time=True if you really want to do this.'
+            raise NotImplementedError(errormsg)
+
+
+class rand_raw(Dist):
+    """
+    Directly sample raw integers (uint64) from the random number generator.
+    Typicaly only used with ss.combine_rands().
+    """
+    def make_rvs(self):
+        if ss.options._centralized:
+            return self.rng.randint(low=0, high=np.iinfo(np.uint64).max, dtype=np.uint64, size=self._size)
+        else:
+            return self.bitgen.random_raw(self._size) # TODO: figure out how to make accept dtype, or check speed
+
 
 class weibull(Dist):
-    """ Weibull distribution -- NB, uses SciPy rather than NumPy """
-    def __init__(self, c=1, loc=0, scale=1,  **kwargs):
+    """
+    Weibull distribution (specifically, scipy.stats.weibull_min)
+
+    Args:
+        c (float): the shape parameter, sometimes called k (default 1.0)
+        loc (float): the location parameter, which shifts the position of the distribution (default 0.0)
+        scale (float): the scale parameter, sometimes called λ (default 1.0)
+    """
+    def __init__(self, c=1.0, loc=0.0, scale=1.0, **kwargs):
         super().__init__(distname='weibull', dist=sps.weibull_min, c=c, loc=loc, scale=scale, **kwargs)
         return
-    
+
+    def make_rvs(self):
+        """ Use SciPy rather than NumPy to include the scale parameter """
+        rvs = self.dist.rvs(self._size)
+        return rvs
+
+
+class gamma(Dist):
+    """
+    Gamma distribution (specifically, scipy.stats.gamma)
+
+    Args:
+        a (float): the shape parameter, sometimes called k (default 1.0)
+        loc (float): the location parameter, which shifts the position of the distribution (default 0.0)
+        scale (float): the scale parameter, sometimes called θ (default 1.0)
+    """
+    def __init__(self, a=1.0, loc=0.0, scale=1.0, **kwargs):
+        super().__init__(distname='gamma', dist=sps.gamma, a=a, loc=loc, scale=scale, **kwargs)
+        return
+
     def make_rvs(self):
         """ Use SciPy rather than NumPy to include the scale parameter """
         rvs = self.dist.rvs(self._size)
@@ -730,14 +976,19 @@ class weibull(Dist):
 
 
 class constant(Dist):
-    """ Constant (delta) distribution: equivalent to np.full() """
-    def __init__(self, v=0, **kwargs):
+    """
+    Constant (delta) distribution: equivalent to np.full()
+
+    Args:
+        v (float): the value to return
+    """
+    def __init__(self, v=0.0, **kwargs):
         super().__init__(distname='const', v=v, **kwargs)
         return
-    
+
     def make_rvs(self):
         return np.full(self._size, self._pars.v)
-    
+
     def ppf(self, rands): # NB: don't actually need to use random numbers here, but not worth the complexity of avoiding this
         return np.full(rands.shape, self._pars.v)
 
@@ -745,26 +996,32 @@ class constant(Dist):
 class bernoulli(Dist):
     """
     Bernoulli distribution: return True or False with the specified probability (which can be an array)
-    
+
     Unlike other distributions, Bernoulli distributions have a filter() method,
     which returns elements of the array that return True.
+
+    Args:
+        p (float): the probability of returning True (default 0.5)
     """
     def __init__(self, p=0.5, **kwargs):
         super().__init__(distname='bernoulli', p=p, **kwargs)
         return
-    
+
     def make_rvs(self):
-        rvs = self.rng.random(self._size) < self._pars.p # 3x faster than using rng.binomial(1, p, size)
+        rvs = self.rand(self._size) < self._pars.p # 3x faster than using rng.binomial(1, p, size)
         return rvs
-    
+
     def ppf(self, rands):
         rvs = rands < self._pars.p
         return rvs
-    
+
     def filter(self, uids=None, both=False):
         """ Return UIDs that correspond to True, or optionally return both True and False """
         if uids is None:
             uids = self.sim.people.auids # All active UIDs
+        elif isinstance(uids, (ss.BoolArr, ss.IndexArr)):
+            uids = uids.uids
+
         bools = self.rvs(uids)
         if both:
             return uids[bools], uids[~bools]
@@ -775,24 +1032,55 @@ class bernoulli(Dist):
         """ Alias to filter(uids, both=True) """
         return self.filter(uids=uids, both=True)
 
+    def call_par(self, key, val, size, uids):
+        """ Reverse the usual order of processing so callable is processed first, and then the timepar conversion """
+        is_timepar = isinstance(val, ss.TimePar)
+
+        if is_timepar: # If it's a time parameter, pull out the value
+            timepar = sc.dcp(val) # Rename to make more sense within the context of this method
+            val = timepar.v # Pull out the base value; we'll deal with the transformation later
+            self._timepar = timepar # This is used, then destroyed, by postprocess_timepar() below
+            if isinstance(timepar, ss.dur): # Validation
+                errormsg = f'Bernoulli distributions can only be used with ss.time_prob() or ss.rate(), not {timepar}'
+                raise TypeError(errormsg)
+
+        # As normal: if the parameter is callable, then call it (types can appear as callable)
+        if callable(val) and not isinstance(val, type):
+            val = self.convert_callable(key, val, size, uids)
+
+        # Process as a timepar
+        if is_timepar:
+            val = self.postprocess_timepar(val) # Note: this is processing the parameter rather than the rvs as usual
+
+        # Store in the parameters and return
+        self._pars[key] = val
+        return val
+
 
 class choice(Dist):
     """
-    Random choice between discrete options
-    
+    Random choice between discrete options (note: dynamic parameters not supported)
+
+    Args:
+        a (int or array): the number of choices, or the choices themselves (default 2)
+        p (array): if supplied, the probability of each choice (default, 1/a for a choices)
+
     **Examples**::
-        
+
         # Simulate 10 die rolls
-        ss.choice(6)(10) + 1 
-        
+        ss.choice(6, strict=False)(10) + 1
+
         # Choose between specified options each with a specified probability (must sum to 1)
-        ss.choice(a=[30, 70], p=[0.3, 0.7])(10)
+        ss.choice(a=[30, 70], p=[0.3, 0.7], strict=False)(10)
+
+    Note: although Bernoulli trials can be generated using a=2, it is much faster
+    to use ss.bernoulli() instead.
     """
     def __init__(self, a=2, p=None, **kwargs):
         super().__init__(distname='choice', a=a, p=p, **kwargs)
         self.dynamic_pars = False # Set to false since array arguments don't imply dynamic pars here
         return
-    
+
     def ppf(self, rands):
         """ Shouldn't actually be needed since dynamic pars not supported """
         pars = self._pars
@@ -803,28 +1091,165 @@ class choice(Dist):
         rvs = pars.a[inds]
         return rvs
 
+    def preprocess_timepar(self, key, timepar):
+        """ Not valid since does not scale with time """
+        errormsg = f'Cannot use timepars with a choice distribution ({self}) since its units are not time. Convert output to time units instead.'
+        raise NotImplementedError(errormsg)
+
+
+class histogram(Dist):
+    """
+    Sample from a histogram with defined bins
+
+    Note: unlike other distributions, the parameters of this distribution can't
+    be modified after creation.
+
+    Args:
+        values (array): the probability (or count) of each bin
+        bins (array): the edges of each bin
+        density (bool): treat the histogram as a density instead of counts; only matters with unequal bin widths, see numpy.histogram and scipy.stats.rv_histogram for more information
+        data (array): if supplied, compute the values and bin edges using this data and np.histogram() instead
+
+    Note: if the length of bins is equal to the length of values, they will be
+    interpreted as left bin edges, and one additional right-bin edge will be added
+    based on the difference between the last two bins (e.g. if the last two bins are
+    40 and 50, the final right edge will be added at 60). If no bins are supplied,
+    then they will be created as integers matching the length of the values.
+
+    The values can be supplied in either normalized (sum to 1) or un-normalized
+    format.
+
+    **Examples**::
+
+        # Sample from an age distribution
+        age_bins = [0,    10,  20,  40,  65, 100]
+        age_vals = [0.1, 0.1, 0.3, 0.3, 0.2]
+        h1 = ss.histogram(values=age_vals, bins=age_bins, strict=False)
+        h1.plot_hist()
+
+        # Create a histogram from data
+        data = np.random.randn(10_000)*2+5
+        h2 = ss.histogram(data=data, strict=False)
+        h2.plot_hist(bins=100)
+    """
+    def __init__(self, values=None, bins=None, density=False, data=None, **kwargs):
+        if data is not None:
+            if values is not None:
+                errormsg = 'You can supply values or data, but not both'
+                raise ValueError(errormsg)
+            kw = {'bins':bins} if bins is not None else {} # Hack to not overwrite default bins value
+            values, bins = np.histogram(data, **kw)
+        else:
+            if values is None:
+                values = [1.0] # Uniform distribution
+            values = sc.toarray(values)
+            if bins is None:
+                bins = np.arange(len(values)+1)
+            bins = sc.toarray(bins)
+        if len(bins) == len(values): # Append a final bin, if necessary
+            delta = bins[-1] - bins[-2]
+            bins = np.append(bins, bins[-1]+delta)
+        vsum = values.sum()
+        if vsum != 1.0:
+            values = values / vsum
+        dist = sps.rv_histogram((values, bins), density=density) # Create the SciPy distribution
+        super().__init__(dist=dist, distname='histogram', **kwargs)
+        self.dynamic_pars = False # Set to false since array arguments don't imply dynamic pars here
+        return
+
+
+class multi_random(sc.prettyobj):
+    """
+    A class for holding two or more ss.random() distributions, and generating
+    random numbers linked to each of them. Useful for e.g. pairwise transmission
+    probabilities.
+
+    See ss.combine_rands() for the manual version; in almost all cases this class
+    should be used instead.
+
+    Usage:
+        multi = ss.multi_random('source', 'target')
+        rvs = multi.rvs(source_uids, target_uids)
+    """
+    def __init__(self, names, *args, **kwargs):
+        names = sc.mergelists(names, args)
+        self.dists = [ss.random(name=name, **kwargs) for name in names]
+        return
+
+    def __len__(self):
+        return len(self.dists)
+
+    def init(self, *args, **kwargs):
+        """ Not usually needed since each dist will handle this automatically; for completeness only """
+        for dist in self.dists: dist.init(*args, **kwargs)
+        return
+
+    def reset(self, *args, **kwargs):
+        """ Not usually needed since each dist will handle this automatically; for completeness only """
+        for dist in self.dists: dist.reset(*args, **kwargs)
+        return
+
+    def jump(self, *args, **kwargs):
+        """ Not usually needed since each dist will handle this automatically; for completeness only """
+        for dist in self.dists: dist.jump(*args, **kwargs)
+        return
+
+    @staticmethod
+    @nb.njit(fastmath=True, parallel=False, cache=True) # Numba is 3x faster, but disabling parallel for efficiency
+    def combine_rvs(rvs_list, int_type, int_max):
+        """ Combine inputs into one number """
+        # Combine using bitwise-or
+        rand_ints = rvs_list[0].view(int_type)
+        for rand_floats in rvs_list[1:]:
+            rand_ints2 = rand_floats.view(int_type)
+            rand_ints = np.bitwise_xor(rand_ints*rand_ints2, rand_ints-rand_ints2)
+
+        # Normalize
+        rvs = rand_ints / int_max
+        return rvs
+
+    def rvs(self, *args):
+        """ Get random variates from each of the underlying distributions and combine them efficiently """
+        # Validation
+        n_args = len(args)
+        n_dists = len(self)
+        if n_args != len(self):
+            errormsg = f'Number of UID lists supplied ({n_args}) does not match number of distributions ({n_dists})'
+            raise ValueError(errormsg)
+
+        rvs_list = [dist.rvs(arg) for dist,arg in zip(self.dists, args)]
+        int_type = ss.dtypes.rand_uint
+        int_max = np.iinfo(int_type).max
+        rvs = self.combine_rvs(rvs_list, int_type, int_max)
+        return rvs
+
+
+
 
 #%% Dist exceptions
 
 class DistNotInitializedError(RuntimeError):
     """ Raised when Dist object is called when not initialized. """
-    def __init__(self, dist):
-        msg = f'{dist} has not been initialized; please call dist.initialize()'
+    def __init__(self, dist=None, msg=None):
+        if msg is None:
+            msg = f'{dist} has not been initialized; please set strict=False when creating the distribution, or call dist.init()'
         super().__init__(msg)
         return
 
 
 class DistNotReadyError(RuntimeError):
     """ Raised when a Dist object is called without being ready. """
-    def __init__(self, dist):
-        msg = f'{dist} is not ready. This is likely caused by calling a distribution multiple times in a single step. Call dist.jump() to reset.'
+    def __init__(self, dist=None, msg=None):
+        if msg is None:
+            msg = f'{dist} is not ready. This is likely caused by calling a distribution multiple times in a single step. Call dist.jump() to reset.'
         super().__init__(msg)
         return
 
 
 class DistSeedRepeatError(RuntimeError):
     """ Raised when a Dist object shares a seed with another """
-    def __init__(self, dist1, dist2):
-        msg = f'A common seed was found between {dist1} and {dist2}. This is likely caused by incorrect initialization of the parent Dists object.'
+    def __init__(self, dist1=None, dist2=None, msg=None):
+        if msg is None:
+            msg = f'A common seed was found between {dist1} and {dist2}. This is likely caused by incorrect initialization of the parent Dists object.'
         super().__init__(msg)
         return
diff --git a/starsim/interventions.py b/starsim/interventions.py
index 4c40500..5981515 100644
--- a/starsim/interventions.py
+++ b/starsim/interventions.py
@@ -1,68 +1,37 @@
 """
-Define interventions (and analyzers)
+Define interventions
 """
-
 import starsim as ss
 import sciris as sc
 import numpy as np
 
-__all__ = ['Plugin', 'Analyzer', 'Intervention']
+__all__ = ['Intervention']
 
 
-class Plugin(ss.Module):
-    """ Base class for interventions and analyzers """
-    def __init__(self, *args, **kwargs):
-        super().__init__(*args, **kwargs)
-        return
-    
-    def __call__(self, *args, **kwargs):
-        return self.apply(*args, **kwargs)
-    
-    def init_pre(self, sim):
-        return super().init_pre(sim)
-    
-    def apply(self, sim):
-        pass
-
-    def finalize(self):
-        return super().finalize()
-    
-    @classmethod
-    def from_func(cls, func):
-        """ Create an intervention or analyzer from a function """
-        name = func.__name__
-        new = cls(name=name)
-        new.apply = func
-        return new
-
-
-class Analyzer(Plugin):
-    """
-    Base class for analyzers. Analyzers are used to provide more detailed information 
-    about a simulation than is available by default -- for example, pulling states 
-    out of sim.people on a particular timestep before they get updated on the next step.
-    
-    The key method of the analyzer is ``apply()``, which is called with the sim
-    on each timestep.
-    
-    To retrieve a particular analyzer from a sim, use sim.get_analyzer().
-    """
-    pass
-
-
-class Intervention(Plugin):
+class Intervention(ss.Module):
     """
     Base class for interventions.
-    
-    The key method of the intervention is ``apply()``, which is called with the sim
+
+    The key method of the intervention is ``step()``, which is called with the sim
     on each timestep.
     """
 
-    def __init__(self, eligibility=None, *args, **kwargs):
+    def __init__(self, *args, eligibility=None, **kwargs):
         super().__init__(*args, **kwargs)
         self.eligibility = eligibility
         return
 
+    @property
+    def has_product(self):
+        """ Check if the intervention has a product """
+        return hasattr(self, 'product') and self.product is not None
+
+    def init_pre(self, sim):
+        super().init_pre(sim)
+        if self.has_product:
+            self.product.init_pre(self.sim)
+        return
+
     def _parse_product(self, product):
         """
         Parse the product input
@@ -79,12 +48,12 @@ class Intervention(Plugin):
     def _parse_product_str(self, product):
         raise NotImplementedError
 
-    def check_eligibility(self, sim):
+    def check_eligibility(self):
         """
         Return an array of indices of agents eligible for screening at time t
         """
         if self.eligibility is not None:
-            is_eligible = self.eligibility(sim)
+            is_eligible = self.eligibility(self.sim)
             if is_eligible is not None and len(is_eligible): # Only worry if non-None/nonzero length
                 if isinstance(is_eligible, ss.BoolArr):
                     is_eligible = is_eligible.uids
@@ -92,7 +61,7 @@ class Intervention(Plugin):
                     errormsg = f'Eligibility function must return BoolArr or UIDs, not {type(is_eligible)} {is_eligible}'
                     raise TypeError(errormsg)
         else:
-            is_eligible = sim.people.auids # Everyone
+            is_eligible = self.sim.people.auids # Everyone
         return is_eligible
 
 
@@ -105,7 +74,7 @@ class RoutineDelivery(Intervention):
     Base class for any intervention that uses routine delivery; handles interpolation of input years.
     """
 
-    def __init__(self, years=None, start_year=None, end_year=None, prob=None, annual_prob=True, *args, **kwargs):
+    def __init__(self, *args, years=None, start_year=None, end_year=None, prob=None, annual_prob=True, **kwargs):
         super().__init__(*args, **kwargs)
         self.years = years
         self.start_year = start_year
@@ -116,6 +85,7 @@ class RoutineDelivery(Intervention):
         return
 
     def init_pre(self, sim):
+        super().init_pre(sim)
 
         # Validate inputs
         if (self.years is not None) and (self.start_year is not None or self.end_year is not None):
@@ -124,26 +94,29 @@ class RoutineDelivery(Intervention):
 
         # If start_year and end_year are not provided, figure them out from the provided years or the sim
         if self.years is None:
-            if self.start_year is None: self.start_year = sim.pars['start']
-            if self.end_year is None:   self.end_year = sim.pars['end']
+            if self.start_year is None: self.start_year = sim.pars.start
+            if self.end_year is None:   self.end_year = sim.pars.stop
         else:
+            self.years = sc.promotetoarray(self.years)
             self.start_year = self.years[0]
             self.end_year = self.years[-1]
 
         # More validation
-        if not(any(np.isclose(self.start_year, sim.yearvec)) and any(np.isclose(self.end_year, sim.yearvec))):
+        yearvec = sim.t.yearvec
+        if not(any(np.isclose(self.start_year, yearvec)) and any(np.isclose(self.end_year, yearvec))):
             errormsg = 'Years must be within simulation start and end dates.'
             raise ValueError(errormsg)
 
         # Adjustment to get the right end point
-        adj_factor = int(1 / sim.dt) - 1 if sim.dt < 1 else 1
+        dt = sim.pars.dt # TODO: need to eventually replace with own timestep, but not initialized yet since super().init_pre() hasn't been called
+        adj_factor = int(1/dt) - 1 if dt < 1 else 1
 
         # Determine the timepoints at which the intervention will be applied
-        self.start_point = sc.findfirst(sim.yearvec, self.start_year)
-        self.end_point   = sc.findfirst(sim.yearvec, self.end_year) + adj_factor
+        self.start_point = sc.findfirst(yearvec, self.start_year)
+        self.end_point   = sc.findfirst(yearvec, self.end_year) + adj_factor
         self.years       = sc.inclusiverange(self.start_year, self.end_year)
         self.timepoints  = sc.inclusiverange(self.start_point, self.end_point)
-        self.yearvec     = np.arange(self.start_year, self.end_year + adj_factor, sim.dt)
+        self.yearvec     = np.arange(self.start_year, self.end_year + adj_factor, dt) # TODO: integrate with self.t
 
         # Get the probability input into a format compatible with timepoints
         if len(self.years) != len(self.prob):
@@ -156,7 +129,7 @@ class RoutineDelivery(Intervention):
             self.prob = sc.smoothinterp(self.yearvec, self.years, self.prob, smoothness=0)
 
         # Lastly, adjust the probability by the sim's timestep, if it's an annual probability
-        if self.annual_prob: self.prob = 1 - (1 - self.prob) ** sim.dt
+        if self.annual_prob: self.prob = 1 - (1 - self.prob) ** dt
 
         return
 
@@ -166,7 +139,7 @@ class CampaignDelivery(Intervention):
     Base class for any intervention that uses campaign delivery; handles interpolation of input years.
     """
 
-    def __init__(self, years, interpolate=None, prob=None, *args, **kwargs):
+    def __init__(self, *args, years=None, interpolate=None, prob=None, **kwargs):
         super().__init__(*args, **kwargs)
         self.years = sc.promotetoarray(years)
         self.interpolate = True if interpolate is None else interpolate
@@ -174,8 +147,10 @@ class CampaignDelivery(Intervention):
         return
 
     def init_pre(self, sim):
+        super().init_pre(sim)
+
         # Decide whether to apply the intervention at every timepoint throughout the year, or just once.
-        self.timepoints = sc.findnearest(sim.yearvec, self.years)
+        self.timepoints = sc.findnearest(sim.timevec, self.years)
 
         if len(self.prob) == 1:
             self.prob = np.array([self.prob[0]] * len(self.timepoints))
@@ -214,46 +189,49 @@ class BaseTest(Intervention):
         return
 
     def init_pre(self, sim):
-        Intervention.init_pre(self, sim)
+        super().init_pre(sim)
         self.outcomes = {k: np.array([], dtype=int) for k in self.product.hierarchy}
         return
 
-    def deliver(self, sim):
+    def deliver(self):
         """
         Deliver the diagnostics by finding who's eligible, finding who accepts, and applying the product.
         """
+        sim = self.sim
         ti = sc.findinds(self.timepoints, sim.ti)[0]
         prob = self.prob[ti]  # Get the proportion of people who will be tested this timestep
-        eligible_uids = self.check_eligibility(sim)  # Check eligibility
+        eligible_uids = self.check_eligibility()  # Check eligibility
         self.coverage_dist.set(p=prob)
         accept_uids = self.coverage_dist.filter(eligible_uids)
         if len(accept_uids):
-            self.outcomes = self.product.administer(sim, accept_uids)  # Actually administer the diagnostic
+            self.outcomes = self.product.administer(accept_uids)  # Actually administer the diagnostic
         return accept_uids
 
-    def check_eligibility(self, sim):
+    def check_eligibility(self):
         raise NotImplementedError
 
 
 class BaseScreening(BaseTest):
     """
     Base class for screening.
+
     Args:
         kwargs (dict): passed to BaseTest
     """
-    def check_eligibility(self, sim):
+    def check_eligibility(self):
         """
         Check eligibility
         """
         raise NotImplementedError
 
-    def apply(self, sim, module=None):
+    def step(self):
         """
         Perform screening by finding who's eligible, finding who accepts, and applying the product.
         """
+        sim = self.sim
         accept_uids = ss.uids()
-        if sim.ti in self.timepoints:
-            accept_uids = self.deliver(sim)
+        if sim.ti in self.timepoints: # TODO: change to self.ti
+            accept_uids = self.deliver()
             self.screened[accept_uids] = True
             self.screens[accept_uids] += 1
             self.ti_screened[accept_uids] = sim.ti
@@ -266,16 +244,17 @@ class BaseScreening(BaseTest):
 class BaseTriage(BaseTest):
     """
     Base class for triage.
+
     Args:
         kwargs (dict): passed to BaseTest
     """
-    def check_eligibility(self, sim):
-        return sc.promotetoarray(self.eligibility(sim))
+    def check_eligibility(self):
+        return sc.promotetoarray(self.eligibility(self.sim))
 
-    def apply(self, sim):
+    def step(self):
         self.outcomes = {k: np.array([], dtype=int) for k in self.product.hierarchy}
         accept_inds = ss.uids()
-        if sim.t in self.timepoints: accept_inds = self.deliver(sim)
+        if self.sim.t in self.timepoints: accept_inds = self.deliver() # TODO: not robust for timestep
         return accept_inds
 
 
@@ -285,21 +264,12 @@ class routine_screening(BaseScreening, RoutineDelivery):
     See base classes for a description of input arguments.
 
     **Examples**::
+
         screen1 = ss.routine_screening(product=my_prod, prob=0.02) # Screen 2% of the eligible population every year
         screen2 = ss.routine_screening(product=my_prod, prob=0.02, start_year=2020) # Screen 2% every year starting in 2020
         screen3 = ss.routine_screening(product=my_prod, prob=np.linspace(0.005,0.025,5), years=np.arange(2020,2025)) # Scale up screening over 5 years starting in 2020
     """
-
-    def __init__(self, product=None, prob=None, eligibility=None,
-                 years=None, start_year=None, end_year=None, **kwargs):
-        BaseScreening.__init__(self, product=product, eligibility=eligibility, **kwargs)
-        RoutineDelivery.__init__(self, prob=prob, start_year=start_year, end_year=end_year, years=years)
-        return
-
-    def init_pre(self, sim):
-        RoutineDelivery.init_pre(self, sim)  # Initialize this first, as it ensures that prob is interpolated properly
-        BaseScreening.init_pre(self, sim)  # Initialize this next
-        return
+    pass
 
 
 class campaign_screening(BaseScreening, CampaignDelivery):
@@ -312,17 +282,7 @@ class campaign_screening(BaseScreening, CampaignDelivery):
         screen1 = ss.campaign_screening(product=my_prod, prob=0.2, years=2030) # Screen 20% of the eligible population in 2020
         screen2 = ss.campaign_screening(product=my_prod, prob=0.02, years=[2025,2030]) # Screen 20% of the eligible population in 2025 and again in 2030
     """
-
-    def __init__(self, product=None, sex=None, eligibility=None,
-                 prob=None, years=None, interpolate=None, **kwargs):
-        BaseScreening.__init__(self, product=product, sex=sex, eligibility=eligibility, **kwargs)
-        CampaignDelivery.__init__(self, prob=prob, years=years, interpolate=interpolate)
-        return
-
-    def init_pre(self, sim):
-        CampaignDelivery.init_pre(self, sim)
-        BaseScreening.init_pre(self, sim)  # Initialize this next
-        return
+    pass
 
 
 class routine_triage(BaseTriage, RoutineDelivery):
@@ -332,21 +292,10 @@ class routine_triage(BaseTriage, RoutineDelivery):
 
     **Example**:
         # Example: Triage positive screens into confirmatory testing
-        screened_pos = lambda sim: sim.get_intervention('screening').outcomes['positive']
+        screened_pos = lambda sim: sim.interventions.screening.outcomes['positive']
         triage = ss.routine_triage(product=my_triage, eligibility=screen_pos, prob=0.9, start_year=2030)
     """
-
-    def __init__(self, product=None, prob=None, eligibility=None,
-                 years=None, start_year=None, end_year=None, annual_prob=None, **kwargs):
-        BaseTriage.__init__(self, product=product, eligibility=eligibility, **kwargs)
-        RoutineDelivery.__init__(self, prob=prob, start_year=start_year, end_year=end_year, years=years,
-                                 annual_prob=annual_prob)
-        return
-
-    def init_pre(self, sim):
-        RoutineDelivery.init_pre(self, sim)  # Initialize this first, as it ensures that prob is interpolated properly
-        BaseTriage.init_pre(self, sim)  # Initialize this next
-        return
+    pass
 
 
 class campaign_triage(BaseTriage, CampaignDelivery):
@@ -356,20 +305,10 @@ class campaign_triage(BaseTriage, CampaignDelivery):
 
     **Examples**:
         # Example: In 2030, triage all positive screens into confirmatory testing
-        screened_pos = lambda sim: sim.get_intervention('screening').outcomes['positive']
+        screened_pos = lambda sim: sim.interventions.screening.outcomes['positive']
         triage1 = ss.campaign_triage(product=my_triage, eligibility=screen_pos, prob=0.9, years=2030)
     """
-
-    def __init__(self, product=None, sex=None, eligibility=None,
-                 prob=None, years=None, interpolate=None, annual_prob=None, **kwargs):
-        BaseTriage.__init__(self, product=product, sex=sex, eligibility=eligibility, **kwargs)
-        CampaignDelivery.__init__(self, prob=prob, years=years, interpolate=interpolate, annual_prob=annual_prob)
-        return
-
-    def init_pre(self, sim):
-        CampaignDelivery.init_pre(self, sim)
-        BaseTriage.init_pre(self, sim)
-        return
+    pass
 
 
 #%% Treatment interventions
@@ -395,37 +334,37 @@ class BaseTreatment(Intervention):
         return
 
     def init_pre(self, sim):
-        Intervention.init_pre(self, sim)
+        super().init_pre(sim)
         self.outcomes = {k: np.array([], dtype=int) for k in ['unsuccessful', 'successful']} # Store outcomes on each timestep
         return
 
-    def get_accept_inds(self, sim):
+    def get_accept_inds(self):
         """
         Get indices of people who will acccept treatment; these people are then added to a queue or scheduled for receiving treatment
         """
         accept_uids = ss.uids()
-        eligible_uids = self.check_eligibility(sim)  # Apply eligiblity
+        eligible_uids = self.check_eligibility()  # Apply eligiblity
         if len(eligible_uids):
             self.coverage_dist.set(p=self.prob[0])
             accept_uids = self.coverage_dist.filter(eligible_uids)
         return accept_uids
 
-    def get_candidates(self, sim):
+    def get_candidates(self):
         """
         Get candidates for treatment on this timestep. Implemented by derived classes.
         """
         raise NotImplementedError
 
-    def apply(self, sim):
+    def step(self):
         """
         Perform treatment by getting candidates, checking their eligibility, and then treating them.
         """
         # Get indices of who will get treated
-        treat_candidates = self.get_candidates(sim)  # NB, this needs to be implemented by derived classes
-        still_eligible = self.check_eligibility(sim)
+        treat_candidates = self.get_candidates()  # NB, this needs to be implemented by derived classes
+        still_eligible = self.check_eligibility()
         treat_uids = treat_candidates.intersect(still_eligible)
         if len(treat_uids):
-            self.outcomes = self.product.administer(sim, treat_uids)
+            self.outcomes = self.product.administer(treat_uids)
         return treat_uids
 
 
@@ -442,15 +381,15 @@ class treat_num(BaseTreatment):
         self.max_capacity = max_capacity
         return
 
-    def add_to_queue(self, sim):
+    def add_to_queue(self):
         """
         Add people who are willing to accept treatment to the queue
         """
-        accept_inds = self.get_accept_inds(sim)
+        accept_inds = self.get_accept_inds()
         if len(accept_inds): self.queue += accept_inds.tolist()
         return
 
-    def get_candidates(self, sim):
+    def get_candidates(self):
         """
         Get the indices of people who are candidates for treatment
         """
@@ -462,13 +401,13 @@ class treat_num(BaseTreatment):
                 treat_candidates = self.queue[:self.max_capacity]
         return ss.uids(treat_candidates) # TODO: Check
 
-    def apply(self, sim):
+    def step(self):
         """
         Apply treatment. On each timestep, this method will add eligible people who are willing to accept treatment to a
         queue, and then will treat as many people in the queue as there is capacity for.
         """
-        self.add_to_queue(sim)
-        treat_inds = BaseTreatment.apply(self, sim) # Apply method from BaseTreatment class
+        self.add_to_queue()
+        treat_inds = BaseTreatment.step(self) # Apply method from BaseTreatment class
         self.queue = [e for e in self.queue if e not in treat_inds] # Recreate the queue, removing people who were treated
         return treat_inds
 
@@ -488,8 +427,8 @@ class BaseVaccination(Intervention):
          label          (str)           : the name of vaccination strategy
          kwargs         (dict)          : passed to Intervention()
     """
-    def __init__(self, product=None, prob=None, label=None, **kwargs):
-        Intervention.__init__(self, **kwargs)
+    def __init__(self, *args, product=None, prob=None, label=None, **kwargs):
+        super().__init__(*args, **kwargs)
         self.prob = sc.promotetoarray(prob)
         self.label = label
         self._parse_product(product)
@@ -499,16 +438,17 @@ class BaseVaccination(Intervention):
         self.coverage_dist = ss.bernoulli(p=0)  # Placeholder
         return
 
-    def apply(self, sim):
+    def step(self):
         """
         Deliver the diagnostics by finding who's eligible, finding who accepts, and applying the product.
         """
+        sim = self.sim
         accept_uids = np.array([])
         if sim.ti in self.timepoints:
 
             ti = sc.findinds(self.timepoints, sim.ti)[0]
             prob = self.prob[ti]  # Get the proportion of people who will be tested this timestep
-            is_eligible = self.check_eligibility(sim)  # Check eligibility
+            is_eligible = self.check_eligibility()  # Check eligibility
             self.coverage_dist.set(p=prob)
             accept_uids = self.coverage_dist.filter(is_eligible)
 
@@ -528,18 +468,7 @@ class routine_vx(BaseVaccination, RoutineDelivery):
     Routine vaccination - an instance of base vaccination combined with routine delivery.
     See base classes for a description of input arguments.
     """
-
-    def __init__(self, product=None, prob=None, eligibility=None,
-                 start_year=None, end_year=None, years=None, **kwargs):
-
-        BaseVaccination.__init__(self, product=product, eligibility=eligibility, **kwargs)
-        RoutineDelivery.__init__(self, prob=prob, start_year=start_year, end_year=end_year, years=years)
-        return
-
-    def init_pre(self, sim):
-        RoutineDelivery.init_pre(self, sim)  # Initialize this first, as it ensures that prob is interpolated properly
-        BaseVaccination.init_pre(self, sim)  # Initialize this next
-        return
+    pass
 
 
 class campaign_vx(BaseVaccination, CampaignDelivery):
@@ -547,15 +476,4 @@ class campaign_vx(BaseVaccination, CampaignDelivery):
     Campaign vaccination - an instance of base vaccination combined with campaign delivery.
     See base classes for a description of input arguments.
     """
-
-    def __init__(self, product=None, prob=None, eligibility=None,
-                 years=None, interpolate=True, **kwargs):
-
-        BaseVaccination.__init__(self, product=product, eligibility=eligibility, **kwargs)
-        CampaignDelivery.__init__(self, prob=prob, years=years, interpolate=interpolate)
-        return
-
-    def init_pre(self, sim):
-        CampaignDelivery.init_pre(self, sim) # Initialize this first, as it ensures that prob is interpolated properly
-        BaseVaccination.init_pre(self, sim) # Initialize this next
-        return
+    pass
diff --git a/starsim/loop.py b/starsim/loop.py
new file mode 100644
index 0000000..f0569ba
--- /dev/null
+++ b/starsim/loop.py
@@ -0,0 +1,336 @@
+"""
+Parent class for the integration loop.
+"""
+import time
+import numpy as np
+import pandas as pd
+import sciris as sc
+import starsim as ss
+import matplotlib.pyplot as plt
+
+# What classes are externally visible
+__all__ = ['Loop']
+
+
+
+#%% Loop class
+
+class Loop:
+    """ Base class for integration loop """
+    def __init__(self, sim): # TODO: consider eps=1e-6 and round times to this value
+        self.sim = sim
+        self.funcs = None
+        self.abs_tvecs = None
+        self.plan = None
+        self.index = 0 # The next function to execute
+        self.cpu_time = [] # Store the CPU time of execution of each function
+        self.df = None # User-friendly verison of the plan
+        self.cpu_df = None # User-friendly time analysis
+        self.initialized = False
+        return
+
+    def init(self):
+        """ Parse the sim into the integration plan """
+        self.collect_funcs()
+        self.collect_abs_tvecs()
+        self.make_plan()
+        self.initialized = True
+        return
+
+    def __len__(self):
+        if self.initialized:
+            return len(self.plan)
+        else:
+            return 0 # Or None?
+
+    def __iadd__(self, func):
+        """ Allow functions to be added to the function list """
+        parent = func.__self__
+        func_name = func.__name__
+
+        # Get the name if it's defined, the class otherwise; these must match abs_tvecs
+        module = parent.name if isinstance(parent, ss.Module) else parent.__class__.__name__.lower()
+
+        # Create the row and append it to the function list
+        row = dict(func_order=len(self.funcs), module=module, func_name=func_name, func=func)
+        self.funcs.append(row)
+        return self
+
+    def __repr__(self):
+        if self.initialized:
+            arrs = list({len(arr) for arr in self.abs_tvecs.values()})
+            if len(arrs) == 1: arrs = arrs[0] # If all are the same, just use that
+            string = f'Loop(n={len(self)}, funcs={len(self.funcs)}, npts={arrs}, index={self.index})'
+        else:
+            string = 'Loop(initialized=False)'
+        return string
+
+    def disp(self):
+        return sc.pr(self)
+
+    def collect_funcs(self):
+        """ Collect all the callable functions (methods) that comprise the step """
+
+        # Run the simulation step first (updates the distributions)
+        self.funcs = [] # Reset, just in case
+        sim = self.sim
+
+        # Collect the start_steps
+        self += sim.start_step # Note special __iadd__() method above, which appends these to the funcs list
+        for mod in sim.modules:
+            self += mod.start_step
+
+        # Update demographic modules (create new agents from births/immigration, schedule non-disease deaths and emigration)
+        for dem in sim.demographics():
+            self += dem.step
+
+        # Carry out autonomous state changes in the disease modules. This allows autonomous state changes/initializations
+        # to be applied to newly created agents
+        for disease in sim.diseases():
+            if isinstance(disease, ss.Disease): # Could be a connector instead -- TODO, rethink this
+                self += disease.step_state
+
+        # Update connectors
+        for connector in sim.connectors():
+            self += connector.step
+
+        # Update networks - this takes place here in case autonomous state changes at this timestep
+        # affect eligibility for contacts
+        for network in sim.networks():
+            self += network.step
+
+        # Apply interventions - new changes to contacts will be visible and so the final networks can be customized by
+        # interventions, by running them at this point
+        for intv in sim.interventions():
+            self += intv.step
+
+        # Carry out autonomous state changes in the disease modules, including transmission (but excluding deaths)
+        for disease in sim.diseases():
+            self += disease.step
+
+        # Update people who died -- calls disease.step_die() internally
+        self += sim.people.step_die
+
+        # Update results
+        self += sim.people.update_results
+        for mod in sim.modules:
+            self += mod.update_results
+
+        # Apply analyzers
+        for ana in sim.analyzers():
+            self += ana.step
+
+        # Clean up dead agents, increment the time index, and perform other housekeeping tasks
+        for mod in sim.modules:
+            self += mod.finish_step
+        self += sim.people.finish_step
+        self += sim.finish_step
+
+        return self.funcs
+
+    def collect_abs_tvecs(self):
+        """ Collect numerical time arrays for each module """
+        self.abs_tvecs = sc.objdict()
+
+        # Handle the sim and people first
+        sim = self.sim
+        for key in ['sim', 'people']:
+            self.abs_tvecs[key] = sim.t.abstvec
+
+        # Handle all other modules
+        for mod in sim.modules:
+            self.abs_tvecs[mod.name] = mod.t.abstvec
+
+        return self.abs_tvecs
+
+    def make_plan(self):
+        """ Combine the module ordering and the time vectors into the integration plan """
+
+        # Assemble the list of dicts
+        raw = []
+        for func_row in self.funcs:
+            for t in self.abs_tvecs[func_row['module']]:
+                row = func_row.copy()
+                row['time'] = t # Add time column
+                raw.append(row)
+
+        # Turn it into a dataframe
+        self.plan = sc.dataframe(raw)
+
+        # Sort it by step_order, a combination of time and function order
+        self.plan['step_order'] = self.plan.time + ss.options.time_eps*self.plan.func_order
+        self.plan['func_label'] = self.plan.module + '.' + self.plan.func_name
+        col_order = ['time', 'func_order', 'step_order', 'func', 'func_label', 'module', 'func_name'] # Func in the middle to hide it
+        self.plan = self.plan.sort_values('step_order').reset_index(drop=True)[col_order]
+        return
+
+    def store_time(self):
+        """ Store the current time in as high resolution as possible """
+        self.cpu_time.append(time.perf_counter())
+        return
+
+    def run_one_step(self):
+        """
+        Take a single step, i.e. call a single function; only used for debugging purposes.
+
+        Compare sim.run_one_step(), which runs a full timestep (which involves multiple function calls).
+        """
+        f = self.plan.func[self.index] # Get the next function
+        f() # Call it
+        self.index += 1 # Increment the time
+        return
+
+    def run(self, until=None, verbose=None):
+        """ Actually run the integration loop; usually called by sim.run() """
+        # Loop over every function in the integration loop, e.g. disease.step()
+        self.store_time()
+        for f,label in zip(self.plan.func[self.index:], self.plan.func_label[self.index:]):
+            if verbose:
+                row = self.plan[self.index]
+                print(f'Running t={row.time:n}, step={row.step_order}, {label}()')
+
+            f() # Execute the function -- this is where all of Starsim happens!!
+
+            # Tidy up
+            self.index += 1 # Increment the count
+            self.store_time()
+            if until and self.sim.now > until: # Terminate if asked to
+                break
+        return
+
+    def manual_reset(self): # TODO: do we need this? I feel if we don't have it, people will be tempted to manually set loop.index = 0.
+        """
+        Reset the loop to run again. Note, does not reset sim quantities so should
+        only be used for debugging.
+        """
+        self.index = 0
+        self.sim.complete = False
+        return
+
+    def to_df(self):
+        """ Return a user-friendly version of the plan, omitting object columns """
+        # Compute the main dataframe
+        cols = ['time', 'func_order', 'module', 'func_name', 'func_label']
+        if self.plan is not None:
+            df = self.plan[cols].copy() # Need to copy, otherwise it's messed up
+        else:
+            errormsg = f'Simulation "{self.sim}" needs to be initialized before exporting the Loop dataframe'
+            raise RuntimeError(errormsg)
+        times = np.diff(self.cpu_time)
+        if len(times) == len(df):
+            df['cpu_time'] = times
+        else:
+            df['cpu_time'] = np.nan
+        self.df = df
+
+        # Compute the CPU dataframe
+        by_func = df.groupby('func_label')
+        method = dict(func_order='first', module='first', func_name='first', cpu_time='sum')
+        cdf = sc.dataframe(by_func.agg(method))
+        cdf['percent'] = cdf.cpu_time / cdf.cpu_time.sum()*100
+        cdf.insert(cdf.cols.index('cpu_time'), 'calls', by_func.size())
+        cdf.sort_values('cpu_time', inplace=True, ascending=False)
+        self.cpu_df = cdf
+        return df
+
+    def plot(self, simplify=False, fig_kw=None, plot_kw=None, scatter_kw=None):
+        """
+        Plot a diagram of all the events
+
+        Args:
+            simplify (bool): if True, skip update_results and finish_step events, which are automatically applied
+            fig_kw (dict): passed to ``plt.figure()``
+            plot_kw (dict): passed to ``plt.plot()``
+            scatter_kw (dict): passed to ``plt.scatter()``
+        """
+
+        # Assemble data
+        df = self.to_df()
+        if simplify:
+            filter_out = ['update_results', 'finish_step']
+            df = df[~df.func_name.isin(filter_out)]
+        yticks = df.func_order.unique()
+        ylabels = df.func_label.unique()
+        x = df.time
+        y = df.func_order
+
+        # Convert module names to integers for plotting colors
+        mod_int, _ = pd.factorize(df.module)
+        colors = sc.gridcolors(np.unique(mod_int), asarray=True)
+
+        # Do the plotting
+        plot_kw = sc.mergedicts(dict(lw=2, alpha=0.2, c='k'), plot_kw)
+        scatter_kw = sc.mergedicts(dict(s=200, alpha=0.6), scatter_kw)
+        fig = plt.figure(**sc.mergedicts(fig_kw))
+        plt.plot(x, y, **plot_kw)
+        plt.scatter(x, y, c=colors[mod_int], **scatter_kw)
+        plt.yticks(yticks, ylabels)
+        plt.title(f'Integration plan ({len(df)} events)')
+        plt.xlabel(f'Time since simulation start (in {self.sim.pars.unit}s)')
+        plt.grid(True)
+        sc.figlayout()
+        sc.boxoff()
+        return ss.return_fig(fig)
+
+    def plot_cpu(self, bytime=True, fig_kw=None, bar_kw=None):
+        """
+        Plot the CPU time spent on each event; visualization of Loop.cpu_df.
+
+        Args:
+            bytime (bool): if True, order events by total time rather than actual order
+            fig_kw (dict): passed to ``plt.figure()``
+            plot_kw (dict): passed to ``plt.bar()``
+        """
+        # Assemble data
+        if self.cpu_df is None:
+            self.to_df()
+        df = self.cpu_df
+        ylabels = df.index.values
+        if bytime:
+            y = np.arange(len(ylabels))
+        else:
+            y = df.func_order.values
+        y = y[::-1] # Reverse order so plots from top to bottom
+
+        x = df.cpu_time.values
+        pcts = df.percent.values
+
+        if x.max() < 1:
+            x *= 1e3
+            unit = 'ms'
+        else:
+            unit = 's'
+
+        # Assemble labels
+        for i in range(len(df)):
+            timestr = sc.sigfig(x[i], 3) + f' {unit}'
+            pctstr = sc.sigfig(pcts[i], 3) + '%'
+            ylabels[i] += f'()\n{timestr}, {pctstr}'
+
+        # Do the plotting
+        bar_kw = sc.mergedicts(bar_kw)
+        fig = plt.figure(**sc.mergedicts(fig_kw))
+        plt.barh(y, width=x, **bar_kw)
+        plt.yticks(y, ylabels)
+        plt.xlabel(f'CPU time ({unit})')
+        plt.ylabel('Function call')
+        plt.grid(True)
+        sc.figlayout()
+        sc.boxoff()
+        return ss.return_fig(fig)
+
+    def __deepcopy__(self, memo):
+        """ A dataframe that has functions in it doesn't copy well; convert to a dict first """
+        cls = self.__class__
+        new = cls.__new__(cls)
+        memo[id(self)] = new
+        for k, v in self.__dict__.items():
+            if k == 'plan' and isinstance(v, sc.dataframe):
+                origdict = v.to_dict() # Convert to a dictionary
+                newdict = sc.dcp(origdict, memo=memo) # Copy the dict
+                newdf = sc.dataframe(newdict)
+                setattr(new, k, newdf)
+            else:
+                setattr(new, k, sc.dcp(v, memo=memo)) # Regular deepcopy
+        return new
+
diff --git a/starsim/modules.py b/starsim/modules.py
index b8e2a82..6ecd6e0 100644
--- a/starsim/modules.py
+++ b/starsim/modules.py
@@ -1,11 +1,14 @@
 """
-General module class -- base class for diseases, interventions, etc.
+General module class -- base class for diseases, interventions, etc. Also
+defines Analyzers and Connectors.
 """
-
 import sciris as sc
 import starsim as ss
+from functools import partial
 
-__all__ = ['module_map', 'find_modules', 'Module', 'Connector']
+__all__ = ['module_map', 'find_modules', 'Base', 'Module', 'Analyzer', 'Connector']
+
+module_args = ['name', 'label'] # Define allowable module arguments
 
 
 def module_map(key=None):
@@ -21,11 +24,11 @@ def module_map(key=None):
     return module_map if key is None else module_map[key]
 
 
-def find_modules(key=None):
-    """ Find all subclasses of Module, divided by type """
+def find_modules(key=None, flat=False):
+    """ Find all subclasses of Module present in Starsim, divided by type """
     modules = sc.objdict()
     modmap = module_map()
-    attrs = dir(ss)
+    attrs = dir(ss) # Find all attributes in Starsim (note: does not parse user code)
     for modkey, modtype in modmap.items(): # Loop over each module type
         modules[modkey] = sc.objdict()
         for attr in attrs: # Loop over each attribute (inefficient, but doesn't need to be optimized)
@@ -38,124 +41,240 @@ def find_modules(key=None):
                     modules[modkey][low_attr.removesuffix('net')] = item
             except:
                 pass
+    if flat:
+        modules = sc.objdict({k:v for vv in modules.values() for k,v in vv.items()}) # Unpack the nested dict into a flat one
     return modules if key is None else modules[key]
-    
 
-class Module(sc.quickobj):
 
-    def __init__(self, name=None, label=None, requires=None):
-        self.set_metadata(name, label, requires) # Usually reset as part of self.update_pars()
-        self.pars = ss.Pars() # Usually populated via self.default_pars()
-        self.results = ss.Results(self.name)
-        self.initialized = False
-        self.finalized = False
-        return
-    
+class Base(sc.quickobj):
+    """
+    The parent class for Sim and Module objects
+    """
     def __bool__(self):
         """ Ensure that zero-length modules (e.g. networks) are still truthy """
         return True
-    
-    def set_metadata(self, name, label, requires):
+
+    def __len__(self):
+        """ The length of a module is the number of timepoints; see also len(sim) """
+        try:    return self.t.npts
+        except: return 0
+
+    def disp(self, output=False, **kwargs):
+        """ Display the full object """
+        out = sc.prepr(self, **kwargs)
+        if not output:
+            print(out)
+        else:
+            return out
+
+    @property
+    def ti(self):
+        """ Get the current module timestep """
+        try:    return self.t.ti
+        except: return None
+
+    @property
+    def now(self):
+        """ Shortcut to self.t.now() """
+        try:    return self.t.now()
+        except: return None
+
+    @property
+    def timevec(self):
+        """ Shortcut to self.t.timevec """
+        try:    return self.t.timevec
+        except: return None
+
+    def copy(self, die=True):
+        """
+        Perform a deep copy of the module/sim
+
+        Args:
+            die (bool): whether to raise an exception if copy fails (else, try a shallow copy)
+        """
+        out = sc.dcp(self, die=die)
+        return out
+
+
+class Module(Base):
+    """
+    The main base class for all Starsim modules: diseases, networks, interventions, etc.
+
+    Args:
+        name (str): a short, key-like name for the module (e.g. "randomnet")
+        label (str): the full, human-readable name for the module (e.g. "Random network")
+        kwargs (dict): passed to ss.Time() (e.g. start, stop, unit, dt)
+    """
+
+    def __init__(self, name=None, label=None, **kwargs):
+        # Handle parameters
+        self.pars = ss.Pars() # Usually populated via self.define_pars()
+        self.set_metadata(name, label) # Usually reset as part of self.update_pars()
+        self.t = ss.Time(**kwargs, name=self.name, init=False)
+
+        # Properties to be added by init_pre()
+        self.sim = None
+        self.dists = None # Turned into a Dists object by sim.init_dists() if this module has dists
+        self.results = ss.Results(self.name)
+
+        # Finish initialization
+        self.pre_initialized = False
+        self.initialized = False
+        self.finalized = False
+        return
+
+    def __call__(self, *args, **kwargs):
+        """ Allow modules to be called like functions """
+        return self.step(*args, **kwargs)
+
+    def _reconcile(self, key, value=None, default=None):
+        """ Reconcile module attributes, parameters, and input arguments """
+        parval = self.pars.get(key)
+        attrval = getattr(self, key, parval)
+        val = sc.ifelse(value, attrval, default)
+        return val
+
+    def set_metadata(self, name=None, label=None):
         """ Set metadata for the module """
-        self.name = sc.ifelse(name, getattr(self, 'name', self.__class__.__name__.lower())) # Default name is the class name
-        self.label = sc.ifelse(label, getattr(self, 'label', self.name))
-        self.requires = sc.mergelists(requires)
+        # Validation
+        for key,val in dict(name=name, label=label).items():
+            if val is not None:
+                if not isinstance(val, str):
+                    errormsg = f'Invalid value for {key}: must be str, not {type(val)}: {val}'
+                    raise TypeError(errormsg)
+
+        # Set values
+        self.name = self._reconcile('name', name, self.__class__.__name__.lower())
+        self.label = self._reconcile('label', label, self.name)
         return
-    
-    def default_pars(self, inherit=False, **kwargs):
+
+    def define_pars(self, inherit=True, **kwargs): # TODO: think if inherit should default to true or false
         """ Create or merge Pars objects """
         if inherit: # Merge with existing
             self.pars.update(**kwargs, create=True)
         else: # Or overwrite
             self.pars = ss.Pars(**kwargs)
         return self.pars
-    
+
     def update_pars(self, pars, **kwargs):
         """ Pull out recognized parameters, returning the rest """
         pars = sc.mergedicts(pars, kwargs)
-        
+
         # Update matching module parameters
         matches = {}
         for key in list(pars.keys()): # Need to cast to list to avoid "dict changed during iteration"
             if key in self.pars:
                 matches[key] = pars.pop(key)
         self.pars.update(matches)
-                
+
         # Update module attributes
-        metadata = {key:pars.pop(key, None) for key in ['name', 'label', 'requires']}
+        metadata = {key:pars.get(key, self.pars.get(key)) for key in module_args}
+        timepars = {key:pars.get(key, self.pars.get(key)) for key in ss.time.time_args}
         self.set_metadata(**metadata)
-        
+        self.t.update(**timepars)
+
         # Should be no remaining pars
-        if len(pars):
-            errormsg = f'{len(pars)} unrecognized arguments for {self.name}: {sc.strjoin(pars.keys())}'
+        remaining = set(pars.keys()) - set(module_args + ss.time.time_args)
+        if len(remaining):
+            errormsg = f'{len(pars)} unrecognized arguments for {self.name}: {sc.strjoin(remaining)}'
             raise ValueError(errormsg)
         return
-    
-    def check_requires(self, sim):
-        """ Check that the module's requirements (of other modules) are met """
-        errs = sc.autolist()
-        all_names = [m.__class__ for m in sim.modules] + [m.name for m in sim.modules if hasattr(m, 'name')]
-        for req in self.requires:
-            if req not in all_names:
-                errs += req
-        if len(errs):
-            errormsg = f'{self.name} (label={self.label}) requires the following module(s), but the Sim does not contain them.'
-            errormsg += sc.newlinejoin(errs)
-            raise Exception(errormsg)
-        return
 
-    def init_pre(self, sim):
+    def init_pre(self, sim, force=False):
         """
         Perform initialization steps
 
         This method is called once, as part of initializing a Sim. Note: after
-        initialization, initialized=False until init_post() is called (which is after
+        initialization, initialized=False until init_vals() is called (which is after
         distributions are initialized).
-        
-        Note: distributions cannot be used here because they aren't initialized 
-        until after init_pre() is called. Use init_post() instead.
         """
-        self.check_requires(sim)
-        self.sim = sim # Link back to the sim object
-        ss.link_dists(self, sim, skip=ss.Sim) # Link the distributions to sim and module
-        sim.pars[self.name] = self.pars
-        sim.results[self.name] = self.results
-        sim.people.add_module(self) # Connect the states to the people
+        if force or not self.pre_initialized:
+            self.sim = sim # Link back to the sim object
+            ss.link_dists(self, sim, skip=ss.Sim) # Link the distributions to sim and module
+            sim.pars[self.name] = self.pars
+            sim.results[self.name] = self.results
+            sim.people.add_module(self) # Connect the states to the people
+            self.init_time() # Initialize the modules' time parameters and link them to the sim
+            self.init_results()
+            self.pre_initialized = True
         return
-    
+
+    def init_results(self):
+        """ Initialize any results required; part of init_pre() """
+        self.results.timevec = self.t.timevec # Store the timevec in the results for plotting
+        return
+
     def init_post(self):
-        """ Initialize the values of the states, including calling distributions; the last step of initialization """
+        """ Initialize the values of the states; the last step of initialization """
         for state in self.states:
             if not state.initialized:
                 state.init_vals()
         self.initialized = True
         return
-    
-    def disp(self, output=False):
-        """ Display the full object """
-        out = sc.prepr(self)
-        if not output:
-            print(out)
-        else:
-            return out
+
+    def init_time(self, force=False):
+        """ Initialize all time parameters by ensuring all parameters are initialized; part of init_post() """
+        # Update time and initialize
+        self.t.init(sim=self.sim) # Sets the absolute sim time vector
+
+        # Find all time parameters in the module
+        timepars = sc.search(self.pars, type=ss.TimePar) # Should it be self or self.pars?
+
+        # Initialize them with the parent module
+        for timepar in timepars.values():
+            if force or not timepar.initialized:
+                timepar.init(parent=self.t, die=False) # In some cases, the values can't be initialized; that's OK here
+        return
+
+    def match_time_inds(self, inds=None):
+         """ Find the nearest matching sim time indices for the current module """
+         if inds is None: inds = Ellipsis
+         self_tvec = self.t.abstvec
+         sim_tvec = self.sim.t.abstvec
+         if len(self_tvec) == len(sim_tvec): # Shortcut to avoid doing matching
+             return inds
+         else:
+             out = sc.findnearest(sim_tvec, [inds])
+             return out
+
+    def start_step(self):
+        """ Tasks to perform at the beginning of the step """
+        if self.dists is not None: # Will be None if no distributions are defined
+            self.dists.jump_dt() # Advance random number generators forward for calls on this step
+        return
+
+    def step(self):
+        """ Define how the module updates over time -- the key part of Starsim!! """
+        errormsg = f'Module "{self.name}" does not define a "step" method: use "def step(self): pass" if this is intentional'
+        raise NotImplementedError(errormsg)
+
+    def finish_step(self):
+        """ Define what should happen at the end of the step; at minimum, increment ti """
+        self.t.ti += 1
+        return
+
+    def update_results(self):
+        """ Perform any results updates on each timestep """
+        pass
 
     def finalize(self):
+        """ Perform any final operations, such as removing unneeded data """
         self.finalize_results()
         self.finalized = True
         return
 
-    def finalize_results(self):
+    def finalize_results(self): # TODO: this is confusing, needs to be not redefined by the user, or called *after* a custom finalize_results()
         """ Finalize results """
         # Scale results
         for reskey, res in self.results.items():
             if isinstance(res, ss.Result) and res.scale:
                 self.results[reskey] = self.results[reskey]*self.sim.pars.pop_scale
         return
-    
-    def add_states(self, *args, check=True):
+
+    def define_states(self, *args, check=True):
         """
-        Add states to the module with the same attribute name as the state
-        
+        Define states of the module with the same attribute name as the state
+
         Args:
             args (states): list of states to add
             check (bool): whether to check that the object being added is a state
@@ -167,13 +286,31 @@ class Module(sc.quickobj):
                 state = ss.State(**arg)
             else:
                 state = arg
-                
+
             if check:
                 assert isinstance(state, ss.Arr), f'Could not add {state}: not an Arr object'
-                
+
+            # Add the state to the module
             setattr(self, state.name, state)
         return
 
+    def define_results(self, *args, check=True):
+        """ Add results to the module """
+        for arg in args:
+            if isinstance(arg, (list, tuple)):
+                result = ss.Result(*arg)
+            elif isinstance(arg, dict):
+                result = ss.Result(**arg)
+            else:
+                result = arg
+
+            # Update with module information
+            result.update(module=self.name, shape=self.t.npts, timevec=self.t.timevec)
+
+            # Add the result to the dict of results; does automatic checking
+            self.results += result
+        return
+
     @property
     def states(self):
         """
@@ -200,6 +337,7 @@ class Module(sc.quickobj):
     def create(cls, name, *args, **kwargs):
         """
         Create a module instance by name
+
         Args:
             name (str): A string with the name of the module class in lower case, e.g. 'sir'
         """
@@ -208,7 +346,20 @@ class Module(sc.quickobj):
                 return subcls(*args, **kwargs)
         else:
             raise KeyError(f'Module "{name}" did not match any known Starsim modules')
-            
+
+    @classmethod
+    def from_func(cls, func):
+        """ Create an module from a function """
+        def step(mod): # TODO: see if this can be done more simply
+            return mod.func(mod.sim)
+        name = func.__name__
+        mod = cls(name=name)
+        mod.func = func
+        mod.step = partial(step, mod)
+        mod.step.__name__ = name # Manually add these in as for a regular class method
+        mod.step.__self__ = mod
+        return mod
+
     def to_json(self):
         """ Export to a JSON-compatible format """
         out = sc.objdict()
@@ -219,22 +370,37 @@ class Module(sc.quickobj):
         return out
 
     def plot(self):
+        """ Plot all results in the module """
         with sc.options.with_style('fancy'):
             flat = sc.flattendict(self.results, sep=': ')
-            yearvec = self.sim.yearvec
+            timevec = self.t.timevec
             fig, axs = sc.getrowscols(len(flat), make=True)
             for ax, (k, v) in zip(axs.flatten(), flat.items()):
-                ax.plot(yearvec, v)
+                ax.plot(timevec, v)
                 ax.set_title(k)
                 ax.set_xlabel('Year')
-        return fig
+        return ss.return_fig(fig)
+
+
+class Analyzer(Module):
+    """
+    Base class for Analyzers. Analyzers are used to provide more detailed information
+    about a simulation than is available by default -- for example, pulling states
+    out of sim.people on a particular timestep before they get updated on the next step.
+
+    The key method of the analyzer is ``step()``, which is called with the sim
+    on each timestep.
+
+    To retrieve a particular analyzer from a sim, use sim.get_analyzer().
+    """
+    pass
 
 
 class Connector(Module):
     """
-    Define a Connector, which mediates interactions between disease modules
-    
+    Base class for Connectors, which mediate interactions between disease (or other) modules
+
     Because connectors can do anything, they have no specified structure: it is
-    up to the user to define how they behave.    
+    up to the user to define how they behave.
     """
     pass
diff --git a/starsim/network.py b/starsim/networks.py
similarity index 57%
rename from starsim/network.py
rename to starsim/networks.py
index a231583..5d4649a 100644
--- a/starsim/network.py
+++ b/starsim/networks.py
@@ -1,7 +1,6 @@
-'''
+"""
 Networks that connect people within a population
-'''
-
+"""
 import networkx as nx
 import numpy as np
 import numba as nb
@@ -10,17 +9,24 @@ import starsim as ss
 import scipy.optimize as spo
 import scipy.spatial as spsp
 
-# CK: need to remove this, but slows down the code otherwise
+# This has a significant impact on runtime, surprisingly
 ss_float_ = ss.dtypes.float
 ss_int_ = ss.dtypes.int
 
 
 # Specify all externally visible functions this file defines; see also more definitions below
-__all__ = ['Network', 'DynamicNetwork', 'SexualNetwork']
+__all__ = ['Route', 'Network', 'DynamicNetwork', 'SexualNetwork']
 
 # %% General network classes
 
-class Network(ss.Module):
+class Route(ss.Module):
+    """
+    A transmission route -- e.g., a network, mixing pool, environmental transmission, etc.
+    """
+    pass
+
+
+class Network(Route):
     """
     A class holding a single network of contact edges (connections) between people
     as well as methods for updating these.
@@ -30,10 +36,8 @@ class Network(ss.Module):
     the connection.
 
     Args:
-        p1 (array): an array of length N, the number of connections in the network, with the indices of people
-                   on one side of the connection.
-        p2 (array): an array of length N, the number of connections in the network, with the indices of people
-                    on the other side of the connection.
+        p1 (array): an array of length N, the number of connections in the network, with the indices of people on one side of the connection.
+        p2 (array): an array of length N, the number of connections in the network, with the indices of people on the other side of the connection.
         beta (array): an array representing relative transmissibility of each connection for this network - TODO, do we need this?
         label (str): the name of the network (optional)
         kwargs (dict): other keys copied directly into the network
@@ -60,9 +64,9 @@ class Network(ss.Module):
         network2 = ss.Network(**network, index=index, self_conn=self_conn, label=network.label)
     """
 
-    def __init__(self, key_dict=None, prenatal=False, postnatal=False, name=None, label=None, requires=None, **kwargs):
+    def __init__(self, key_dict=None, prenatal=False, postnatal=False, name=None, label=None, **kwargs):
         # Initialize as a module
-        super().__init__(name=name, label=label, requires=requires)
+        super().__init__(name=name, label=label)
 
         # Each relationship is characterized by these default set of keys, plus any user- or network-supplied ones
         default_keys = sc.objdict(
@@ -88,37 +92,50 @@ class Network(ss.Module):
         self.participant = ss.BoolArr('participant')
         self.validate_uids()
         return
-    
+
     @property
     def p1(self):
+        """ The first half of a network edge (person 1) """
         return self.edges['p1'] if 'p1' in self.edges else None
-    
+
     @property
     def p2(self):
+        """ The second half of a network edge (person 2) """
         return self.edges['p2'] if 'p2' in self.edges else None
 
     @property
     def beta(self):
+        """ Relative transmission on each network edge """
         return self.edges['beta'] if 'beta' in self.edges else None
 
+    def init_results(self):
+        """ Store network length by default """
+        super().init_results()
+        self.define_results(
+            ss.Result('n_edges', dtype=int, scale=True, label='Number of edges', auto_plot=False)
+        )
+        return
+
     def init_post(self, add_pairs=True):
         super().init_post()
         if add_pairs: self.add_pairs()
         return
 
     def __len__(self):
-        try:
-            return len(self.edges.p1)
-        except:  # pragma: no cover
-            return 0
+        """ The length is the number of edges """
+        try:    return len(self.edges.p1)
+        except: return 0
 
     def __repr__(self, **kwargs):
         """ Convert to a dataframe for printing """
-        namestr = self.name
-        labelstr = f'"{self.label}"' if self.label else '<no label>'
-        keys_str = ', '.join(self.edges.keys())
-        output = f'{namestr}({labelstr}, {keys_str})\n'  # e.g. Network("r", p1, p2, beta)
-        output += self.to_df().__repr__()
+        try:
+            namestr = self.name
+            labelstr = f'"{self.label}"' if self.label else '<no label>'
+            keys_str = ', '.join(self.edges.keys())
+            output = f'{namestr}({labelstr}, {keys_str})\n'  # e.g. Network("r", p1, p2, beta)
+            output += self.to_df().__repr__()
+        except:
+            output = sc.prepr(self, vals=False)
         return output
 
     def __contains__(self, item):
@@ -149,7 +166,7 @@ class Network(ss.Module):
         states that depend on other states.
         """
         pass
-    
+
     def validate_uids(self):
         """ Ensure that p1, p2 are both UID arrays """
         edges = self.edges
@@ -184,6 +201,7 @@ class Network(ss.Module):
     def get_inds(self, inds, remove=False):
         """
         Get the specified indices from the edgelist and return them as a dict.
+
         Args:
             inds (int, array, slice): the indices to find
             remove (bool): whether to remove the indices
@@ -207,25 +225,48 @@ class Network(ss.Module):
         popped_inds = self.get_inds(inds, remove=True)
         return popped_inds
 
-    def append(self, contacts=None, **kwargs):
+    def append(self, edges=None, **kwargs):
         """
-        Append contacts to the current network.
+        Append edges to the current network.
 
         Args:
-            contacts (dict): a dictionary of arrays with keys p1,p2,beta, as returned from network.pop_inds()
+            edges (dict): a dictionary of arrays with keys p1,p2,beta, as returned from network.pop_inds()
         """
-        contacts = sc.mergedicts(contacts, kwargs)
+        edges = sc.mergedicts(edges, kwargs)
         for key in self.meta_keys():
             curr_arr = self.edges[key]
             try:
-                new_arr = contacts[key]
+                new_arr = edges[key]
             except KeyError:
-                errormsg = f'Cannot append contacts since required key "{key}" is missing'
+                errormsg = f'Cannot append edges since required key "{key}" is missing'
                 raise KeyError(errormsg)
             self.edges[key] = np.concatenate([curr_arr, new_arr])  # Resize to make room, preserving dtype
         self.validate_uids()
         return
 
+    def update_results(self):
+        """ Store the number of edges in the network """
+        self.results['n_edges'][self.ti] = len(self)
+        return
+
+    def to_graph(self): # pragma: no cover
+        """
+        Convert to a networkx DiGraph
+
+        **Example**::
+
+            import networkx as nx
+            sim = ss.Sim(n_agents=100, networks='mf').init()
+            G = sim.networks.randomnet.to_graph()
+            nx.draw(G)
+        """
+        keys = [('p1', int), ('p2', int), ('beta', float)]
+        data = [np.array(self.edges[k], dtype=dtype).tolist() for k,dtype in keys]
+        G = nx.DiGraph()
+        G.add_weighted_edges_from(zip(*data), weight='beta')
+        nx.set_edge_attributes(G, self.label, name='layer')
+        return G
+
     def to_dict(self):
         """ Convert to dictionary """
         d = {k: self.edges[k] for k in self.meta_keys()}
@@ -248,8 +289,8 @@ class Network(ss.Module):
         """
         Find all contacts of the specified people
 
-        For some purposes (e.g. contact tracing) it's necessary to find all the contacts
-        associated with a subset of the people in this network. Since contacts are bidirectional
+        For some purposes (e.g. contact tracing) it's necessary to find all the edges
+        associated with a subset of the people in this network. Since edges are bidirectional
         it's necessary to check both p1 and p2 for the target indices. The return type is a Set
         so that there is no duplication of indices (otherwise if the Network has explicit
         symmetric interactions, they could appear multiple times). This is also for performance so
@@ -258,7 +299,7 @@ class Network(ss.Module):
         infection, e.g. exposure risk.
 
         Args:
-            inds (array): indices of people whose contacts to return
+            inds (array): indices of people whose edges to return
             as_array (bool): if true, return as sorted array (otherwise, return as unsorted set)
 
         Returns:
@@ -267,7 +308,7 @@ class Network(ss.Module):
         Example: If there were a network with
         - p1 = [1,2,3,4]
         - p2 = [2,3,1,4]
-        Then find_contacts([1,3]) would return {1,2,3}
+        Then find_edges([1,3]) would return {1,2,3}
         """
 
         # Check types
@@ -276,7 +317,7 @@ class Network(ss.Module):
         if inds.dtype != np.int64:  # pragma: no cover # This is int64 since indices often come from utils.true(), which returns int64
             inds = np.array(inds, dtype=np.int64)
 
-        # Find the contacts
+        # Find the edges
         contact_inds = ss.find_contacts(self.edges.p1, self.edges.p2, inds)
         if as_array:
             contact_inds = np.fromiter(contact_inds, dtype=ss_int_)
@@ -288,10 +329,6 @@ class Network(ss.Module):
         """ Define how pairs of people are formed """
         pass
 
-    def update(self):
-        """ Define how pairs/connections evolve (in time) """
-        pass
-
     def remove_uids(self, uids):
         """
         Remove interactions involving specified UIDs
@@ -304,9 +341,10 @@ class Network(ss.Module):
 
         return
 
-    def beta_per_dt(self, disease_beta=None, dt=None, uids=None):
-        if uids is None: uids = Ellipsis
-        return self.edges.beta[uids] * disease_beta * dt
+    def net_beta(self, disease_beta=None, inds=None, disease=None):
+        """ Calculate the beta for the given disease and network """
+        if inds is None: inds = Ellipsis
+        return self.edges.beta[inds] * disease_beta # Beta should already include dt if desired
 
 
 class DynamicNetwork(Network):
@@ -316,9 +354,14 @@ class DynamicNetwork(Network):
         super().__init__(key_dict=key_dict, **kwargs)
         return
 
+    def step(self):
+        self.end_pairs()
+        self.add_pairs()
+        return
+
     def end_pairs(self):
         people = self.sim.people
-        self.edges.dur = self.edges.dur - self.sim.dt
+        self.edges.dur = self.edges.dur - self.t.dt # TODO: think about whether this is right # Update: it is, if duration is *NOT* a ss.dur! Otherwise it should be -1, in timestep units
 
         # Non-alive agents are removed
         active = (self.edges.dur > 0) & people.alive[self.edges.p1] & people.alive[self.edges.p2]
@@ -347,19 +390,18 @@ class SexualNetwork(DynamicNetwork):
         # This property could also be overwritten by a NetworkConnector
         # which could incorporate information about membership in other
         # contact networks
-        right_sex = people[sex]
-        is_active = self.active(people)
-        is_available = (right_sex & is_active).uids
-        still_available = is_available.remove(self.members)
-        return still_available
+        available = people[sex] & self.active(people)
+        available[self.edges.p1] = False
+        available[self.edges.p2] = False
+        return available.uids
 
-    def beta_per_dt(self, disease_beta=None, dt=None, uids=None):
-        if uids is None: uids = Ellipsis
-        return self.edges.beta[uids] * (1 - (1 - disease_beta) ** (self.edges.acts[uids] * dt))
+    def net_beta(self, disease_beta=None, inds=None, disease=None):
+        if inds is None: inds = Ellipsis
+        return self.edges.beta[inds] * (1 - (1 - disease_beta) ** (self.edges.acts[inds] * self.t.dt))
 
 
 # %% Specific instances of networks
-__all__ += ['StaticNet', 'RandomNet', 'NullNet', 'MFNet', 'MSMNet', 'EmbeddingNet', 'MaternalNet', 'PrenatalNet', 'PostnatalNet']
+__all__ += ['StaticNet', 'RandomNet', 'ErdosRenyiNet', 'DiskNet', 'NullNet', 'MFNet', 'MSMNet', 'EmbeddingNet', 'MaternalNet', 'PrenatalNet', 'PostnatalNet']
 
 
 class StaticNet(Network):
@@ -387,7 +429,7 @@ class StaticNet(Network):
     def __init__(self, graph=None, pars=None, **kwargs):
         super().__init__()
         self.graph = graph
-        self.default_pars(seed=True, p=None, n_contacts=10)
+        self.define_pars(seed=True, p=None, n_contacts=10)
         self.update_pars(pars, **kwargs)
         self.dist = ss.Dist(name='StaticNet')
         return
@@ -401,7 +443,7 @@ class StaticNet(Network):
         if self.pars.p is None: # Convert from n_contacts to probability
             self.pars.p = n_contacts/self.n_agents
         return
-    
+
     def init_post(self):
         super().init_post()
         if 'seed' in self.pars and self.pars.seed is True:
@@ -413,7 +455,7 @@ class StaticNet(Network):
                 print(f"{str(e)}: networkx {self.graph.name} not supported. Try using ss.NullNet().")
                 raise e
         self.validate_pop(self.n_agents)
-        self.get_contacts()
+        self.get_edges()
         return
 
     def validate_pop(self, n_agents):
@@ -427,15 +469,15 @@ class StaticNet(Network):
             errmsg = f"The nx generator {self.graph.name} produced a graph with no edges"
             raise ValueError(errmsg)
 
-    def get_contacts(self):
+    def get_edges(self):
         p1s = []
         p2s = []
         for edge in self.graph.edges():
             p1, p2 = edge
             p1s.append(p1)
             p2s.append(p2)
-        contacts = dict(p1=p1s, p2=p2s, beta=np.ones_like(p1s))
-        self.append(contacts)
+        edges = dict(p1=p1s, p2=p2s, beta=np.ones_like(p1s))
+        self.append(edges)
         return
 
 
@@ -445,9 +487,9 @@ class RandomNet(DynamicNetwork):
     def __init__(self, pars=None, key_dict=None, **kwargs):
         """ Initialize """
         super().__init__(key_dict=key_dict)
-        self.default_pars(
+        self.define_pars(
             n_contacts = ss.constant(10),
-            dur = 0,
+            dur = 0, # Note; network edge durations are required to have the same unit as the network
         )
         self.update_pars(pars, **kwargs)
         self.dist = ss.Dist(distname='RandomNet') # Default RNG
@@ -458,7 +500,7 @@ class RandomNet(DynamicNetwork):
         return
 
     @staticmethod
-    @nb.njit(cache=True)
+    @nb.njit(fastmath=True, parallel=False, cache=True)
     def get_source(inds, n_contacts):
         """ Optimized helper function for getting contacts """
         total_number_of_half_edges = np.sum(n_contacts)
@@ -470,9 +512,9 @@ class RandomNet(DynamicNetwork):
             count += n
         return source
 
-    def get_contacts(self, inds, n_contacts):
+    def get_edges(self, inds, n_contacts):
         """
-        Efficiently generate contacts
+        Efficiently find edges
 
         Note that because of the shuffling operation, each person is assigned 2N contacts
         (i.e. if a person has 5 contacts, they appear 5 times in the 'source' array and 5
@@ -480,7 +522,7 @@ class RandomNet(DynamicNetwork):
         function should be HALF of the total contacts a person is expected to have, if both
         the source and target array outputs are used (e.g. for social contacts)
 
-        adjusted_number_of_contacts = np.round(number_of_contacts / 2).astype(cvd.default_int)
+        adjusted_number_of_contacts = np.round(number_of_contacts / 2).astype(ss.dtype.int)
 
         Whereas for asymmetric contacts (e.g. staff-public interactions) it might not be necessary
 
@@ -494,36 +536,168 @@ class RandomNet(DynamicNetwork):
         """
         source = self.get_source(inds, n_contacts)
         target = self.dist.rng.permutation(source)
-        self.dist.jump() # Reset the RNG manually # TODO, think if there's a better way
+        self.dist.jump() # Reset the RNG manually; does not auto-jump since using rng directly above # TODO, think if there's a better way
         return source, target
 
-    def update(self):
-        self.end_pairs()
-        self.add_pairs()
-        return
-
     def add_pairs(self):
-        """ Generate contacts """
+        """ Generate edges """
         people = self.sim.people
+        born = people.alive & (people.age > 0)
         if isinstance(self.pars.n_contacts, ss.Dist):
-            number_of_contacts = self.pars.n_contacts.rvs(people.uid[people.alive])  # or people.uid?
+            number_of_contacts = self.pars.n_contacts.rvs(born.uids)  # or people.uid?
         else:
-            number_of_contacts = np.full(len(people), self.pars.n_contacts)
+            number_of_contacts = np.ones(len(people))*self.pars.n_contacts
 
-        number_of_contacts = np.round(number_of_contacts / 2).astype(ss_int_)  # One-way contacts
+        number_of_contacts = sc.randround(number_of_contacts / 2).astype(ss_int_)  # One-way contacts
 
-        p1, p2 = self.get_contacts(people.uid.__array__(), number_of_contacts)
+        p1, p2 = self.get_edges(born.uids, number_of_contacts)
         beta = np.ones(len(p1), dtype=ss_float_)
 
         if isinstance(self.pars.dur, ss.Dist):
             dur = self.pars.dur.rvs(p1)
         else:
-            dur = np.full(len(p1), self.pars.dur)
-        
+            dur = np.ones(len(p1))*self.pars.dur # Other option would be np.full(len(p1), self.pars.dur.x), but this is harder to read
+
         self.append(p1=p1, p2=p2, beta=beta, dur=dur)
         return
 
 
+class ErdosRenyiNet(DynamicNetwork):
+    """
+    In the Erdos-Renyi network, every possible edge has a probability, p, of
+    being created on each time step.
+
+    The degree of each node will have a binomial distribution, considering each
+    of the N-1 possible edges connection this node to the others will be created
+    with probability p.
+
+    Please be careful with the `dur` parameter. When set to 0, new edges will be
+    created on each time step. If positive, edges will persist for `dur` years.
+    Note that the existence of edges from previous time steps will not prevent
+    or otherwise alter the creation of new edges on each time step, edges will
+    accumulate over time.
+    """
+
+    def __init__(self, pars=None, key_dict=None, **kwargs):
+        """ Initialize """
+        super().__init__(key_dict=key_dict)
+        self.define_pars(
+            p = 0.1, # Probability of each edge
+            dur = 0, # Duration of zero ensures that new random edges are formed on each time step
+        )
+        self.update_pars(pars, **kwargs)
+        self.randint = ss.randint(low=np.iinfo('int64').min, high=np.iinfo('int64').max, dtype=np.int64) # Used to draw a random number for each agent as part of creating edges
+        return
+
+    def init_post(self):
+        self.add_pairs()
+        return
+
+    def add_pairs(self):
+        """ Generate contacts """
+        people = self.sim.people
+        born_uids = (people.age > 0).uids
+
+        # Sample integers
+        ints = self.randint.rvs(born_uids)
+
+        # All possible edges are upper triangle of complete matrix
+        idx1, idx2 = np.triu_indices(n=len(born_uids), k=1)
+
+        # Use integers to create random numbers per edge
+        i1 = ints[idx1]
+        i2 = ints[idx2]
+        r = ss.utils.combine_rands(i1, i2) # TODO: use ss.multi_rand()
+        edge = r <= self.pars.p
+
+        p1 = idx1[edge]
+        p2 = idx2[edge]
+        beta = np.ones(len(p1), dtype=ss_float_)
+
+        if isinstance(self.pars.dur, ss.Dist):
+            dur = self.pars.dur.rvs(p1)
+        else:
+            dur = np.ones(len(p1))*self.pars.dur
+
+        self.append(p1=p1, p2=p2, beta=beta, dur=dur)
+        return
+
+
+class DiskNet(Network):
+    """
+    Disk graph in which edges are made between agents located within a user-defined radius.
+
+    Interactions take place within a square with edge length of 1. Agents are
+    initialized to have a random position and orientation within this square. On
+    each time step, agents advance v*dt in the direction they are pointed. When
+    encountering a wall, agents are reflected.
+
+    Edges are formed between two agents if they are within r distance of each other.
+    """
+
+    def __init__(self, pars=None, key_dict=None, **kwargs):
+        """ Initialize """
+        super().__init__(key_dict=key_dict)
+        self.define_pars(
+            r = 0.1, # Radius
+            v = 0.05, # Velocity
+        )
+        self.update_pars(pars, **kwargs)
+        self.define_states(
+            ss.FloatArr('x', default=ss.random(), label='X position'),
+            ss.FloatArr('y', default=ss.random(), label='Y position'),
+            ss.FloatArr('theta', default=ss.uniform(high=2*np.pi), label='Heading'),
+        )
+        return
+
+    def init_post(self):
+        self.add_pairs()
+        return
+
+    def step(self):
+        # Motion step
+        vdt = self.pars.v * self.t.dt
+        self.x[:] = self.x + vdt * np.cos(self.theta)
+        self.y[:] = self.y + vdt * np.sin(self.theta)
+
+        # Wall bounce
+
+        ## Right edge
+        inds = (self.x > 1).uids
+        self.x[inds] = 2 - self.x[inds]
+        self.theta[inds] = np.pi - self.theta[inds]
+
+        ## Left edge
+        inds = (self.x < 0).uids
+        self.x[inds] =  -self.x[inds]
+        self.theta[inds] = np.pi - self.theta[inds]
+
+        ## Top edge
+        inds = (self.y > 1).uids
+        self.y[inds] = 2 - self.y[inds]
+        self.theta[inds] = - self.theta[inds]
+
+        ## Bottom edge
+        inds = (self.y < 0).uids
+        self.y[inds] = -self.y[inds]
+        self.theta[inds] = - self.theta[inds]
+
+        self.add_pairs()
+        return
+
+    def add_pairs(self):
+        """ Generate contacts """
+        p1, p2 = np.triu_indices(n=len(self.x), k=1)
+        d12_sq = (self.x.raw[p2]-self.x.raw[p1])**2 + (self.y.raw[p2]-self.y.raw[p1])**2
+        edge = d12_sq < self.pars.r**2
+
+        self.edges['p1'] = ss.uids(p1[edge])
+        self.edges['p2'] = ss.uids(p2[edge])
+        self.edges['beta'] = np.ones(len(self.p1), dtype=ss_float_)
+
+        return
+
+
 class NullNet(Network):
     """
     A convenience class for a network of size n that only has self-connections with a weight of 0.
@@ -532,7 +706,7 @@ class NullNet(Network):
 
     Guarantees there's one (1) contact per agent (themselves), and that their connection weight is zero.
 
-    For an empty network (ie, no contacts) use
+    For an empty network (ie, no edges) use
     >> import starsim as ss
     >> import networkx as nx
     >> empty_net_static = ss.StaticNet(nx.empty_graph)
@@ -554,14 +728,18 @@ class NullNet(Network):
             if self.n > popsize:
                 errormsg = f'Please ensure the size of the network ({self.n} is less than or equal to the population size ({popsize}).'
                 raise ValueError(errormsg)
-        self.get_contacts()
+        self.get_edges()
         return
 
-    def get_contacts(self):
+    def get_edges(self):
         indices = np.arange(self.n)
         self.append(dict(p1=indices, p2=indices, beta=np.zeros_like(indices)))
         return
 
+    def step(self):
+        """ Not used for NullNet """
+        pass
+
 
 class MFNet(SexualNetwork):
     """
@@ -570,11 +748,11 @@ class MFNet(SexualNetwork):
     """
     def __init__(self, pars=None, key_dict=None, **kwargs):
         super().__init__(key_dict=key_dict)
-        self.default_pars(
+        self.define_pars(
             duration = ss.lognorm_ex(mean=15),  # Can vary by age, year, and individual pair. Set scale=exp(mu) and s=sigma where mu,sigma are of the underlying normal distribution.
             participation = ss.bernoulli(p=0.9),  # Probability of participating in this network - can vary by individual properties (age, sex, ...) using callable parameter values
             debut = ss.normal(loc=16),  # Age of debut can vary by using callable parameter values
-            acts = ss.poisson(lam=80),
+            acts = ss.poisson(lam=80), # TODO: make this work with ss.rate, which it currently does not due to network initialization limitations
             rel_part_rates = 1.0,
         )
         self.update_pars(pars=pars, **kwargs)
@@ -647,9 +825,9 @@ class MFNet(SexualNetwork):
 
         return len(p1)
 
-    def update(self):
+    def step(self):
         self.end_pairs()
-        self.set_network_states(upper_age=self.sim.dt) # TODO: looks wrong
+        self.set_network_states(upper_age=self.t.dt) # TODO: check
         self.add_pairs()
         return
 
@@ -661,32 +839,29 @@ class MSMNet(SexualNetwork):
 
     def __init__(self, pars=None, key_dict=None, **kwargs):
         super().__init__(key_dict=key_dict)
-        self.default_pars(
-            duration = ss.lognorm_ex(mean=15, stdev=15),
+        self.define_pars(
+            duration = ss.lognorm_ex(mean=2, std=1),
             debut = ss.normal(loc=16, scale=2),
-            acts = ss.lognorm_ex(mean=80, stdev=20),
+            acts = ss.lognorm_ex(mean=80, std=20),
             participation = ss.bernoulli(p=0.1),
         )
         self.update_pars(pars, **kwargs)
         return
 
-    def init_pre(self, sim):
-        # Add more here in line with MF network, e.g. age of debut
-        # Or if too much replication then perhaps both these networks
-        # should be subclasss of a specific network type (ask LY/DK)
-        super().init_pre(sim)
-        self.set_network_states(sim.people)
-        self.add_pairs(sim.people, ti=0)
+    def init_post(self):
+        self.set_network_states()
+        self.add_pairs()
         return
 
-    def set_network_states(self, people, upper_age=None):
+    def set_network_states(self, upper_age=None):
         """ Set network states including age of entry into network and participation rates """
+        people = self.sim.people
         if upper_age is None: uids = people.uid[people.male]
         else: uids = people.uid[people.male & (people.age < upper_age)]
 
         # Participation
         self.participant[people.female] = False
-        self.participant[uids] = self.participation.rvs(uids) # Should be CRN safe?
+        self.participant[uids] = self.pars.participation.rvs(uids) # Should be CRN safe?
 
         # Debut
         self.debut[uids] = self.pars.debut.rvs(len(uids)) # Just pass len(uids) as this network is not crn safe anyway
@@ -694,7 +869,7 @@ class MSMNet(SexualNetwork):
 
     def add_pairs(self):
         """ Pair all unpartnered MSM """
-        available_m = self.available(self.sim.people, 'm')
+        available_m = self.available(self.sim.people, 'male')
         n_pairs = int(len(available_m)/2)
         p1 = available_m[:n_pairs]
         p2 = available_m[n_pairs:n_pairs*2]
@@ -709,13 +884,13 @@ class MSMNet(SexualNetwork):
             act_vals = self.pars.acts.rvs(len(p1))
 
         self.append(p1=p1, p2=p2, beta=np.ones_like(p1), dur=dur, acts=act_vals)
-        
+
         return len(p1)
 
-    def update(self):
-        self.end_pairs(self.sim)
-        self.set_network_states(self.sim.people, upper_age=self.sim.dt)
-        self.add_pairs(self.sim)
+    def step(self):
+        self.end_pairs()
+        self.set_network_states()
+        self.add_pairs()
         return
 
 
@@ -732,7 +907,7 @@ class EmbeddingNet(MFNet):
             male_shift is the average age that males are older than females in partnerships
         """
         super().__init__()
-        self.default_pars(
+        self.define_pars(
             inherit = True, # The MFNet already comes with pars, we want to keep those
             embedding_func = ss.normal(name='EmbeddingNet', loc=self.embedding_loc, scale=2),
             male_shift = 5,
@@ -789,20 +964,24 @@ class MaternalNet(DynamicNetwork):
         super().__init__(key_dict=key_dict, prenatal=prenatal, postnatal=postnatal, **kwargs)
         return
 
-    def update(self):
+    def step(self):
         """
         Set beta to 0 for women who complete duration of transmission
         Keep connections for now, might want to consider removing
+
+        NB: add_pairs() and end_pairs() are NOT called here; this is done separately
+        in ss.Pregnancy.update_states().
         """
-        inactive = self.edges.end <= self.sim.ti
+        inactive = self.edges.end <= self.ti
         self.edges.beta[inactive] = 0
         return
 
     def end_pairs(self):
         people = self.sim.people
-        active = (self.edges.end > self.sim.ti) & people.alive[self.edges.p1] & people.alive[self.edges.p2]
+        edges = self.edges
+        active = (edges.end > self.ti) & people.alive[edges.p1] & people.alive[edges.p2]
         for k in self.meta_keys():
-            self.edges[k] = self.edges[k][active]
+            edges[k] = edges[k][active]
         return len(active)
 
     def add_pairs(self, mother_inds=None, unborn_inds=None, dur=None, start=None):
@@ -811,10 +990,10 @@ class MaternalNet(DynamicNetwork):
             return 0
         else:
             if start is None:
-                start = np.full_like(dur, fill_value=self.sim.ti)
+                start = np.ones_like(dur)*self.ti
             n = len(mother_inds)
             beta = np.ones(n)
-            end = start + sc.promotetoarray(dur) / self.sim.dt
+            end = start + sc.promotetoarray(dur)
             self.append(p1=mother_inds, p2=unborn_inds, beta=beta, dur=dur, start=start, end=end)
             return n
 
@@ -830,3 +1009,265 @@ class PostnatalNet(MaternalNet):
     def __init__(self, key_dict=None, prenatal=False, postnatal=True, **kwargs):
         super().__init__(key_dict=key_dict, prenatal=prenatal, postnatal=postnatal, **kwargs)
         return
+
+
+__all__ += ['AgeGroup', 'MixingPools', 'MixingPool']
+
+class AgeGroup(sc.prettyobj):
+    """ A simple age-based filter that returns uids of agents that match the criteria """
+    def __init__(self, low, high, do_cache=True):
+        self.low = low
+        self.high = high
+
+        self.do_cache = do_cache
+        self.uids = None # Cached
+        self.ti_cache = -1
+
+        self.name = repr(self)
+        return
+
+    def __call__(self, sim):
+        if (not self.do_cache) or (self.ti_cache != sim.ti):
+            in_group = sim.people.age >= self.low
+            if self.high is not None:
+                in_group = in_group & (sim.people.age < self.high)
+            self.uids = ss.uids(in_group)
+            self.ti_cache = sim.ti
+        return self.uids
+
+    def __repr__(self):
+        return f'age({self.low}-{self.high})'
+
+
+class MixingPools(Route):
+    """
+    A container for creating a rectangular array of MixingPool instances
+
+    By default, separates the population into <15 and >15 age groups.
+
+    Args:
+        diseases (str): the diseases that transmit via these mixing pools
+        src (inds): source agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents
+        dst (inds): destination agents; as above
+        beta (float): overall transmission via these mixing pools
+        contacts (array): the relative connectivity between different mixing pools (can be float or Dist)
+
+    **Example**::
+
+        import starsim as ss
+        mps = ss.MixingPools(
+            diseases = 'sis',
+            beta = 0.1,
+            src = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},
+            dst = {'0-15': ss.AgeGroup(0, 15), '15+': ss.AgeGroup(15, None)},
+            contacts = [[2.4, 0.49], [0.91, 0.16]],
+        )
+        sim = ss.Sim(diseases='sis', networks=mps).run()
+        sim.plot()
+    """
+    def __init__(self, pars=None, **kwargs):
+        super().__init__()
+        self.define_pars(
+            diseases = None,
+            src = None,
+            dst = None,
+            beta = ss.beta(0.1),
+            contacts = None,
+        )
+        self.update_pars(pars, **kwargs)
+        self.validate_pars()
+        self.pools = []
+        return
+
+    def __len__(self):
+        try:    return len(self.pools)
+        except: return 0
+
+    def validate_pars(self):
+        """ Check that src and dst have correct types, and contacts is the correct shape """
+        p = self.pars
+
+        # Validate src and dst
+        if not isinstance(p.src, dict):
+            errormsg = f'src must be a provided as a dictionary, not {type(self.pars.src)}'
+            raise TypeError(errormsg)
+        if not isinstance(p.dst, dict):
+            raise TypeError(f'dst must be a provided as a dictionary, not {type(self.pars.src)}')
+        p.src = sc.objdict(p.src)
+        p.dst = sc.objdict(p.dst)
+
+        # Validate the contacts
+        if p.contacts is None:
+            p.contacts = np.ones((len(p.src), len(p.dst)))
+        p.contacts = np.array(p.contacts)
+        actual = p.contacts.shape
+        expected = (len(p.src), len(p.dst))
+        if actual != expected:
+            errormsg = f'The number of source and destination groups must match the number of rows and columns in the mixing matrix, but {actual} != {expected}.'
+            raise ValueError(errormsg)
+
+        return
+
+    def init_pre(self, sim):
+        super().init_pre(sim)
+        p = self.pars
+
+        self.pools = []
+        for i,sk,src in p.src.enumitems():
+            for j,dk,dst in p.dst.enumitems():
+                contacts = p.contacts[i,j]
+                if sc.isnumber(contacts): # If it's a number, convert to a distribution
+                    contacts = ss.poisson(lam=contacts)
+                name = f'pool:{sk}->{dk}'
+                mp = MixingPool(name=name, diseases=p.diseases, beta=p.beta, contacts=contacts, src=src, dst=dst)
+                mp.init_pre(sim) # Initialize the pool
+                self.pools.append(mp)
+        return
+
+    def init_post(self):
+        """ Initialize each mixing pool """
+        for mp in self.pools:
+            mp.init_post()
+        return
+
+    def step(self):
+        """ Step each mixing pool """
+        for mp in self.pools:
+            mp.step()
+        return
+
+    def remove_uids(self, uids):
+        """ Remove UIDs from each mixing pool """
+        for mp in self.pools:
+            mp.remove_uids(uids)
+        return
+
+
+class MixingPool(Route):
+    """
+    Define a single mixing pool; can be used as a drop-in replacement for a network.
+
+    Args:
+        diseases (str): the diseases that transmit via this mixing pool
+        src (inds): source agents; can be AgeGroup(), ss.uids(), or lambda(sim); None indicates all alive agents
+        dst (inds): destination agents; as above
+        beta (float): overall transmission
+        contacts (Dist): the number of effective contacts of the destination agents
+
+    **Example**::
+
+        import starsim as ss
+
+        # Set the parameters
+        mp_pars = dict(
+            src = lambda sim: sim.people.male, # only males are infectious
+            dst = None, # all agents are susceptible
+            beta = ss.beta(0.2),
+            contacts = ss.poisson(lam=4),
+        )
+
+        # Seed 5% of the male population
+        def p_init(self, sim, uids):
+            return 0.05*sim.people.male
+
+        # Create and run the sim
+        sis = ss.SIS(init_prev=p_init)
+        mp = ss.MixingPool(mp_pars)
+        sim = ss.Sim(diseases=sis, networks=mp)
+        sim.run()
+        sim.plot()
+    """
+    def __init__(self, pars=None, **kwargs):
+        super().__init__()
+        self.define_pars(
+            diseases = None,
+            src = None,
+            dst = None, # Same as src
+            beta = ss.beta(0.2),
+            contacts = ss.poisson(1.0),
+        )
+        self.update_pars(pars, **kwargs)
+
+        self.define_states(
+            ss.FloatArr('eff_contacts', default=self.pars.contacts, label='Effective number of contacts')
+        )
+
+        self.pars.diseases = sc.promotetolist(self.pars.diseases)
+        self.diseases = None
+        self.src_uids = None
+        self.dst_uids = None
+
+        self.p_acquire = ss.bernoulli(p=0) # Placeholder value
+
+        return
+
+    def __len__(self):
+        try:
+            return len(self.pars.dst)
+        except:
+            return 0
+
+    def init_post(self):
+        super().init_post()
+
+        if len(self.pars.diseases) == 0:
+            self.diseases = [d for d in self.sim.diseases.values() if isinstance(d, ss.Infection)] # Assume the user wants all communicable diseases
+        else:
+            self.diseases = []
+            for d in self.pars.diseases:
+                if not isinstance(d, str):
+                    raise TypeError(f'Diseases can be specified as ss.Disease objects or strings, not {type(d)}')
+                if d not in self.sim.diseases:
+                    raise KeyError(f'Could not find disease with name {d} in the list of diseases.')
+
+                dis = self.sim.diseases[d]
+                if not isinstance(dis, ss.Infection):
+                    raise TypeError(f'Cannot create a mixing pool for disease {d}. Mixing pools only work for communicable diseases.')
+                self.diseases.append(dis)
+
+            if len(self.diseases) == 0:
+                raise ValueError('You must specify at least one transmissible disease to use mixing pools')
+        return
+
+    def get_uids(self, func_or_array):
+        if func_or_array is None:
+            return self.sim.people.auids
+        elif callable(func_or_array):
+            return func_or_array(self.sim)
+        elif isinstance(func_or_array, ss.uids):
+            return func_or_array
+        raise Exception('src must be either a callable function, e.g. lambda sim: ss.uids(sim.people.age<5), or an array of uids.')
+
+    def remove_uids(self, uids):
+        """ If UIDs are supplied explicitly, remove them if people die """
+        for key in ['src', 'dst']:
+            inds = self.pars[key]
+            if isinstance(inds, ss.uids):
+                self.pars[key] = inds.remove(uids)
+        return
+
+    def step(self):
+        self.src_uids = self.get_uids(self.pars.src)
+        self.dst_uids = self.get_uids(self.pars.dst)
+        beta = self.pars.beta
+        if isinstance(beta, ss.beta):
+            beta = beta.values # Don't use as a time probability
+
+        if beta == 0:
+            return 0
+
+        if len(self.src_uids) == 0 or len(self.dst_uids) == 0:
+            return 0
+
+        n_new_cases = 0
+        for disease in self.diseases:
+            trans = np.mean(disease.infectious[self.src_uids] * disease.rel_trans[self.src_uids])
+            acq = self.eff_contacts[self.dst_uids] * disease.susceptible[self.dst_uids] * disease.rel_sus[self.dst_uids]
+            p = beta*trans*acq
+
+            self.p_acquire.set(p=p)
+            new_cases = self.p_acquire.filter(self.dst_uids)
+            n_new_cases += len(new_cases)
+            disease.set_prognoses(new_cases)
+
+        return n_new_cases
diff --git a/starsim/parameters.py b/starsim/parameters.py
index 5b7034d..cdf9ad8 100644
--- a/starsim/parameters.py
+++ b/starsim/parameters.py
@@ -1,7 +1,6 @@
 """
 Set parameters
 """
-
 from numbers import Number
 import numpy as np
 import pandas as pd
@@ -17,7 +16,7 @@ atomic_classes = (str, Number, list, np.ndarray, pd.Series, pd.DataFrame, type(N
 class Pars(sc.objdict):
     """
     Dict-like container of parameters
-    
+
     Acts like an ``sc.objdict()``, except that adding new keys are disallowed by
     default, and auto-updates known types.
     """
@@ -30,11 +29,11 @@ class Pars(sc.objdict):
                 raise ValueError(errormsg)
         super().__init__(**kwargs)
         return
-    
+
     def update(self, pars=None, create=False, **kwargs):
         """
         Update internal dict with new pars.
-        
+
         Args:
             pars (dict): the parameters to update (if None, do nothing)
             create (bool): if create is False, then raise a KeyNotFoundError if the key does not already exist
@@ -47,7 +46,7 @@ class Pars(sc.objdict):
             return self
         if not create: # Check if there are any mismatches, which raises an exception if there are
             self.check_key_mismatch(pars)
-        
+
         # Perform the update
         for key,new in pars.items():
             if key not in self.keys(): # It's a new parameter and create=True: update directly
@@ -56,20 +55,27 @@ class Pars(sc.objdict):
                 old = self[key] # Get the existing object we're about to update
                 if isinstance(old, atomic_classes): # It's a number, string, etc: update directly
                     self[key] = new
+
                 elif isinstance(old, Pars): # It's a Pars object: update recursively
                     old.update(new, create=create)
                 elif isinstance(old, ss.ndict): # Update module containers
                     self._update_ndict(key, old, new)
                 elif isinstance(old, ss.Module):  # Update modules
                     self._update_module(key, old, new)
+                elif isinstance(old, ss.TimePar):
+                    self._update_timepar(key, old, new)
                 elif isinstance(old, ss.Dist): # Update a distribution
                     self._update_dist(key, old, new)
+                elif callable(old): # It's a function: update directly
+                    self[key] = new
+                elif isinstance(old, dict):
+                    self[key] = new # Take dictionaries directly, without warning the user
                 else: # Everything else; not used currently but could be
-                    warnmsg = 'No known mechanism for handling {type(old)} → {type(new)}; using default'
+                    warnmsg = f'No known mechanism for handling {type(old)} → {type(new)}; using default'
                     ss.warn(warnmsg)
                     self[key] = new
         return self
-    
+
     def _update_ndict(self, key, old, new):
         """ Update an ndict object in the parameters, e.g. sim.pars.diseases """
         if not len(old): # It's empty, just overwrite
@@ -82,7 +88,7 @@ class Pars(sc.objdict):
                 errormsg = f'Cannot update an ndict with {type(new)}: must be a dict to set new parameters'
                 raise TypeError(errormsg)
         return
-    
+
     def _update_module(self, key, old, new):
         """ Update a Module object in the parameters, e.g. sim.pars.diseases.sir """
         if isinstance(new, dict):
@@ -91,25 +97,69 @@ class Pars(sc.objdict):
             errormsg = f'Cannot update a module with {type(new)}: must be a dict to set new parameters'
             raise TypeError(errormsg)
         return
-    
+
+    def _update_timepar(self, key, old, new):
+        """ Update a time parameter (duration or rate) """
+
+        # It's a TimePar, e.g. dur_inf = ss.dur(6); use directly
+        if isinstance(new, ss.TimePar):
+            self[key] = new
+
+        # It's a dataframe, allow the update -- used for demographics
+        elif isinstance(new, (pd.Series, pd.DataFrame)):
+            self[key] = new # TODO: add validation or convert to timepar
+
+        # It's a single number, e.g. dur_inf = 6; set parameters
+        elif isinstance(new, Number):
+            old.set(new)
+
+        # It's a list of numbers, e.g. dur_inf = [6, 2]; set parameters
+        elif isinstance(new, list):
+            old.set(*new)
+
+        # It's a dict, figure out what to do
+        elif isinstance(new, dict):
+            if isinstance(old, ss.beta):
+                self[key] = new # TODO: use an actual set here
+            else:
+                old.set(**new)
+
+        # Give up
+        else:
+            errormsg = f'Updating timepar from {type(old)} to {type(new)} is not supported'
+            raise TypeError(errormsg)
+
+        return
+
     def _update_dist(self, key, old, new):
         """ Update a Dist object in the parameters, e.g. sim.pars.diseases.sir.dur_inf """
+
         # It's a Dist, e.g. dur_inf = ss.normal(6,2); use directly
-        if isinstance(new, ss.Dist): 
+        if isinstance(new, ss.Dist):
             if isinstance(old, ss.bernoulli) and not isinstance(new, ss.bernoulli):
                 errormsg = f"Bernoulli distributions can't be changed to another type: {type(new)} is invalid"
                 raise TypeError(errormsg)
             else:
                 self[key] = new
-        
+
         # It's a single number, e.g. dur_inf = 6; set parameters
         elif isinstance(new, Number):
             old.set(new)
-        
-        # It's a list number, e.g. dur_inf = [6, 2]; set parameters
+
+        # It's a list of numbers, e.g. dur_inf = [6, 2]; set parameters
         elif isinstance(new, list):
             old.set(*new)
-        
+
+        # It's a timepar, set it like a number, e.g. dur_inf = ss.dur(6)
+        elif isinstance(new, ss.TimePar):
+            oldpar = old.pars[0]
+            if isinstance(oldpar, ss.TimePar): # If changing from one timepar to another, validate
+                dur_mismatch = isinstance(oldpar, ss.dur) != isinstance(new, ss.dur)
+                if dur_mismatch:
+                    errormsg = f'Cannot change a duration to a non-duration vice versa: old={type(oldpar)}, new={type(new)}'
+                    raise TypeError(errormsg)
+            old.set(new)
+
         # It's a dict, figure out what to do
         elif isinstance(new, dict):
             newtype = new.get('type')
@@ -122,6 +172,12 @@ class Pars(sc.objdict):
                 else:
                     dist = ss.make_dist(new)
                     self[key] = dist
+
+        # Give up
+        else:
+            errormsg = f'Updating dist from {type(old)} to {type(new)} is not supported'
+            raise TypeError(errormsg)
+
         return
 
     def check_key_mismatch(self, pars):
@@ -133,15 +189,15 @@ class Pars(sc.objdict):
             errormsg = f'Key(s) {mismatches} not found; available keys are {available_keys}'
             raise sc.KeyNotFoundError(errormsg)
         return
-    
+
     def dict_update(self, *args, **kwargs):
         """ Redefine default dict.update(), since overwritten in this class; should not usually be used """
         super().update(*args, **kwargs)
         return
-    
+
     def to_json(self, **kwargs):
         """ Convert to JSON representation """
-        return sc.jsonify(self, **kwargs)
+        return sc.jsonify(dict(self), **kwargs)
 
 
 class SimPars(Pars):
@@ -152,35 +208,53 @@ class SimPars(Pars):
     directly.
 
     Args:
-        kwargs (dict): any additional kwargs are interpreted as parameter names
+        label (str): The name of the simulation
+        n_agents (int/float): The number of agents to run (default 10,000)
+        total_pop (int/float): If provided, scale the agents to this effective population size
+        pop_scale (float): If provided, use this agent-to-population scale factor (total_pop = n_agents*pop_scale)
+        unit (str): The time unit for the simulation (default 'year'; other choices are 'day', 'week', 'month')
+        start (float/str/date): The starting date for the simulation (default 2000); can be a year or date
+        stop (float/str/date): If provided, the ending date for the simulation (if not provided, calculate from "dur")
+        dur (int): How many timesteps to simulate, if "stop" is not provided (default 50)
+        dt (float): The timestep, in units of "unit" (default 1.0)
+        rand_seed (int): The overall random seed for the simulation (used to set module-specific random seeds)
+        birth_rate (float): If provided, include births with this rate (per 1000 people per year)
+        death_rate (float): If provided, include deaths with this rate (per 1000 people per year)
+        use_aging (bool): Specify whether agents age (by default, agents age if and only if births and/or deaths are included)
+        people (People): If provided, use a pre-existing People object rather than creating one (in which case n_agents will be ignored)
+        networks (str/list/Module): The network module(s); can be a string, single module (i.e. Network), or list
+        demographics (str/list/Module): As above
+        diseases (str/list/Module): As above
+        connectors (str/list/Module): As above
+        interventions (str/list/Module): As above
+        analyzers (str/list/Module): As above
+        verbose (float): How much detail to print (1 = every timestep, 0.1 = every 10 timesteps, etc.)
     """
     def __init__(self, **kwargs):
-        
+
         # General parameters
         self.label   = '' # The label of the simulation
         self.verbose = ss.options.verbose # Whether or not to display information during the run -- options are 0 (silent), 0.1 (some; default), 1 (default), 2 (everything)
 
         # Population parameters
-        self.n_agents  = 10e3  # Number of agents
-        self.total_pop = None  # If defined, used for calculating the scale factor
-        self.pop_scale = None  # How much to scale the population
+        self.n_agents  = 10e3 # Number of agents
+        self.total_pop = None # If defined, used for calculating the scale factor
+        self.pop_scale = None # How much to scale the population
 
         # Simulation parameters
-        self.unit       = 'year' # The time unit to use (NOT YET IMPLEMENTED)
-        self.start      = 2000   # Start of the simulation
-        self.end        = None   # End of the simulation
-        self.n_years    = 50     # Number of years to run, if end isn't specified. Note that this includes burn-in
-        self.dt         = 1.0    # Timestep
-        self.rand_seed  = 1      # Random seed, if None, don't reset
-        self.slot_scale = 5      # Random slots will be assigned to newborn agents between min=n_agents and max=slot_scale*n_agents
+        self.unit      = ''    # The time unit to use; options are 'year' (default), 'day', 'week', 'month', or 'none'
+        self.start     = None  # Start of the simulation (default 2020)
+        self.stop      = None  # End of the simulation
+        self.dur       = None  # Duration of time to run, if stop isn't specified (default 50 steps of self.unit)
+        self.dt        = 1.0   # Timestep (in units of self.unit)
+        self.rand_seed = 1     # Random seed; if None, don't reset
 
         # Demographic parameters
-        self.location   = None  #  NOT CURRENTLY FUNCTIONAL - what demographics to use
         self.birth_rate = None
         self.death_rate = None
         self.use_aging  = None # True if demographics, false otherwise
 
-        # Modules: demographics, diseases, connectors, networks, analyzers, and interventions
+        # Modules: demographics, diseases, networks, analyzers, and interventions
         self.people = None
         self.networks      = ss.ndict()
         self.demographics  = ss.ndict()
@@ -192,7 +266,7 @@ class SimPars(Pars):
         # Update with any supplied parameter values and generate things that need to be generated
         self.update(kwargs)
         return
-    
+
     def is_default(self, key):
         """ Check if the provided value matches the default """
         default_pars = SimPars() # Create a default SimPars object
@@ -206,16 +280,15 @@ class SimPars(Pars):
         self.validate_sim_pars()
         self.validate_modules()
         return
-    
+
     def validate_sim_pars(self):
         """ Validate each of the parameter values """
         self.validate_verbose()
         self.validate_agents()
         self.validate_total_pop()
-        self.validate_start_end()
-        self.validate_dt()
+        self.validate_time()
         return
-    
+
     def validate_verbose(self):
         """ Validate verbosity """
         if self.verbose == 'brief':
@@ -224,7 +297,7 @@ class SimPars(Pars):
             errormsg = f'Verbose argument should be either "brief", -1, or a float, not {type(self.par.verbose)} "{self.par.verbose}"'
             raise ValueError(errormsg)
         return
-    
+
     def validate_agents(self):
         """ Check that n_agents is supplied and convert to an integer """
         if self.people is not None:
@@ -239,10 +312,10 @@ class SimPars(Pars):
             errormsg = 'Must supply n_agents, a people object, or a popdict'
             raise ValueError(errormsg)
         return
-    
+
     def validate_total_pop(self):
         """ Ensure one but not both of total_pop and pop_scale are defined """
-        if self.total_pop is not None:  # If no pop_scale has been provided, try to get it from the location
+        if self.total_pop is not None:  # In future, if no pop_scale has been provided, try to get it from the location
             if self.pop_scale is not None:
                 errormsg = f'You can define total_pop ({self.total_pop}) or pop_scale ({self.pop_scale}), but not both, since one is calculated from the other'
                 raise ValueError(errormsg)
@@ -256,48 +329,38 @@ class SimPars(Pars):
         if self.pop_scale is None:
             self.pop_scale = total_pop / self.n_agents
         return
-    
-    def validate_start_end(self):
-        """ Ensure at least one of n_years and end is defined, but not both """
-        if self.end is not None:
-            if self.is_default('n_years'):
-                self.n_years = self.end - self.start
+
+    def validate_time(self):
+        """ Ensure at least one of dur and stop is defined, but not both """
+
+        # Handle the unit
+        if self.unit == '':
+            self.unit = ss.time.default_unit
+        self.unit = ss.time.validate_unit(self.unit)
+
+        # Handle start
+        if self.start is None:
+            self.start = ss.time.default_start[self.unit]
+
+        # Handle stop and dur
+        if self.stop is not None:
+            if self.dur is None:
+                self.dur = ss.date_diff(self.start, self.stop, self.unit)
             else:
-                errormsg = f'You can supply either end ({self.end}) or n_years ({self.n_years}) but not both, since one is calculated from the other'
+                errormsg = f'You can supply either stop ({self.stop}) or dur ({self.dur}) but not both, since one is calculated from the other'
                 raise ValueError(errormsg)
-            if self.n_years <= 0:
-                errormsg = f"Number of years must be >0, but you supplied start={str(self.start)} and " \
-                           f"end={str(self.end)}, which gives n_years={self.n_years}"
+            if self.dur <= 0:
+                errormsg = f"Duration must be >0, but you supplied start={str(self.start)} and stop={str(self.stop)}, which gives dur={self.dur}"
                 raise ValueError(errormsg)
         else:
-            if self.n_years is not None:
-                self.end = self.start + self.n_years
-            else:
-                errormsg = 'You must supply one of n_years and end."'
-                raise ValueError(errormsg)
+            if self.dur is None:
+                self.dur = ss.time.default_dur
+            self.stop = ss.date_add(self.start, self.dur, self.unit)
         return
 
-    def validate_dt(self):
-        """
-        Check that 1/dt is an integer value, otherwise results and time vectors will have mismatching shapes.
-        init_results explicitly makes this assumption by casting resfrequency = int(1/dt).
-        """
-        if self.unit == 'year': # TODO: implement properly
-            dt = self.dt
-            reciprocal = 1.0 / dt  # Compute the reciprocal of dt
-            if not reciprocal.is_integer():  # Check if reciprocal is not a whole (integer) number
-                # Round the reciprocal
-                reciprocal = int(reciprocal)
-                rounded_dt = 1.0 / reciprocal
-                self.dt = rounded_dt
-                if self.verbose:
-                    warnmsg = f'Warning: Provided time step dt={dt} resulted in a non-integer number of steps per year. Rounded to {rounded_dt}.'
-                    ss.warn(warnmsg)
-        return
-    
     def validate_modules(self):
         """ Validate modules passed in pars"""
-        
+
         # Do special validation on demographics (must be before modules are created)
         self.validate_demographics()
 
@@ -317,21 +380,32 @@ class SimPars(Pars):
         # Do special validation on networks (must be after modules are created)
         self.validate_networks()
         return
-    
+
     def validate_demographics(self):
         """ Validate demographics-related input parameters"""
-        # Allow shortcut for default demographics # TODO: think about whether we want to enable this, when we have birth_rate and death_rate
+        # Allow shortcut for default demographics
         if self.demographics == True:
-            self.demographics = [ss.Births(), ss.Deaths()]
+            self.demographics = sc.autolist()
+            if self.birth_rate is None:
+                self.demographics += ss.Births()
+            if self.death_rate is None:
+                self.demographics += ss.Deaths()
 
         # Allow users to add vital dynamics by entering birth_rate and death_rate parameters directly to the sim
+        valid = isinstance(self.demographics, ss.ndict) and not len(self.demographics)
         if self.birth_rate is not None:
+            if not valid:
+                errormsg = 'You can only specify birth_rate together with (optionally) death_rate, not other demographics modules; add ss.Births() manually'
+                raise ValueError(errormsg)
             births = ss.Births(birth_rate=self.birth_rate)
             self.demographics += births
         if self.death_rate is not None:
+            if not valid:
+                errormsg = 'You can only specify death_rate together with (optionally) birth_rate, not other demographics modules; add ss.Deaths() manually'
+                raise ValueError(errormsg)
             background_deaths = ss.Deaths(death_rate=self.death_rate)
             self.demographics += background_deaths
-        
+
         # Decide whether to use aging based on if demographics modules are present
         if self.use_aging is None:
             self.use_aging = True if self.demographics else False
@@ -340,8 +414,12 @@ class SimPars(Pars):
     def validate_networks(self):
         """ Validate networks """
         # Don't allow more than one prenatal or postnatal network
-        prenatal_nets  = {k:nw for k,nw in self.networks.items() if nw.prenatal}
-        postnatal_nets = {k:nw for k,nw in self.networks.items() if nw.postnatal}
+        prenatal_nets = []
+        postnatal_nets = []
+        for k,nw in self.networks.items():
+            if isinstance(nw, ss.Network):
+                if nw.prenatal: prenatal_nets.append(k)
+                if nw.postnatal: postnatal_nets.append(k)
         if len(prenatal_nets) > 1:
             errormsg = f'Starsim currently only supports one prenatal network; prenatal networks are: {prenatal_nets.keys()}'
             raise ValueError(errormsg)
@@ -368,7 +446,7 @@ class SimPars(Pars):
         """
         modmap = ss.module_map() # List of modules and parent module classes, e.g. ss.Disease
         modules = ss.find_modules() # Each individual module class option, e.g. ss.SIR
-        
+
         for modkey,ssmoddict in modules.items():
             moddictkeys = ssmoddict.keys()
             moddictvals = ssmoddict.values()
@@ -376,25 +454,25 @@ class SimPars(Pars):
             modlist = self[modkey]
             if isinstance(modlist, list): # Skip over ones that are already ndict format, assume they're already initialized
                 for i,mod in enumerate(modlist):
-                    
+
                     # Convert first from a string to a dict
                     if isinstance(mod, str):
                         mod = dict(type=mod)
-                        
+
                     # Convert from class to class instance (used for interventions and analyzers only)
                     if isinstance(mod, type) and modkey in ['interventions', 'analyzers']:
                         mod = mod() # Call it to create a class instance
-                    
+
                     # Now convert from a dict to a module
                     if isinstance(mod, dict):
-                        
+
                         # Get the module type as a string
                         if 'type' in mod:
                             modtype = mod.pop('type')
                         else:
                             errormsg = f'When specifying a {modkey} module with a dict, one of the keys must be "type"; you supplied {mod}'
                             raise ValueError(errormsg)
-                        
+
                         # Get the module type as a class
                         if isinstance(modtype, str): # Usual case, a string, e.g. dict(type='sir', dur_inf=6)
                             modtype = modtype.lower() # Because our map is in lowercase
@@ -409,24 +487,25 @@ class SimPars(Pars):
                             else:
                                 errormsg = f'Invalid module class "{modtype}" for "{modkey}"; must be one of {moddictvals}'
                                 raise TypeError(errormsg)
-                        
+
                         # Create the module and store it in the list
                         mod = modcls(**mod)
-                    
+
                     # Special handling for interventions and analyzers: convert class and function to class instance
                     if modkey in ['interventions', 'analyzers']:
                         if isinstance(mod, type) and issubclass(mod, expected_cls):
                             mod = mod()  # Convert from a class to an instance of a class
                         elif not isinstance(mod, ss.Module) and callable(mod):
                             mod = expected_cls.from_func(mod)
-                    
+
                     # Do final check
-                    if not isinstance(mod, expected_cls):
-                        errormsg = f'Was expecting {modkey} entry {i} to be class {expected_cls}, but was {type(mod)} instead'
+                    if not isinstance(mod, (expected_cls, ss.Module)): # TEMP: check if this check still works?
+                        errormsg = f'Was expecting {modkey} entry {i} to be class {expected_cls} or Plugin, but was {type(mod)} instead'
                         raise TypeError(errormsg)
                     modlist[i] = mod
         return
 
 
 def make_pars(**kwargs):
+    """ Shortcut for making a new instance of SimPars """
     return SimPars(**kwargs)
diff --git a/starsim/people.py b/starsim/people.py
index e597f12..37e021d 100644
--- a/starsim/people.py
+++ b/starsim/people.py
@@ -1,12 +1,11 @@
 """
 Defines the People class and functions associated with making people
 """
-
-# %% Imports
 import numpy as np
 import pandas as pd
 import sciris as sc
 import starsim as ss
+from pathlib import Path
 
 __all__ = ['People', 'Person']
 
@@ -19,9 +18,8 @@ class People(sc.prettyobj):
     will get passed instead since it will be needed before the People object is
     initialized.
 
-    Note that this class handles the mechanics of updating the actual people, while
-    ``ss.BasePeople`` takes care of housekeeping (saving, loading, exporting, etc.).
-    Please see the BasePeople class for additional methods.
+    Note that this class handles the mechanics of updating the actual people,
+    as well as the additional housekeeping methods (saving, loading, exporting, etc.).
 
     Args:
         pars (dict): the sim parameters, e.g. sim.pars -- alternatively, if a number, interpreted as n_agents
@@ -34,7 +32,7 @@ class People(sc.prettyobj):
 
     def __init__(self, n_agents, age_data=None, extra_states=None):
         """ Initialize """
-        
+
         # We internally store states in a dict keyed by the memory ID of the state, so that we can have colliding names
         # e.g., across modules, but we will never change the size of a State multiple times in the same iteration over
         # _states. This is a hidden variable because it is internally used to synchronize the size of all States contained
@@ -44,23 +42,25 @@ class People(sc.prettyobj):
         self.version = ss.__version__  # Store version info
         self.initialized = False
 
-        # Handle the three fundamental arrays: UIDs for tracking agents, slots for 
+        # Handle the three fundamental arrays: UIDs for tracking agents, slots for
         # tracking random numbers, and AUIDs for tracking alive agents
         n = int(n_agents)
         uids = ss.uids(np.arange(n))
         self.auids = uids.copy() # This tracks all active UIDs (in practice, agents who are alive)
         self.uid = ss.IndexArr('uid')  # This variable tracks all UIDs
         self.slot = ss.IndexArr('slot') # A slot is a special state managed internally
+        self.parent = ss.IndexArr('parent', label='UID of parent')  # UID of parent, if any, IndexArray?
         self.uid.grow(new_vals=uids)
         self.slot.grow(new_vals=uids)
+        self.parent.grow(new_uids=uids, new_vals=np.full(len(uids), self.parent.nan))
         for state in [self.uid, self.slot]:
             state.people = self # Manually link to people since we don't want to link to states
-        
+
         # Handle additional states
         extra_states = sc.promotetolist(extra_states)
         states = [
-            ss.BoolArr('alive', default=True),  # Time index for death
-            ss.BoolArr('female', default=ss.bernoulli(name='female', p=0.5)),
+            ss.State('alive', default=True),  # Time index for death
+            ss.State('female', default=ss.bernoulli(name='female', p=0.5)),
             ss.FloatArr('age', default=self.get_age_dist(age_data)), # NaN until conceived
             ss.FloatArr('ti_dead'),  # Time index for death
             ss.FloatArr('scale', default=1.0), # The scale factor for the agents (multiplied for making results)
@@ -71,31 +71,73 @@ class People(sc.prettyobj):
             self.states.append(state, overwrite=False)
             setattr(self, state.name, state)
             state.link_people(self)
-            
+
         return
 
     @staticmethod
     def get_age_dist(age_data):
-        """ Return an age distribution based on provided data """
+        """
+        Return an age distribution based on provided data
+
+        The data should be provided in the form of either an Nx2 array, a pandas series
+        with age as the index and counts/probability as the value, or a pandas DataFrame
+        with "age" and "value" as columns. Each of these should look like e.g.:
+
+            age      value
+            0      220.548
+            1      206.188
+            2      195.792
+            3      187.442
+
+        The ages will be interpreted as lower bin edges. An upper bin edge will
+        automatically be added based on the final age plus the difference of the
+        last two bins. To explicitly control the width of the upper age bin, add
+        an extra entry to the ``age_data`` with a value of 0 and an age value
+        corresponding to the desired upper age bound.
+
+        Args:
+            age_data: An array/series/dataframe with an index corresponding to age values, and a value corresponding to histogram counts
+                         or relative proportions. A distribution will be estimated based on the histogram. The histogram will be
+                         assumed to correspond to probability densitiy if the sum of the histogram values is equal to 1, otherwise
+                         it will be assumed to correspond to counts.
+
+        Note: age_data can also be provided as a string
+
+        Returns:
+            An ``ss.Dist`` instance that returns an age for newly created agents
+        """
         if age_data is None:
             dist = ss.uniform(low=0, high=100, name='Age distribution')
-            return dist
+        else:
+            # Try loading from file
+            if isinstance(age_data, str) or isinstance(age_data, Path):
+                age_data = pd.read_csv(age_data)
 
-        if sc.checktype(age_data, pd.DataFrame):
-            age_bins = age_data['age'].values
-            age_props = age_data['value'].values
-            age_props = age_props / age_props.sum()
-            return ss.choice(a=age_bins, p=age_props)
+            # Process
+            if isinstance(age_data, np.ndarray): # TODO: accept output of np.histogram()
+                age_bins = age_data[:,0]
+                age_props = age_data[:,1]
+            elif isinstance(age_data, pd.Series):
+                age_bins = age_data.index
+                age_props = age_data.values
+            elif isinstance(age_data, pd.DataFrame):
+                age_bins = age_data['age'].values
+                age_props = age_data['value'].values
+
+            # Convert to a histogram
+            dist = ss.histogram(values=age_props, bins=age_bins, name='Age distribution')
+
+        return dist
 
     def link_sim(self, sim):
         """ Initialization """
         if self.initialized:
-            errormsg = 'Cannot re-initialize a People object directly; use sim.initialize(reset=True)'
+            errormsg = 'Cannot re-initialize a People object directly; use sim.init(reset=True)'
             raise RuntimeError(errormsg)
         self.sim = sim # Store the sim
         ss.link_dists(obj=self.states, sim=sim, module=self, skip=[ss.Sim, ss.Module])
         return
-    
+
     def add_module(self, module, force=False):
         """
         Add a Module to the People instance
@@ -103,7 +145,7 @@ class People(sc.prettyobj):
         This method is used to add a module to the People. It will register any module states with this
         people instance for dynamic resizing, and expose the states contained in the module to the user
         via `People.states.<module_name>.<state_name>`
-        
+
         The entries created below make it possible to do `sim.people.hiv.susceptible` or
         `sim.people.states['hiv.susceptible']` and have both of them work
         """
@@ -120,7 +162,7 @@ class People(sc.prettyobj):
                 self.states[combined_name] = state # Register the state on the user-facing side using the combined name. Within the original module, it can still be referenced by its original name
                 module_states[state.name] = state
         return
-    
+
     def init_vals(self):
         """ Populate states with initial values, the final step of initialization """
         for state in self.states():
@@ -128,19 +170,19 @@ class People(sc.prettyobj):
                 state.init_vals()
         self.initialized = True
         return
-    
+
     def __bool__(self):
         """ Ensure that zero-length people are still truthy """
         return True
-    
+
     def __len__(self):
         """ Length of people """
         return len(self.auids)
-    
+
     @property
     def n_uids(self):
         return self.uid.len_used
-    
+
     def _link_state(self, state, die=True):
         """
         Link a state with the People instance for dynamic resizing; usually called by
@@ -148,7 +190,7 @@ class People(sc.prettyobj):
 
         All states should be registered by this function for the purpose of connecting them to the
         People's UIDs and to have them be automatically resized when the number of agents changes.
-        This operation is normally triggered as part of initializing the state (via `State.initialize()`)
+        This operation is normally triggered as part of initializing the state (via `State.init()`)
         """
         if id(state) not in self._states:
             self._states[id(state)] = state
@@ -184,10 +226,12 @@ class People(sc.prettyobj):
         new_slots = new_slots if new_slots is not None else new_uids
         self.slot.grow(new_uids, new_vals=new_slots)
 
+        self.parent.grow(new_uids, new_vals=self.parent.nan) # Grow parent array
+
         # Grow the states
         for state in self._states.values():
             state.grow(new_uids)
-            
+
         # Finally, update the alive indices
         self.auids = self.auids.concat(new_uids)
         return new_uids
@@ -221,7 +265,7 @@ class People(sc.prettyobj):
         """
         state['_states'] =  {id(v):v for v in state['_states'].values()}
         self.__dict__ = state
-        
+
         return
 
     def scale_flows(self, inds):
@@ -235,7 +279,7 @@ class People(sc.prettyobj):
         """ Final updates at the very end of the timestep """
         sim = self.sim
         if sim.pars.use_aging:
-            self.age[self.alive.uids] += sim.dt
+            self.age[self.alive.uids] += sim.t.dt_year
         return
 
     def request_death(self, uids):
@@ -266,28 +310,35 @@ class People(sc.prettyobj):
         self.ti_dead[uids] = self.sim.ti
         return
 
-    def resolve_deaths(self):
+    def step_die(self):
         """ Carry out any deaths that took place this timestep """
         death_uids = (self.ti_dead <= self.sim.ti).uids
         self.alive[death_uids] = False
+
+        # Execute deaths that took place this timestep (i.e., changing the `alive` state of the agents). This is executed
+        # before analyzers have run so that analyzers are able to inspect and record outcomes for agents that died this timestep
+        for disease in self.sim.diseases():
+            if isinstance(disease, ss.Disease):
+                disease.step_die(death_uids)
+
         return death_uids
-    
+
     def remove_dead(self):
         """
         Remove dead agents
         """
         uids = self.dead.uids
         if len(uids):
-            
+
             # Remove the UIDs from the networks too
             for network in self.sim.networks.values():
                 network.remove_uids(uids) # TODO: only run once every nth timestep
-                
+
             # Calculate the indices to keep
-            self.auids = self.auids.remove(uids)
+            self.auids = self.auids[np.isin(self.auids, np.unique(uids), assume_unique=True, invert=True, kind='sort')]
 
         return
-    
+
     @property
     def dead(self):
         """ Dead boolean """
@@ -305,7 +356,13 @@ class People(sc.prettyobj):
         res.new_deaths[ti] = np.count_nonzero(self.ti_dead == ti)
         res.cum_deaths[ti] = np.sum(res.new_deaths[:ti]) # TODO: inefficient to compute the cumulative sum on every timestep!
         return
-    
+
+    def finish_step(self):
+        # self.update_results() # This is called separately
+        self.remove_dead()
+        self.update_post()
+        return
+
     def person(self, ind):
         """ Get all the properties for a single person """
         person = Person()
@@ -314,12 +371,12 @@ class People(sc.prettyobj):
         for key in self.states.keys():
             person[key] = self.states[key][ind]
         return person
-            
+
 
 class Person(sc.objdict):
     """ A simple class to hold all attributes of a person """
     def to_df(self):
         """ Convert to a dataframe """
-        df = sc.dataframe.from_dict(self, orient='index', columns='value')
+        df = sc.dataframe.from_dict(self, orient='index', columns=['value'])
         df.index.name = 'key'
         return df
diff --git a/starsim/products.py b/starsim/products.py
index bcaea4f..145a543 100644
--- a/starsim/products.py
+++ b/starsim/products.py
@@ -1,11 +1,10 @@
 """
 Define products
 """
-
 import starsim as ss
 import sciris as sc
 import numpy as np
-
+import pandas as pd
 
 __all__ = ['Product', 'Dx', 'Tx', 'Vx']
 
@@ -25,7 +24,7 @@ class Product(ss.Module):
 
 class Dx(Product):
     """
-    Generic class for diagnostics 
+    Generic class for diagnostics
     """
 
     def __init__(self, df, hierarchy=None, *args, **kwargs):
@@ -48,10 +47,10 @@ class Dx(Product):
     def default_value(self):
         return len(self.hierarchy) - 1
 
-    def administer(self, sim, uids, return_format='dict'):
+    def administer(self, uids, return_format='dict'):
         """
         Administer a testing product.
-        
+
         Returns:
 
              if return_format=='array': an array of length len(inds) with integer entries that map each person to one of the result_states
@@ -59,11 +58,11 @@ class Dx(Product):
         """
 
         # Pre-fill with the default value, which is set to be the last value in the hierarchy
-        results = sc.dataframe({'uids': uids, 'result': self.default_value})
+        results = pd.Series(self.default_value,index=uids)
 
         for disease in self.diseases:
             for state in self.health_states:
-                this_state = getattr(sim.diseases[disease], state)
+                this_state = getattr(self.sim.diseases[disease], state)
                 true_uids = this_state.uids # Find people for which this state is true
                 these_uids = true_uids.intersect(uids) # Find intersection of people in this state and the supplied UIDs
 
@@ -71,20 +70,18 @@ class Dx(Product):
                 df_filter = (self.df.state == state) & (self.df.disease == disease)
                 thisdf = self.df[df_filter]  # apply filter to get the results for this state & genotype
                 probs = [thisdf[thisdf.result == result].probability.values[0] for result in self.hierarchy]
-                self.result_dist.pk = probs  # Overwrite distribution probabilities
+                self.result_dist.pars['p'] = probs  # Overwrite distribution probabilities
 
                 # Sort people into one of the possible result states and then update their overall results
                 this_result = self.result_dist.rvs(these_uids)
-                row_inds = sc.findinds(results.uids.isin(these_uids))
-                results.loc[row_inds, 'result'] = np.minimum(this_result, results.loc[row_inds, 'result'])
-
-            if return_format == 'dict':
-                output = {self.hierarchy[i]: results[results.result == i].uids.values for i in range(len(self.hierarchy))}
-            elif return_format == 'array':
-                output = results
-
-        return output
+                results.loc[these_uids] = np.minimum(this_result, results.loc[these_uids])
 
+        if return_format == 'dict':
+            return {k: ss.uids(results.index[results == i]) for i, k in enumerate(self.hierarchy)}
+        elif return_format == 'array':
+            return results
+        else:
+            raise Exception('Unknown return format')
 
 class Tx(Product):
     """
@@ -98,7 +95,7 @@ class Tx(Product):
         self.efficacy_dist = ss.bernoulli(p=0)
         return
 
-    def administer(self, sim, uids, return_format='dict'):
+    def administer(self, uids, return_format='dict'):
         """
         Loop over treatment states to determine those who are successfully treated and clear infection
         """
@@ -106,26 +103,20 @@ class Tx(Product):
         tx_successful = []  # Initialize list of successfully treated individuals
 
         for disease_name in self.diseases:
-
-            disease = sim.diseases[disease_name]
+            disease = self.sim.diseases[disease_name]
 
             for state in self.health_states:
-
                 pre_tx_state = getattr(disease, state)
                 true_uids = pre_tx_state.uids # People in this state
                 these_uids = true_uids.intersect(uids)
 
                 if len(these_uids):
-
                     df_filter = (self.df.state == state) & (self.df.disease == disease_name)  # Filter by state
                     thisdf = self.df[df_filter]  # apply filter to get the results for this state & genotype
 
                     # Determine whether treatment is successful
                     self.efficacy_dist.set(p=thisdf.efficacy.values[0])
-
-                    # HACK to reset the efficacy_dist as it is called multiple times per timestep. TODO: Refactor
-                    self.efficacy_dist.jump(sim.ti+1)
-                    eff_treat_inds = self.efficacy_dist.filter(these_uids)
+                    eff_treat_inds = self.efficacy_dist.filter(these_uids) # TODO: think if there's a way of not calling this inside a loop like this
 
                     post_tx_state_name = thisdf.post_state.values[0]
                     post_tx_state = getattr(disease, post_tx_state_name)
diff --git a/starsim/regression/pars_v2.0.0.json b/starsim/regression/pars_v2.0.0.json
new file mode 100644
index 0000000..15d5dd1
--- /dev/null
+++ b/starsim/regression/pars_v2.0.0.json
@@ -0,0 +1,200 @@
+{
+  "pars": {
+    "verbose": 0,
+    "n_agents": 10000,
+    "total_pop": 10000,
+    "pop_scale": 1.0,
+    "unit": "year",
+    "start": 2000,
+    "stop": 2020,
+    "dur": 20,
+    "dt": 0.2,
+    "rand_seed": 2,
+    "slot_scale": 5,
+    "min_slots": 100,
+    "birth_rate": null,
+    "death_rate": null,
+    "use_aging": true,
+    "births": {
+      "birth_rate": 30,
+      "rel_birth": 1,
+      "units": 0.001
+    },
+    "deaths": {
+      "rel_death": 1,
+      "death_rate": {
+        "type": "Dist",
+        "classname": "bernoulli",
+        "tracestr": "pars_deaths_death_rate",
+        "diststr": "",
+        "pars": {
+          "p": {
+            "python_class": "<class 'function'>"
+          }
+        }
+      },
+      "units": 0.001
+    },
+    "randomnet": {
+      "n_contacts": {
+        "type": "Dist",
+        "classname": "constant",
+        "tracestr": "pars_randomnet_n_contacts",
+        "diststr": "",
+        "pars": {
+          "v": 10
+        }
+      },
+      "dur": 0
+    },
+    "mfnet": {
+      "duration": {
+        "type": "Dist",
+        "classname": "lognorm_ex",
+        "tracestr": "pars_mfnet_duration",
+        "diststr": "",
+        "pars": {
+          "mean": 15,
+          "std": 1.0
+        }
+      },
+      "participation": {
+        "type": "Dist",
+        "classname": "bernoulli",
+        "tracestr": "pars_mfnet_participation",
+        "diststr": "",
+        "pars": {
+          "p": 0.9
+        }
+      },
+      "debut": {
+        "type": "Dist",
+        "classname": "normal",
+        "tracestr": "pars_mfnet_debut",
+        "diststr": "",
+        "pars": {
+          "loc": 16,
+          "scale": 1.0
+        }
+      },
+      "acts": {
+        "type": "Dist",
+        "classname": "poisson",
+        "tracestr": "pars_mfnet_acts",
+        "diststr": "",
+        "pars": {
+          "lam": 80
+        }
+      },
+      "rel_part_rates": 1.0
+    },
+    "maternalnet": {},
+    "sir": {
+      "log": false,
+      "beta": {
+        "classname": "beta",
+        "v": 0.1,
+        "unit": "year",
+        "parent_unit": "year",
+        "parent_dt": 0.2,
+        "parent_name": "Deaths",
+        "self_dt": 1.0,
+        "factor": 5.0,
+        "values": 0.0208516376390232
+      },
+      "init_prev": {
+        "type": "Dist",
+        "classname": "bernoulli",
+        "tracestr": "pars_sir_init_prev",
+        "diststr": "",
+        "pars": {
+          "p": 0.01
+        }
+      },
+      "dur_inf": {
+        "type": "Dist",
+        "classname": "lognorm_ex",
+        "tracestr": "pars_sir_dur_inf",
+        "diststr": "",
+        "pars": {
+          "mean": {
+            "classname": "dur",
+            "v": 6,
+            "unit": "year",
+            "parent_unit": "year",
+            "parent_dt": 0.2,
+            "parent_name": "Deaths",
+            "self_dt": 1.0,
+            "factor": 5.0,
+            "values": 30.0
+          },
+          "std": 1.0
+        }
+      },
+      "p_death": {
+        "type": "Dist",
+        "classname": "bernoulli",
+        "tracestr": "pars_sir_p_death",
+        "diststr": "",
+        "pars": {
+          "p": 0.01
+        }
+      }
+    },
+    "sis": {
+      "log": false,
+      "beta": {
+        "classname": "beta",
+        "v": 0.05,
+        "unit": "year",
+        "parent_unit": "year",
+        "parent_dt": 0.2,
+        "parent_name": "Deaths",
+        "self_dt": 1.0,
+        "factor": 5.0,
+        "values": 0.010206218313011495
+      },
+      "init_prev": {
+        "type": "Dist",
+        "classname": "bernoulli",
+        "tracestr": "pars_sis_init_prev",
+        "diststr": "",
+        "pars": {
+          "p": 0.01
+        }
+      },
+      "dur_inf": {
+        "type": "Dist",
+        "classname": "lognorm_ex",
+        "tracestr": "pars_sis_dur_inf",
+        "diststr": "",
+        "pars": {
+          "mean": {
+            "classname": "dur",
+            "v": 10,
+            "unit": "year",
+            "parent_unit": "year",
+            "parent_dt": 0.2,
+            "parent_name": "Deaths",
+            "self_dt": 1.0,
+            "factor": 5.0,
+            "values": 50.0
+          },
+          "std": 1.0
+        }
+      },
+      "waning": {
+        "classname": "rate",
+        "v": 0.05,
+        "unit": "year",
+        "parent_unit": "year",
+        "parent_dt": 0.2,
+        "parent_name": "Deaths",
+        "self_dt": 1.0,
+        "factor": 5.0,
+        "values": 0.01
+      },
+      "imm_boost": 1.0
+    }
+  }
+}
\ No newline at end of file
diff --git a/starsim/results.py b/starsim/results.py
index 001cfd7..23c4e2b 100644
--- a/starsim/results.py
+++ b/starsim/results.py
@@ -1,76 +1,293 @@
 """
 Result structures.
 """
-
 import numpy as np
 import sciris as sc
 import starsim as ss
-
+import matplotlib.pyplot as plt
 
 __all__ = ['Result', 'Results']
 
 
-class Result(np.ndarray):
-    
-    def __new__(cls, module=None, name=None, shape=None, dtype=None, scale=None):
-        arr = np.zeros(shape=shape, dtype=dtype).view(cls)
-        arr.name = name
-        arr.module = module
-        arr.scale = scale
-        return arr
-    
+class Result(ss.BaseArr):
+    """
+    Array-like container for holding sim results.
+
+    Args:
+        module (str): the name of the parent module, e.g. 'hiv'
+        name (str): the name of this result, e.g. 'new_infections'
+        shape (int/tuple): the shape of the result array (usually module.npts)
+        scale (bool): whether or not the result scales by population size (e.g. a count does, a prevalence does not)
+        auto_plot (bool): whether to include automatically in sim.plot() results
+        label (str): a human-readable label for the result
+        values (array): prepopulate the Result with these values
+        timevec (array): an array of time points
+        low (array): values for the lower bound
+        high (array): values for the upper bound
+
+    In most cases, ``ss.Result`` behaves exactly like ``np.array()``, except with
+    the additional fields listed above. To see everything contained in a result,
+    you can use result.disp().
+    """
+    def __init__(self, name=None, label=None, dtype=float, shape=None, scale=True, auto_plot=True,
+                 module=None, values=None, timevec=None, low=None, high=None):
+        # Copy inputs
+        self.name = name
+        self.label = label
+        self.module = module
+        self.scale = scale
+        self.auto_plot = auto_plot
+        self.timevec = timevec
+        self.low = low
+        self.high = high
+        self.dtype = dtype
+        self.shape = shape
+        self.values = values
+        self.init_values()
+        return
+
     def __repr__(self):
-        modulestr = f'{self.module}.' if (self.module is not None) else ''
         cls_name = self.__class__.__name__
         arrstr = super().__repr__().removeprefix(cls_name)
-        out = f'{cls_name}({modulestr}{self.name}):\narray{arrstr}'
+        out = f'{cls_name}({self.key}):\narray{arrstr}'
         return out
 
-    def __array_finalize__(self, obj):
-        if obj is None:
-            return
-        self.name   = getattr(obj, 'name',   None)
-        self.module = getattr(obj, 'module', None)
-        self.scale  = getattr(obj, 'scale',  None)
+    def __str__(self):
+        cls_name = self.__class__.__name__
+        try:
+            minval = self.values.min()
+            meanval = self.values.mean()
+            maxval = self.values.max()
+            valstr = f'min={minval:n}, mean={meanval:n}, max={maxval:n}'
+        except:
+            valstr = f'{self.values}'
+        out = f'{cls_name}({self.key}: {valstr})'
+        return out
+
+    def __getitem__(self, key):
+        """ Allow e.g. result['low'] """
+        if isinstance(key, str):
+            return getattr(self, key)
+        else:
+            return super().__getitem__(key)
+
+    @property
+    def initialized(self):
+        return self.values is not None
+
+    @property
+    def has_dates(self):
+        """ Check whether the time vector uses dates (rather than numbers) """
+        try:    return not sc.isnumber(self.timevec[0])
+        except: return False
+
+    def init_values(self, values=None, dtype=None, shape=None, force=False):
+        """ Handle values """
+        if not self.initialized or force:
+            values = sc.ifelse(values, self.values)
+            dtype = sc.ifelse(dtype, self.dtype)
+            shape = sc.ifelse(shape, self.shape)
+            if values is not None: # Create if values already supplied
+                self.values = np.array(values, dtype=dtype)
+                dtype = self.values.dtype
+                shape = self.values.shape
+            elif shape is not None: # Or if a shape is provided, initialize
+                self.values = np.zeros(shape=shape, dtype=dtype)
+            else:
+                self.values = None
+            self.dtype = dtype
+            self.shape = shape
+        return self.values
+
+    def update(self, *args, **kwargs):
+        """ Update parameters, and initialize values if needed """
+        super().update(*args, **kwargs)
+        self.init_values()
         return
 
-    def __array_wrap__(self, obj, **kwargs):
-        if obj.shape == ():
-            return obj[()]
+    @property
+    def key(self):
+        """ Return the unique key of the result: <module>.<name>, e.g. "hiv.new_infections" """
+        modulestr = f'{self.module}.' if (self.module is not None) else ''
+        namestr = self.name if (self.name is not None) else 'unnamed'
+        key = modulestr + namestr
+        return key
+
+    @property
+    def full_label(self):
+        """ Return the full label of the result: <Module>: <label>, e.g. "HIV: New infections" """
+        reslabel = sc.ifelse(self.label, self.name)
+        if self.module == 'sim': # Don't add anything if it's the sim
+            full = f'Sim: {reslabel}'
         else:
-            return super().__array_wrap__(obj, **kwargs)
-    
-    def to_df(self):
-        return sc.dataframe({self.name:self})
-    
+            try:
+                mod = ss.find_modules(flat=True)[self.module]
+                modlabel = mod.__name__
+                assert self.module == modlabel.lower(), f'Mismatch: {self.module}, {modlabel}' # Only use the class name if the module name is the default
+            except: # Don't worry if we can't find it, just use the module name
+                modlabel = self.module.title()
+            full = f'{modlabel}: {reslabel}'
+        return full
+
+    def to_df(self, sep='_', rename=False):
+        """
+        Convert to a dataframe with timevec, value, low, and high columns
+
+        Args:
+            rename (bool): if True, rename the columns with the name of the result (else value, low, high)
+        """
+        data = dict()
+        if self.timevec is not None:
+            data['timevec'] = self.timevec
+        valcol = self.name if rename else 'value'
+        data[valcol] = self.values
+        for key in ['low', 'high']:
+            val = self[key]
+            valcol = f'{self.name}{sep}{key}' if rename else key
+            if val is not None:
+                data[valcol] = val
+        df = sc.dataframe(data)
+        return df
+
+    def plot(self, fig=None, ax=None, fig_kw=None, plot_kw=None, fill_kw=None, **kwargs):
+        """ Plot a single result; kwargs are interpreted as plot_kw """
+        # Prepare inputs
+        fig_kw = sc.mergedicts(fig_kw)
+        plot_kw = sc.mergedicts(dict(lw=3, alpha=0.8), plot_kw, kwargs)
+        fill_kw = sc.mergedicts(dict(alpha=0.1), fill_kw)
+        if fig is None and ax is None:
+            fig = plt.figure(**fig_kw)
+        if ax is None:
+            ax = plt.subplot(111)
+        if self.timevec is None:
+            errormsg = f'Cannot figure out how to plot {self}: no time data associated with it'
+            raise ValueError(errormsg)
+
+        # Plot bounds
+        if self.low is not None and self.high is not None:
+            ax.fill_between(self.timevec, self.low, self.high, **fill_kw)
+
+        # Plot results
+        plt.plot(self.timevec, self.values, **plot_kw)
+        plt.title(self.full_label)
+        plt.xlabel('Time')
+        sc.commaticks(ax)
+        if self.has_dates:
+            sc.dateformatter(ax)
+        if (self.values.min() >= 0) and (plt.ylim()[0]<0): # Don't allow axis to go negative if results don't
+            plt.ylim(bottom=0)
+        return ss.return_fig(fig)
+
 
 class Results(ss.ndict):
-    
-    def __init__(self, module, strict=True, *args, **kwargs):
-        super().__init__(type=Result, strict=strict)
+    """ Container for storing results """
+    def __init__(self, module, *args, strict=True, **kwargs):
         if hasattr(module, 'name'):
             module = module.name
         self.setattribute('_module', module)
+        super().__init__(type=Result, strict=strict, *args, **kwargs)
         return
-    
+
+    def __repr__(self, indent=2, **kwargs): # kwargs are not used, but are needed for disp() to work
+        string = f'Results({self._module})\n'
+        for i,k,v in self.enumitems():
+            if k != 'timevec':
+                entry = f'{v}'
+                if '\n' in entry: # Check if the string is multi-line
+                    lines = entry.splitlines()
+                    entry = f'{i}. {lines[0]}\n'
+                    entry += '\n'.join(' '*indent + f'{i}.' + line for line in lines[1:])
+                    string += entry + '\n'
+                else:
+                    string += f'{i}. {v}\n'
+        string = string.rstrip()
+        return string
+
+    def disp(self, *args, **kwargs):
+        print(super().__repr__(*args, **kwargs))
+        return
+
     def append(self, arg, key=None):
+        """ This is activated by adding as well, e.g. results += result """
         if isinstance(arg, (list, tuple)):
             result = ss.Result(self._module, *arg)
         elif isinstance(arg, dict):
             result = ss.Result(self._module, **arg)
         else:
             result = arg
+
+        if not isinstance(result, Result):
+            warnmsg = f'You are adding a result of type {type(result)} to Results, which is inadvisable.'
+            ss.warn(warnmsg)
+
         if result.module != self._module:
+            if result.module:
+                warnmsg = f'You are adding a result from module {result.module} to module {self._module}; check that this is intentional.'
+                ss.warn(warnmsg)
             result.module = self._module
-        
+
         super().append(result, key=key)
         return
-    
-    def to_df(self):
-        pass
-    
-    def __repr__(self, *args, **kwargs): # TODO: replace with dataframe summary
-        return super().__repr__(*args, **kwargs)
-        
-    def plot(self):
-        pass
+
+    @property
+    def all_results(self):
+        """ Iterator over all results, skipping any nested values """
+        return iter(res for res in self.values() if isinstance(res, Result))
+
+    @property
+    def equal_len(self):
+        """ Check if all results are equal length """
+        lengths = [len(res) for res in self.flatten().values()]
+        return len(set(lengths)) == 1
+
+    def flatten(self, sep='_', only_results=True):
+        """ Turn from a nested dictionary into a flat dictionary, keeping only results by default """
+        out = sc.flattendict(self, sep=sep)
+        if only_results:
+            out = sc.objdict({k:v for k,v in out.items() if isinstance(v, Result)})
+        return out
+
+    def to_df(self, sep='_', descend=False):
+        """ Merge all results dataframes into one """
+        if not descend:
+            dfs = [res.to_df(sep=sep, rename=True) for res in self.all_results]
+            if len(dfs):
+                df = dfs[0]
+                for df2 in dfs[1:]:
+                    df = df.merge(df2)
+            else:
+                df = None
+        else:
+            if self.equal_len:
+                flat = self.flatten(sep=sep, only_results=True)
+                flat = dict(timevec=self.timevec) | flat # Prepend the timevec
+                df = sc.dataframe.from_dict(flat)
+            else:
+                df = sc.objdict() # For non-equal lengths, actually return an objdict rather than a dataframe
+                df.sim = self.to_df(sep=sep, descend=False)
+                for k,v in self.items():
+                    if isinstance(v, Results):
+                        thisdf = v.to_df(sep=sep, descend=False) # Only allow one level of nesting
+                        if thisdf is not None:
+                            df[k] = thisdf
+        return df
+
+    def plot(self, style='fancy', fig_kw=None, plot_kw=None):
+        """ Plot all the results """
+        # Prepare the inputs
+        fig_kw = sc.mergedicts(fig_kw)
+        plot_kw = sc.mergedicts(plot_kw)
+        results = list(self.all_results)
+        nrows,ncols = sc.getrowscols(len(results))
+
+        # Do the plotting
+        with sc.options.with_style(style):
+            fig = plt.figure(**fig_kw)
+            for i,res in enumerate(results):
+                ax = plt.subplot(nrows, ncols, i+1)
+                res.plot(ax=ax, **plot_kw)
+            sc.figlayout()
+        return ss.return_fig(fig)
+
+
+
diff --git a/starsim/run.py b/starsim/run.py
index 9d9b6c2..718f705 100644
--- a/starsim/run.py
+++ b/starsim/run.py
@@ -1,23 +1,32 @@
 """
 Utilities for running in parallel
 """
-
 import numpy as np
 import sciris as sc
+import matplotlib.pyplot as plt
 import starsim as ss
 
 __all__ = ['MultiSim', 'single_run', 'multi_run', 'parallel']
 
 
-class MultiSim(sc.prettyobj):
+class MultiSim:
     """
     Class for running multiple copies of a simulation.
+
+    Args:
+        sims (Sim/list): a single sim or a list of sims
+        base_sim (Sim): the sim used for shared properties; if not supplied, the first of the sims provided
+        label (str): the name of the multisim
+        n_runs (int): if a single sim is provided, the number of replicates (default 4)
+        initialize (bool): whether or not to initialize the sims (otherwise, initialize them during run)
+        inplace (bool): whether to modify the sims in-place (default True); else return new sims
+        debug (bool): if True, run in serial
+        kwargs (dict): stored in run_args and passed to run()
     """
-
-    def __init__(self, sims=None, base_sim=None, label=None, initialize=False, *args, **kwargs):
-
+    def __init__(self, sims=None, base_sim=None, label=None, n_runs=4, initialize=False,
+                 inplace=True, debug=False, **kwargs):
         # Handle inputs
-        super().__init__(*args, **kwargs)
+        super().__init__(**kwargs)
         if base_sim is None:
             if isinstance(sims, ss.Sim):
                 base_sim = sims
@@ -33,9 +42,11 @@ class MultiSim(sc.prettyobj):
         self.sims = sims
         self.base_sim = base_sim
         self.label = base_sim.label if (label is None and base_sim is not None) else label
-        self.run_args = sc.mergedicts(kwargs)
+        self.run_args = sc.mergedicts(dict(n_runs=n_runs, inplace=inplace, debug=debug), kwargs)
         self.results = None
+        self.summary = None
         self.which = None  # Whether the multisim is to be reduced, combined, etc.
+        self.timer = sc.timer() # Create a timer
 
         # Optionally initialize
         if initialize:
@@ -44,7 +55,60 @@ class MultiSim(sc.prettyobj):
         return
 
     def __len__(self):
-        return len(self.sims)
+        """ The length of a MultiSim is how many sims it contains """
+        try:
+            return len(self.sims)
+        except:
+            return 0
+
+    def __repr__(self):
+        """ Return a brief description of a multisim; see multisim.disp() for the more detailed version. """
+        try:
+            labelstr = f'"{self.label}"; ' if self.label else ''
+            string   = f'MultiSim({labelstr}n_sims: {len(self)}; base: {self.base_sim})'
+        except Exception as E:
+            string = sc.objectid(self)
+            string += f'Warning, multisim appears to be malformed:\n{str(E)}'
+        return string
+
+    def brief(self):
+        """ A single-line display of the MultiSim; same as print(multisim) """
+        print(self)
+        return
+
+    def show(self, output=False):
+        """
+        Print a moderate length summary of the MultiSim. See also multisim.disp()
+        (detailed output) and multisim.brief() (short output).
+
+        Args:
+            output (bool): if true, return a string instead of printing output
+
+        **Example**::
+
+            msim = ss.MultiSim(ss.demo(run=False), label='Example multisim')
+            msim.run()
+            msim.show() # Prints moderate length output
+        """
+        labelstr = f' "{self.label}"' if self.label else ''
+        simlenstr = f'{len(self)}'
+        string  = f'MultiSim{labelstr} summary:\n'
+        string += f'  Number of sims: {simlenstr}\n'
+        string += f'  Reduced/combined: {self.which}\n'
+        string += f'  Base: {self.base_sim}\n'
+        if self.sims:
+            string += '  Sims:\n'
+            for s,sim in enumerate(self.sims):
+                string += f'    {s}: {sim}\n'
+        if not output:
+            print(string)
+            return
+        else:
+            return string
+
+    def disp(self):
+        """ Display the full object """
+        return sc.pr(self)
 
     def init_sims(self, **kwargs):
         """
@@ -59,17 +123,20 @@ class MultiSim(sc.prettyobj):
 
         # Initialize the sims but don't run them
         kwargs = sc.mergedicts(self.run_args, kwargs, {'do_run': False})  # Never run, that's the point!
+        kwargs.pop('inplace', None)
+        kwargs.pop('debug', None)
         self.sims = multi_run(sims, **kwargs)
 
         return
 
-    def run(self, reduce=False, **kwargs):
+    def run(self, **kwargs):
         """
-        Run the sims
+        Run the sims; see ``ss.multi_run()`` for additional arguments
 
         Args:
-            reduce  (bool): whether to reduce after running (see reduce())
-            kwargs  (dict): passed to multi_run(); use run_args to pass arguments to sim.run()
+            n_runs (int): how many replicates of each sim to run (if a list of sims is not provided)
+            inplace (bool): whether to modify the sims in place (otherwise return copies)
+            kwargs (dict): passed to multi_run(); use run_args to pass arguments to sim.run()
 
         Returns:
             None (modifies MultiSim object in place)
@@ -87,12 +154,21 @@ class MultiSim(sc.prettyobj):
                     sim.label = f'Sim {s}'
 
         # Run
+        self.timer.start()
         kwargs = sc.mergedicts(self.run_args, kwargs)
-        self.sims = multi_run(sims, **kwargs)
+        inplace = kwargs.pop('inplace', True)
+        debug = kwargs.pop('debug', False)
+        if debug:
+            run_sims = [single_run(sim, **kwargs) for sim in sims]
+        else: # The next line does all the work!
+            run_sims = multi_run(sims, **kwargs) # Output sims are copies due to the pickling during parallelization
 
-        # Reduce
-        if reduce:
-            self.reduce()
+        # Handle output
+        if inplace and isinstance(self.sims, list) and len(run_sims) == len(self.sims): # Validation
+            for old,new in zip(self.sims, run_sims):
+                old.__dict__.update(new.__dict__) # Update the same object with the new results
+        self.sims = run_sims # Just overwrite references
+        self.timer.stop()
 
         return self
 
@@ -149,7 +225,6 @@ class MultiSim(sc.prettyobj):
             msim.reduce()
             msim.summarize()
         """
-
         if use_mean:
             if bounds is None:
                 bounds = 2
@@ -162,7 +237,7 @@ class MultiSim(sc.prettyobj):
                 except Exception as E:
                     errormsg = (f'Could not figure out how to convert {quantiles} into a quantiles object:'
                                 f' must be a dict with keys low, high or a 2-element array ({str(E)})')
-                    raise ValueError(errormsg)
+                    raise ValueError(errormsg) from E
 
         # Store information on the sims
         n_runs = len(self)
@@ -170,35 +245,35 @@ class MultiSim(sc.prettyobj):
         reduced_sim.metadata = dict(parallelized=True, combined=False, n_runs=n_runs, quantiles=quantiles,
                                     use_mean=use_mean, bounds=bounds)  # Store how this was parallelized
 
-        # Perform the statistics
+        # Calculate the statistics
         raw = {}
 
-        rkeys = reduced_sim.results.keys()
-
+        rflat = reduced_sim.results.flatten()
+        rkeys = list(rflat.keys())
         for rkey in rkeys:
-            raw[rkey] = np.zeros((reduced_sim.res_npts, len(self.sims)))
+            raw[rkey] = np.zeros((len(reduced_sim), len(self.sims)))
             for s, sim in enumerate(self.sims):
-                vals = sim.results[rkey].values
-                raw[rkey][:, s] = vals
+                flat = sim.results.flatten()
+                raw[rkey][:, s] = flat[rkey]
 
         for rkey in rkeys:
-            results = reduced_sim.results
+            res = rflat[rkey]
             if use_mean:
                 r_mean = np.mean(raw[rkey], axis=1)
                 r_std = np.std(raw[rkey], axis=1)
-                results[rkey].values[:] = r_mean
-                results[rkey].low = r_mean - bounds * r_std
-                results[rkey].high = r_mean + bounds * r_std
+                res[:] = r_mean
+                res.low = r_mean - bounds * r_std
+                res.high = r_mean + bounds * r_std
             else:
-                results[rkey].values[:] = np.quantile(raw[rkey], q=0.5, axis=1)
-                results[rkey].low = np.quantile(raw[rkey], q=quantiles['low'], axis=1)
-                results[rkey].high = np.quantile(raw[rkey], q=quantiles['high'], axis=1)
+                res[:] = np.quantile(raw[rkey], q=0.5, axis=1)
+                res.low = np.quantile(raw[rkey], q=quantiles['low'], axis=1)
+                res.high = np.quantile(raw[rkey], q=quantiles['high'], axis=1)
 
         # Compute and store final results
-        reduced_sim.compute_summary()
+        reduced_sim.summarize()
         self.orig_base_sim = self.base_sim
         self.base_sim = reduced_sim
-        self.results = reduced_sim.results
+        self.results = ss.Results('MultiSim').merge(rflat) # Create the dictionary and merge it
         self.summary = reduced_sim.summary
         self.which = 'reduced'
 
@@ -227,8 +302,93 @@ class MultiSim(sc.prettyobj):
         """
         return self.reduce(use_mean=False, quantiles=quantiles, **kwargs)
 
+    def summarize(self, method='mean', quantiles=None, how='default'):
+        """
+        Summarize the simulations statistically.
 
-def single_run(sim, ind=0, reseed=True, keep_people=False, run_args=None, sim_args=None,
+        Args:
+            method (str): one of 'mean' (default: [mean, 2*std]), 'median' ([median, min, max]), or 'all' (all results)
+            quantiles (dict): if method='median', use these quantiles
+            how (str): passed to sim.summarize()
+        """
+
+        # Compute the summaries
+        summaries = []
+        for sim in self.sims:
+            summaries.append(sim.summarize(how=how))
+
+        summary = sc.dcp(summaries[0]) # Use the first one as a template
+        for k in summary.keys():
+            arr = np.array([s[k] for s in summaries])
+            if method == 'all':
+                summary[k] = arr
+            elif method == 'mean':
+                summary[k] = sc.objdict({'mean':arr.mean(), 'std':arr.std(), 'sem':sc.sem(arr)})
+            elif method == 'median':
+                if quantiles is None:
+                    quantiles = sc.objdict({'median':0.5, 'min':0, 'max':1, 'q25':0.25, 'q75':0.75})
+                elif isinstance(quantiles, list):
+                    quantiles = {q:q for q in quantiles}
+                summary[k] = {q:v for q,v in zip(quantiles, np.quantile(arr, quantiles))}
+
+        self.summary = summary # Could reconcile with reduce()'s summary
+
+        return summary
+
+    def plot(self, key=None, fig=None, fig_kw=None, plot_kw=None, fill_kw=None):
+        """
+        Plot all results in the MultiSim object.
+
+        If the MultiSim object has been reduced (i.e. mean or median), then plot
+        the best value and uncertainty bound. Otherwise, plot individual sims.
+
+        Args:
+            key (str): the results key to plot (by default, all)
+            fig (Figure): if provided, plot results into an existing figure
+            fig_kw (dict): passed to ``plt.subplots()``
+            plot_kw (dict): passed to ``plt.plot()``
+            fill_kw (dict): passed to ``plt.fill_between()``
+        """
+        # Has not been reduced yet, plot individual sim
+        if self.which is None:
+            fig = None
+            alpha = 0.7 if len(self) < 5 else 0.5
+            plot_kw = sc.mergedicts({'alpha':alpha}, plot_kw)
+            with ss.options.context(jupyter=False): # Always return the figure
+                for sim in self.sims:
+                    fig = sim.plot(key=key, fig=fig, fig_kw=fig_kw, plot_kw=plot_kw)
+            plt.legend()
+
+        # Has been reduced, plot with uncertainty bounds
+        else:
+            flat = self.results
+            n_cols = np.ceil(np.sqrt(len(flat))) # TODO: remove duplication with sim.plot()
+            default_figsize = np.array([8, 6])
+            figsize_factor = np.clip((n_cols-3)/6+1, 1, 1.5) # Scale the default figure size based on the number of rows and columns
+            figsize = default_figsize*figsize_factor
+            fig_kw = sc.mergedicts({'figsize':figsize}, fig_kw)
+            fig_kw = sc.mergedicts(fig_kw)
+            fill_kw = sc.mergedicts({'alpha':0.2}, fill_kw)
+            plot_kw = sc.mergedicts({'lw':2, 'alpha':0.8}, plot_kw)
+            with sc.options.with_style('simple'):
+                if key is not None:
+                    flat = {k:v for k,v in flat.items() if k.startswith(key)}
+                if fig is None:
+                    fig, axs = sc.getrowscols(len(flat), make=True, **fig_kw)
+                else:
+                    axs = sc.toarray(fig.axes)
+
+                # Do the plotting
+                for ax, (key, res) in zip(axs.flatten(), flat.items()):
+                    ax.fill_between(res.timevec, res.low, res.high, **fill_kw)
+                    ax.plot(res.timevec, res, **plot_kw)
+                    ax.set_title(getattr(res, 'label', key))
+                    ax.set_xlabel('Year')
+
+        return ss.return_fig(fig)
+
+
+def single_run(sim, ind=0, reseed=True, shrink=True, run_args=None, sim_args=None,
                verbose=None, do_run=True, **kwargs):
     """
     Convenience function to perform a single simulation run. Mostly used for
@@ -240,7 +400,7 @@ def single_run(sim, ind=0, reseed=True, keep_people=False, run_args=None, sim_ar
         reseed      (bool)  : whether to generate a fresh seed for each run
         noise       (float) : the amount of noise to add to each run
         noisepar    (str)   : the name of the parameter to add noise to
-        keep_people (bool)  : whether to keep the people after the sim run
+        shrink      (bool)  : whether to shrink the sim after the sim run
         run_args    (dict)  : arguments passed to sim.run()
         sim_args    (dict)  : extra parameters to pass to the sim, e.g. 'n_infected'
         verbose     (int)   : detail to print
@@ -268,11 +428,7 @@ def single_run(sim, ind=0, reseed=True, keep_people=False, run_args=None, sim_ar
 
     if reseed:
         sim.pars['rand_seed'] += ind  # Reset the seed, otherwise no point of parallel runs
-        ss.set_seed()
-
-    if verbose >= 1:
-        verb = 'Running' if do_run else 'Creating'
-        print(f'{verb} a simulation using seed={sim["rand_seed"]}')
+        ss.set_seed() # Note: may not be needed
 
     # Handle additional arguments
     for key, val in sim_args.items():
@@ -280,7 +436,9 @@ def single_run(sim, ind=0, reseed=True, keep_people=False, run_args=None, sim_ar
         if key in sim.pars.keys():
             if verbose >= 1:
                 print(f'Setting key {key} from {sim[key]} to {val}')
-                sim[key] = val
+            sim.pars[key] = val
+            if key == 'rand_seed':
+                ss.set_seed() # Note: may not be needed
         else:
             raise sc.KeyNotFoundError(f'Could not set key {key}: not a valid parameter name')
 
@@ -289,24 +447,25 @@ def single_run(sim, ind=0, reseed=True, keep_people=False, run_args=None, sim_ar
         sim.run(**run_args)
 
     # Shrink the sim to save memory
-    if not keep_people:
+    if shrink:
         sim.shrink()
 
     return sim
 
 
-def multi_run(sim, n_runs=4, reseed=None, iterpars=None, keep_people=None, run_args=None, sim_args=None,
+def multi_run(sim, n_runs=4, reseed=None, iterpars=None, shrink=None, run_args=None, sim_args=None,
               par_args=None, do_run=True, parallel=True, n_cpus=None, verbose=None, **kwargs):
     """
-    For running multiple runs in parallel. If the first argument is a list of sims,
-    exactly these will be run and most other arguments will be ignored.
+    For running multiple sims in parallel. If the first argument is a list of sims
+    rather than a single sim, exactly these will be run and most other arguments
+    will be ignored.
 
     Args:
-        sim         (Sim)   : the sim instance to be run, or a list of sims.
+        sim         (Sim/list): the sim instance to be run, or a list of sims.
         n_runs      (int)   : the number of parallel runs
         reseed      (bool)  : whether or not to generate a fresh seed for each run (default: true for single, false for list of sims)
         iterpars    (dict)  : any other parameters to iterate over the runs; see sc.parallelize() for syntax
-        keep_people (bool)  : whether to keep the people after the sim run (default false)
+        shrink      (bool)  : whether to shrink the sim after the sim run
         run_args    (dict)  : arguments passed to sim.run()
         sim_args    (dict)  : extra parameters to pass to the sim
         par_args    (dict)  : arguments passed to sc.parallelize()
@@ -348,12 +507,12 @@ def multi_run(sim, n_runs=4, reseed=None, iterpars=None, keep_people=None, run_a
         if reseed is None: reseed = True
         iterkwargs = dict(ind=np.arange(n_runs))
         iterkwargs.update(iterpars)
-        kwargs = dict(sim=sim, reseed=reseed, verbose=verbose, keep_people=keep_people,
+        kwargs = dict(sim=sim, reseed=reseed, verbose=verbose, shrink=shrink,
                       sim_args=sim_args, run_args=run_args, do_run=do_run)
     elif isinstance(sim, list):  # List of sims
         if reseed is None: reseed = False
         iterkwargs = dict(sim=sim, ind=np.arange(len(sim)))
-        kwargs = dict(reseed=reseed, verbose=verbose, keep_people=keep_people, sim_args=sim_args, run_args=run_args,
+        kwargs = dict(reseed=reseed, verbose=verbose, shrink=shrink, sim_args=sim_args, run_args=run_args,
                       do_run=do_run)
     else:
         errormsg = f'Must be Sim object or list, not {type(sim)}'
@@ -394,7 +553,8 @@ Alternatively, to run without multiprocessing, set parallel=False.
             sims.append(sim)
 
     return sims
-                  
+
+
 def parallel(*args, **kwargs):
     """
     A shortcut to ``ss.MultiSim()``, allowing the quick running of multiple simulations
@@ -409,10 +569,12 @@ def parallel(*args, **kwargs):
 
     **Examples**::
 
-        s1 = ss.Sim(beta=0.01, label='Low')
-        s2 = ss.Sim(beta=0.02, label='High')
+        s1 = ss.Sim(n_agents=1000, label='Small', diseases='sis', networks='random')
+        s2 = ss.Sim(n_agents=2000, label='Large', diseases='sis', networks='random')
         ss.parallel(s1, s2).plot()
-        msim = ss.parallel([s1, s2], keep_people=True)
+        msim = ss.parallel([s1, s2], shrink=False)
     """
     sims = sc.mergelists(*args)
-    return MultiSim(sims=sims).run(**kwargs)
+    msim = MultiSim(sims=sims, **kwargs)
+    msim.run()
+    return msim
diff --git a/starsim/samples.py b/starsim/samples.py
index a8818a6..1e43f91 100644
--- a/starsim/samples.py
+++ b/starsim/samples.py
@@ -6,7 +6,6 @@ Hierarchy
 - samples: collection of results with same parameters but different seeds
 - dataset: collection of samples (with different parameters)
 """
-
 import io
 import zipfile
 import sciris as sc
@@ -146,7 +145,7 @@ class Samples:
             self.preload()
 
         return
-        
+
     def copy(self):
         """
         Shallow copy - shared cache, copied summary
@@ -269,7 +268,7 @@ class Samples:
         Returns: Array of seed values
         """
         return self.index.get_level_values("seed").values
-    
+
     @staticmethod
     def _seedfile(seed):
         """ Helper function to generate a seed file name """
@@ -281,8 +280,7 @@ class Samples:
         Args:
             folder: The folder name
             outputs: A list of tuples (df:pd.DataFrame, summary_row:dict) where the summary row as an entry 'seed' for the seed
-            identifiers: A list of columns to use as identifiers. These should appear in the summary dataframe and should have the same
-                         value for all samples.
+            identifiers: A list of columns to use as identifiers. These should appear in the summary dataframe and should have the same value for all samples.
         """
         zipdata = {} # Store all the data to be written as files inside the zipfile
         summary_rows = []
@@ -309,12 +307,12 @@ class Samples:
         # Finish working on and write the summary
         summary.set_index(identifiers, inplace=True)
         zipdata[summary_file] = summary.to_csv()
-        
+
         # Handle the zip file name
         if fname is None:
             fname = "-".join(str(row[x]) for x in identifiers[1:]) + ".zip"
         folder.mkdir(parents=True, exist_ok=True)
-        
+
         # Save the zip file
         sc.savezip(folder/fname, data=zipdata, tobytes=False)
 
@@ -349,7 +347,7 @@ class Samples:
         """
         for seed in self.seeds:
             yield seed, self.get(seed)
-            
+
     def __getitem__(self, item):
         """
         Overload getitem for convenience
@@ -401,8 +399,8 @@ class Samples:
 
         Args:
             fcn: A function to apply. It should take in a dataframe
-            *args: Additional arguments for ``fcn``
-            **kwargs: Additional arguments for ``fcn``
+            args: Additional arguments for ``fcn``
+            kwargs: Additional arguments for ``fcn``
 
         Returns: A list with the output of ``fcn``
         """
diff --git a/starsim/settings.py b/starsim/settings.py
index 1bccd52..70bb3ef 100644
--- a/starsim/settings.py
+++ b/starsim/settings.py
@@ -4,20 +4,19 @@ All options should be set using set() or directly, e.g.::
 
     ss.options(verbose=False)
 """
-
-import os
 import numpy as np
 import sciris as sc
 
 __all__ = ['dtypes', 'options']
 
 # Define Starsim-default data types
-dtypes = sc.objdict(
-    bool = bool,
-    int = np.int64,
-    float = np.float64,
-    result_float = np.float64,
-)
+class dtypes:
+    bool = bool
+    int = np.int64
+    rand_int = np.int32
+    rand_uint = np.uint32
+    float = np.float32
+    result_float = np.float64
 
 
 # Not public to avoid confusion with ss.options
@@ -51,7 +50,7 @@ class Options(sc.objdict):
         self.setattribute('optdesc', optdesc)  # Set the description as an attribute, not a dict entry
         self.setattribute('orig_options', sc.dcp(options))  # Copy the default options
         return
-    
+
     @staticmethod
     def get_orig_options():
         """
@@ -64,27 +63,42 @@ class Options(sc.objdict):
         options = sc.objdict()  # The options
 
         optdesc.verbose = 'Set default level of verbosity (i.e. logging detail): e.g., 0.1 is an update every 10 simulated timesteps.'
-        options.verbose = float(os.getenv('STARSIM_VERBOSE', 0.1))
+        options.verbose = sc.parse_env('STARSIM_VERBOSE', 0.1, 'float')
+
+        optdesc.license = 'Whether to print the license on import'
+        options.license = sc.parse_env('STARSIM_LICENSE', False, 'bool')
 
         optdesc.warnings = 'How warnings are handled: options are "warn" (default), "print", and "error"'
-        options.warnings = str(os.getenv('STARSIM_WARNINGS', 'warn'))
+        options.warnings = sc.parse_env('STARSIM_WARNINGS', 'warn', 'str')
+
+        optdesc.time_eps = 'Set size of smallest possible time unit (in units of sim time, e.g. "year" or "day")'
+        options.time_eps = sc.parse_env('STARSIM_TIME_EPS', 1e-6, 'float') # If unit = 'year', corresponds to ~30 seconds
 
         optdesc.sep = 'Set thousands seperator for text output'
-        options.sep = str(os.getenv('STARSIM_SEP', ','))
+        options.sep = sc.parse_env('STARSIM_SEP', ',', 'str')
 
-        optdesc.precision = 'Set arithmetic precision -- 32-bit by default for efficiency'
-        options.precision = int(os.getenv('STARSIM_PRECISION', 64))
+        optdesc.date_sep = 'Set seperator for dates'
+        options.date_sep = sc.parse_env('STARSIM_DATE_SEP', '.', 'str')
+
+        optdesc.jupyter = 'Set whether to use Jupyter settings: -1=auto, 0=False, 1=True'
+        options.jupyter = sc.parse_env('STARSIM_JUPYTER', -1, 'int')
+
+        optdesc.precision = 'Set arithmetic precision'
+        options.precision = sc.parse_env('STARSIM_PRECISION', 64, 'int')
 
         optdesc._centralized = 'If True, revert to centralized random number generation (NOT ADVISED).'
-        options._centralized = False
+        options._centralized = sc.parse_env('STARSIM_CENTRALIZED', False, 'bool')
 
         return optdesc, options
 
     def __call__(self, *args, **kwargs):
         """Allow ``ss.options(dpi=150)`` instead of ``ss.options.set(dpi=150)`` """
-
         return self.set(*args, **kwargs)
 
+    def to_dict(self):
+        ''' Pull out only the settings from the options object '''
+        return {k:v for k,v in self.items()}
+
     def __repr__(self):
         """ Brief representation """
         output = sc.objectid(self)
@@ -143,7 +157,7 @@ class Options(sc.objdict):
         # Handle other keys
         elif key is not None:
             kwargs = sc.mergedicts(kwargs, {key: value})
-        
+
         # Reset options
         for key, value in kwargs.items():
             if key not in self:
@@ -155,7 +169,7 @@ class Options(sc.objdict):
                 if value in [None, 'default']:
                     value = self.orig_options[key]
                 self[key] = value
-                
+
                 # Handle special cases
                 if key == 'precision':
                     self.reset_precision()
@@ -174,7 +188,7 @@ class Options(sc.objdict):
 
             # Convert warnings to errors
             with ss.options.context(warnings='error'):
-                ss.Sim(location='not a location').initialize()
+                ss.Sim(location='not a location').init()
 
             # Use with_style(), not context(), for plotting options
             with ss.options.with_style(dpi=50):
@@ -199,7 +213,7 @@ class Options(sc.objdict):
             return self[key] != self.orig_options[key]
         else:
             return None
-    
+
     def set_precision(self):
         if self.precision == 32:
             dtypes.int = np.int32
diff --git a/starsim/sim.py b/starsim/sim.py
index a717f7a..125bb13 100644
--- a/starsim/sim.py
+++ b/starsim/sim.py
@@ -1,101 +1,159 @@
 """
 Define core Sim classes
 """
-
-# Imports
 import itertools
 import numpy as np
 import sciris as sc
 import starsim as ss
-import matplotlib.pyplot as pl
+import matplotlib as mpl
+import matplotlib.pyplot as plt
 
 __all__ = ['Sim', 'AlreadyRunError', 'demo', 'diff_sims', 'check_sims_match']
 
 
-class Sim(sc.prettyobj):
+class Sim(ss.Base):
+    """
+    The Sim object
 
+    All Starsim simulations run via the Sim class. It is responsible for initializing
+    and running all modules and generating results.
+
+    Args:
+        pars (SimPars/dict): either an ss.SimPars object, or a nested dictionary; can include all other arguments
+        label (str): the human-readable name of the simulation
+        people (People): if provided, use this ss.People object
+        demographics (str/Demographics/list): a string naming the demographics module to use, the module itself, or a list
+        diseases (str/Disease/list): as above, for diseases
+        networks (str/Network/list): as above, for networks
+        interventions (str/Intervention/list): as above, for interventions
+        analyzers (str/Analyzer/list): as above, for analyzers
+        connectors (str/Connector/list): as above, for connectors
+        copy_inputs (bool): if True, copy modules as they're inserted into the sim (allowing reuse in other sims, but meaning they won't be updated)
+        data (df): a dataframe (or dict) of data, with a column "time" plus data of the form "module.result", e.g. "hiv.new_infections" (used for plotting only)
+        kwargs (dict): merged with pars; see ss.SimPars for all parameter values
+
+    **Examples**::
+
+        sim = ss.Sim(diseases='sir', networks='random') # Simplest Starsim sim; equivalent to ss.demo()
+        sim = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet()) # Equivalent using objects instead of strings
+        sim = ss.Sim(diseases=['sir', ss.SIS()], networks=['random', 'mf']) # Example using list inputs; can mix and match types
+    """
     def __init__(self, pars=None, label=None, people=None, demographics=None, diseases=None, networks=None,
-                 interventions=None, analyzers=None, connectors=None, copy_inputs=True, **kwargs):
-
-        # Make default parameters (using values from parameters.py)
-        self.pars = ss.make_pars() # Start with default pars
-        args = dict(label=label, people=people, demographics=demographics, diseases=diseases, networks=networks, 
+                 interventions=None, analyzers=None, connectors=None, copy_inputs=True, data=None, **kwargs):
+        self.pars = ss.make_pars() # Make default parameters (using values from parameters.py)
+        args = dict(label=label, people=people, demographics=demographics, diseases=diseases, networks=networks,
                     interventions=interventions, analyzers=analyzers, connectors=connectors)
         args = {key:val for key,val in args.items() if val is not None} # Remove None inputs
-        self.pars.update(sc.mergedicts(pars, args, kwargs, _copy=copy_inputs))  # Update the parameters
-        
-        # Set attributes
+        input_pars = sc.mergedicts(pars, args, kwargs, _copy=copy_inputs)
+        self.pars.update(input_pars)  # Update the parameters
+
+        # Set attributes; see also sim.init() for more
         self.label = label # Usually overwritten during initialization by the parameters
         self.created = sc.now()  # The datetime the sim was created
-        self.initialized = False  # Whether initialization is complete
-        self.complete = False  # Whether a simulation has completed running # TODO: replace with finalized?
-        self.results_ready = False  # Whether results are ready
+        self.version = ss.__version__ # The Starsim version
+        self.metadata = sc.metadata(version=self.version, pipfreeze=False)
         self.dists = ss.Dists(obj=self) # Initialize the random number generator container
+        self.loop = ss.Loop(self) # Initialize the integration loop
         self.results = ss.Results(module='sim')  # For storing results
+        self.data = data # For storing input data
+        self.initialized = False  # Whether initialization is complete
+        self.complete = False  # Whether a simulation has completed running
+        self.results_ready = False  # Whether results are ready
+        self.elapsed = None # The time required to run
         self.summary = None  # For storing a summary of the results
         self.filename = None # Store the filename, if saved
         return
-    
+
     def __getitem__(self, key):
         """ Allow dict-like access, e.g. sim['diseases'] """
         return getattr(self, key)
-    
+
     def __setitem__(self, key, value):
         """ Allow dict-like access, e.g. sim['created'] = sc.now() """
         return setattr(self, key, value)
-    
-    def initialize(self, **kwargs):
-        """ Perform all initializations for the sim; most heavy lifting is done by the parameters """
-        # Validation and initialization
+
+    def __repr__(self):
+        """ Show a quick version of the sim """
+        # Try a more custom repr first
+        try:
+            labelstr = f'{self.label}; ' if self.label else ''
+            n = int(self.pars.n_agents)
+            timestr = f'{self.pars.start}—{self.pars.stop}'
+
+            moddict = {}
+            for modkey in ss.module_map().keys():
+                if hasattr(self, modkey):
+                    thismodtype = self[modkey]
+                elif modkey in self.pars:
+                    thismodtype = self.pars[modkey]
+                else:
+                    thismodtype = {}
+
+                if isinstance(thismodtype, dict) and len(thismodtype):
+                    moddict[modkey] = sc.strjoin(thismodtype.keys())
+                elif isinstance(thismodtype, str):
+                    moddict[modkey] = thismodtype
+
+            if len(moddict):
+                modulestr = ''
+                for k,mstr in moddict.items():
+                    modulestr += f'; {k}={mstr}'
+            else:
+                modulestr = ''
+            if not self.initialized:
+                modulestr += '; not initialized'
+
+            string = f'Sim({labelstr}n={n:n}; {timestr}{modulestr})'
+
+        # Or just use default
+        except Exception as E:
+            ss.warn(f'Error displaying custom sim repr, falling back to default: {E}')
+            string = sc.prepr(self, vals=False)
+
+        return string
+
+    @property
+    def modules(self):
+        """ Return iterator over all Module instances (stored in standard places) in the Sim """
+        return itertools.chain(
+            self.demographics(),
+            self.networks(),
+            self.diseases(),
+            self.connectors(),
+            self.interventions(),
+            [intv.product for intv in self.interventions() if hasattr(intv, 'product') and intv.product is not None], # TODO: simplify
+            self.analyzers(),
+        )
+
+    def init(self, **kwargs):
+        """ Perform all initializations for the sim """
+
+        # Validation and initialization -- this is "pre"
         ss.set_seed(self.pars.rand_seed) # Reset the seed before the population is created -- shouldn't matter if only using Dist objects
-        
-        # Validate parameters
-        self.pars.validate()
+        self.pars.validate() # Validate parameters
+        self.init_time() # Initialize time
+        self.init_people(**kwargs) # Initialize the people
+        self.init_sim_attrs()
+        self.init_mods_pre()
 
-        # Initialize time
-        self.init_time_attrs()
-        
-        # Initialize the people
-        self.init_people(**kwargs)  # Create all the people
-        
-        # # Initialize the modules within the parameters
-        # self.pars.validate_modules(self)
-        
-        # Move initialized modules to the sim
-        keys = ['label', 'demographics', 'networks', 'diseases', 'interventions', 'analyzers', 'connectors']
-        for key in keys:
-            setattr(self, key, self.pars.pop(key))
-            
-        # Initialize all the modules with the sim
-        for mod in self.modules:
-            mod.init_pre(self)
-
-        # Initialize products # TODO: think about simplifying
-        for mod in self.interventions:
-            if hasattr(mod, 'product') and isinstance(mod.product, ss.Product):
-                mod.product.init_pre(self)
-        
-        # Initialize all distributions now that everything else is in place, then set states
-        self.dists.initialize(obj=self, base_seed=self.pars.rand_seed, force=True)
-        
-        # Initialize the values in all of the states and networks
-        self.init_vals()
-        
-        # Initialize the results
-        self.init_results()
+        # Final initializations -- this is "post"
+        self.init_dists() # Initialize distributions
+        self.init_people_vals() # Initialize the values in all the states and networks
+        self.init_mod_vals() # Initialize the module values
+        self.init_results() # Initialize the results
+        self.init_data() # Initialize the data
+        self.loop.init() # Initialize the integration loop
+        self.timer = sc.timer() # Store a timer for keeping track of how long the run takes
+        self.verbose = self.pars.verbose # Store a run-specific value of verbose
 
         # It's initialized
         self.initialized = True
         return self
-    
-    def init_time_attrs(self):
+
+    def init_time(self):
         """ Time indexing; derived values live in the sim rather than in the pars """
-        self.dt = self.pars.dt # Shortcut to dt since used a lot
-        self.yearvec = np.arange(start=self.pars.start, stop=self.pars.end + self.pars.dt, step=self.pars.dt) # The time points of the sim
-        self.results.yearvec = self.yearvec # Store the yearvec in the results for plotting
-        self.npts = len(self.yearvec) # The number of points in the sim
-        self.tivec = np.arange(self.npts) # The vector of time indices
-        self.ti = 0  # The time index, e.g. 0, 1, 2
+        self.t = ss.Time(pars=self.pars, name='sim', sim=True)
+        self.results.timevec = self.timevec # Store the timevec in the results for plotting
         return
 
     def init_people(self, verbose=None, **kwargs):
@@ -103,7 +161,7 @@ class Sim(sc.prettyobj):
         Initialize people within the sim
         Sometimes the people are provided, in which case this just adds a few sim properties to them.
         Other time people are not provided and this method makes them.
-        
+
         Args:
             verbose (int):  detail to print
             kwargs  (dict): passed to ss.make_people()
@@ -124,166 +182,135 @@ class Sim(sc.prettyobj):
         self.people = people
         self.people.link_sim(self)
         return self.people
-    
-    def init_vals(self):
-        """ Initialize the states and other objects with values """
-        
-        # Initialize values in people
+
+    def init_sim_attrs(self):
+        """ Move initialized modules to the sim """
+        keys = ['label', 'demographics', 'networks', 'diseases', 'interventions', 'analyzers', 'connectors']
+        for key in keys:
+            setattr(self, key, self.pars.pop(key))
+        return
+
+    def init_mods_pre(self):
+        """ Initialize all the modules with the sim """
+        for mod in self.modules:
+            mod.init_pre(self)
+        return
+
+    def init_dists(self):
+        """ Initialize the distributions """
+        # Initialize all distributions now that everything else is in place
+        self.dists.init(obj=self, base_seed=self.pars.rand_seed, force=True)
+
+        # Copy relevant dists to each module
+        for mod in self.modules:
+            self.dists.copy_to_module(mod)
+        return
+
+    def init_people_vals(self):
+        """ Initialize the People states with actual values """
         self.people.init_vals()
-        
-        # Initialize values in other modules, including networks
+        return
+
+    def init_mod_vals(self):
+        """ Initialize values in other modules, including networks and time parameters """
         for mod in self.modules:
             mod.init_post()
         return
-    
+
+    def reset_time_pars(self, force=True):
+        """ Reset the time parameters in the modules; used for imposing the sim's timestep on the modules """
+        for mod in self.modules:
+            mod.init_time_pars(force=force)
+        return
+
     def init_results(self):
         """ Create initial results that are present in all simulations """
-        self.results += [ # TODO: refactor with self.add_results()
-            ss.Result(None, 'n_alive',    self.npts, ss.dtypes.int, scale=True),
-            ss.Result(None, 'new_deaths', self.npts, ss.dtypes.int, scale=True),
-            ss.Result(None, 'cum_deaths', self.npts, ss.dtypes.int, scale=True),
+        kw = dict(shape=self.t.npts, timevec=self.t.timevec, dtype=int, scale=True)
+        self.results += [
+            ss.Result('n_alive',    label='Number alive', **kw),
+            ss.Result('new_deaths', label='Deaths', **kw),
+            ss.Result('cum_deaths', label='Cumulative deaths', **kw),
         ]
         return
 
-    @property
-    def modules(self):
-        # Return iterator over all Module instances (stored in standard places) in the Sim
-        products = [intv.product for intv in self.interventions.values() if
-                    hasattr(intv, 'product') and isinstance(intv.product, ss.Product)]
-        return itertools.chain(
-            self.demographics.values(),
-            self.networks.values(),
-            self.diseases.values(),
-            self.connectors.values(),
-            self.interventions.values(),
-            products,
-            self.analyzers.values(),
-        )
-    
-    @property
-    def year(self):
-        return self.yearvec[self.ti]
+    def init_data(self, data=None):
+        """ Initialize or add data to the sim """
+        data = data if data is not None else self.data
+        self.data = ss.validate_sim_data(data)
+        return
 
-    def step(self):
-        """ Step through time and update values """
+    def start_step(self):
+        """ Start the step -- only print progress; all actual changes happen in the modules """
 
         # Set the time and if we have reached the end of the simulation, then do nothing
         if self.complete:
-            raise AlreadyRunError('Simulation already complete (call sim.initialize() to re-run)')
-
-        # Advance random number generators forward to prepare for any random number calls that may be necessary on this step
-        self.dists.jump(to=self.ti+1)  # +1 offset because ti=0 is used on initialization
-
-        # Update demographic modules (create new agents from births/immigration, schedule non-disease deaths and emigration)
-        for dem_mod in self.demographics():
-            dem_mod.update()
-
-        # Carry out autonomous state changes in the disease modules. This allows autonomous state changes/initializations
-        # to be applied to newly created agents
-        for disease in self.diseases():
-            disease.update_pre()
-
-        # Update connectors -- TBC where this appears in the ordering
-        for connector in self.connectors():
-            connector.update()
-
-        # Update networks - this takes place here in case autonomous state changes at this timestep affect eligibility for contacts
-        for network in self.networks():
-            network.update()
-
-        # Apply interventions - new changes to contacts will be visible and so the final networks can be customized by
-        # interventions, by running them at this point
-        for intervention in self.interventions():
-            intervention(self)
-
-        # Carry out transmission/new cases
-        for disease in self.diseases():
-            disease.make_new_cases()
-
-        # Execute deaths that took place this timestep (i.e., changing the `alive` state of the agents). This is executed
-        # before analyzers have run so that analyzers are able to inspect and record outcomes for agents that died this timestep
-        uids = self.people.resolve_deaths()
-        for disease in self.diseases():
-            disease.update_death(uids)
-
-        # Update results
-        self.people.update_results()
-
-        for dem_mod in self.demographics():
-            dem_mod.update_results()
-
-        for disease in self.diseases():
-            disease.update_results()
+            errormsg = 'Simulation already complete (call sim.init() to re-run)'
+            raise AlreadyRunError(errormsg)
+
+        # Print out progress if needed
+        self.elapsed = self.timer.toc(output=True)
+        if self.verbose: # Print progress
+            t = self.t
+            simlabel = f'"{self.label}": ' if self.label else ''
+            string = f'  Running {simlabel}{t.now("str")} ({t.ti:2.0f}/{t.npts}) ({self.elapsed:0.2f} s) '
+            if self.verbose >= 1:
+                sc.heading(string)
+            elif self.verbose > 0:
+                if not (t.ti % int(1.0 / self.verbose)):
+                    sc.progressbar(t.ti + 1, t.npts, label=string, length=20, newline=True)
+        return
 
-        for analyzer in self.analyzers():
-            analyzer(self)
-            
-        # Clean up dead agents
-        self.people.remove_dead()
+    def finish_step(self):
+        """ Finish the simulation timestep """
+        self.t.ti += 1
+        return
 
-        # Tidy up
-        self.ti += 1
-        self.people.ti = self.ti
-        self.people.update_post()
+    def run_one_step(self, verbose=None):
+        """
+        Run a single sim step; only used for debugging purposes.
 
-        if self.ti == self.npts:
-            self.complete = True
+        Note: sim.run_one_step() runs a single simulation timestep, which involves
+        multiple function calls. In contrast, loop.run_one_step() runs a single
+        function call.
 
-        return
+        Note: the verbose here is only for the Loop object, not the sim.
+        """
+        self.loop.run(self.t.now(), verbose)
+        return self
 
     def run(self, until=None, verbose=None):
         """ Run the model once """
 
         # Initialization steps
-        T = sc.timer()
-        if not self.initialized:
-            self.initialize()
-            self._orig_pars = sc.dcp(self.pars)  # Create a copy of the parameters to restore after the run
-
-        if verbose is None:
-            verbose = self.pars.verbose
+        if not self.initialized: self.init()
+        self.verbose = sc.ifelse(verbose, self.pars.verbose)
+        self.timer.start()
 
         # Check for AlreadyRun errors
         errormsg = None
-        if until is None: until = self.npts
-        if until > self.npts:
-            errormsg = f'Requested to run until t={until} but the simulation end is ti={self.npts}'
-        if self.ti >= until:  # NB. At the start, self.t is None so this check must occur after initialization
-            errormsg = f'Simulation is currently at t={self.ti}, requested to run until ti={until} which has already been reached'
         if self.complete:
-            errormsg = 'Simulation is already complete (call sim.initialize() to re-run)'
+            errormsg = 'Simulation is already complete (call sim.init() to re-run)'
         if errormsg:
             raise AlreadyRunError(errormsg)
 
-        # Main simulation loop
-        while self.ti < until:
+        # Main simulation loop -- just one line!!!
+        self.loop.run(until)
 
-            # Check if we were asked to stop
-            elapsed = T.toc(output=True)
-
-            # Print progress
-            if verbose:
-                simlabel = f'"{self.label}": ' if self.label else ''
-                string = f'  Running {simlabel}{self.yearvec[self.ti]:0.1f} ({self.ti:2.0f}/{self.npts}) ({elapsed:0.2f} s) '
-                if verbose >= 2:
-                    sc.heading(string)
-                elif verbose > 0:
-                    if not (self.ti % int(1.0 / verbose)):
-                        sc.progressbar(self.ti + 1, self.npts, label=string, length=20, newline=True)
-
-            # Actually run the model
-            self.step()
+        # Check if the simulation is complete
+        if self.loop.index == len(self.loop.plan):
+            self.complete = True
 
         # If simulation reached the end, finalize the results
         if self.complete:
-            self.finalize(verbose=verbose)
-            sc.printv(f'Run finished after {elapsed:0.2f} s.\n', 1, verbose)
+            self.t.ti -= 1  # During the run, this keeps track of the next step; restore this be the final day of the sim
+            for mod in self.modules: # May not be needed, but keeps it consistent with the sim
+                mod.t.ti -= 1
+            self.finalize()
+            sc.printv(f'Run finished after {self.elapsed:0.2f} s.\n', 1, self.verbose)
+        return self # Allows e.g. ss.Sim().run().plot()
 
-        return self
-
-    def finalize(self, verbose=None):
+    def finalize(self):
         """ Compute final results """
-
         if self.results_ready:
             # Because the results are rescaled in-place, finalizing the sim cannot be run more than once or
             # otherwise the scale factor will be applied multiple times
@@ -291,31 +318,30 @@ class Sim(sc.prettyobj):
 
         # Scale the results
         for reskey, res in self.results.items():
-            if isinstance(res, ss.Result) and res.scale:
+            if isinstance(res, ss.Result) and res.scale: # NB: disease-specific results are scaled in module.finalize() below
                 self.results[reskey] = self.results[reskey] * self.pars.pop_scale
+        self.results_ready = True # Results are ready to use
 
+        # Finalize each module
         for module in self.modules:
             module.finalize()
 
-        self.summarize()
-        self.results_ready = True  # Set this first so self.summary() knows to print the results
-        self.ti -= 1  # During the run, this keeps track of the next step; restore this be the final day of the sim
+        # Generate the summary and finish up
+        self.summarize() # Create summary
         return
 
     def summarize(self, how='default'):
         """
-        Provide a quick summary of the sim
-        
+        Provide a quick summary of the sim; returns the last entry for count and
+        cumulative results, and the mean otherwise.
+
         Args:
             how (str): how to summarize: can be 'mean', 'median', 'last', or a mapping of result keys to those
-        
-        Returns the last entry for count and cumulative results, and the mean otherwise
         """
-        
         def get_func(key, how, default='mean'):
             """
             Find the right function by matching the "how" key with the result key
-            
+
             For example, hkey="cum_ " will match result key "cum_infections"
             """
             func = None
@@ -326,7 +352,7 @@ class Sim(sc.prettyobj):
             if func is None:
                 func = default
             return func
-            
+
         def get_result(res, func):
             """ Convert a string to the actual function to use, e.g. "median" maps to np.median() """
             if   func == 'mean':   return res.mean()
@@ -334,30 +360,27 @@ class Sim(sc.prettyobj):
             elif func == 'last':   return res[-1]
             elif callable(func):   return func(res)
             else: raise Exception(f'"{func}" is not a valid function')
-        
+
         # Convert "how" from a string to a dict
         if how == 'default':
-            how = {'n_':'mean', 'new_':'mean', 'cum_':'last', '':'mean'}
+            how = {'n_':'mean', 'new_':'mean', 'cum_':'last', 'timevec':'last', '':'mean'}
         elif isinstance(how, str):
             how = {'':how} # Match everything
-        
+
         summary = sc.objdict()
         flat = sc.flattendict(self.results, sep='_')
         for key, res in flat.items():
-            try:
-                func = get_func(key, how)
-                entry = get_result(res, func)
-            except Exception as E:
-                entry = f'N/A {E}'
-            summary[key] = entry
+            if 'timevec' not in key: # Skip module-specific time vectors
+                try:
+                    func = get_func(key, how)
+                    entry = get_result(res, func)
+                except Exception as E:
+                    entry = f'N/A {E}'
+                summary[key] = entry
         self.summary = summary
         return summary
-    
-    def disp(self):
-        print(self.summary)
-        return
-    
-    def shrink(self, skip_attrs=None, in_place=True):
+
+    def shrink(self, inplace=True, size_limit=1.0):
         """
         "Shrinks" the simulation by removing the people and other memory-intensive
         attributes (e.g., some interventions and analyzers), and returns a copy of
@@ -365,151 +388,82 @@ class Sim(sc.prettyobj):
         for saved files.
 
         Args:
-            skip_attrs (list): a list of attributes to skip (remove) in order to perform the shrinking; default "people"
-            in_place (bool): whether to perform the shrinking in place (default), or return a shrunken copy instead
+            inplace (bool): whether to perform the shrinking in place (default), or return a shrunken copy instead
+            size_limit (float): print a warning if any module is larger than this size limit (set to None to disable)
 
         Returns:
             shrunken (Sim): a Sim object with the listed attributes removed
         """
-        # By default, skip people (~90% of memory), popdict, and _orig_pars (which is just a backup)
-        if skip_attrs is None:
-            skip_attrs = ['people']
-
         # Create the new object, and copy original dict, skipping the skipped attributes
-        if in_place:
-            shrunken = self
-            for attr in skip_attrs:
-                setattr(self, attr, None)
+        if inplace:
+            sim = self
         else:
-            shrunken = object.__new__(self.__class__)
-            shrunken.__dict__ = {k: (v if k not in skip_attrs else None) for k, v in self.__dict__.items()}
-
-        # Don't return if in place
-        if in_place:
-            return
-        else:
-            return shrunken
-
-    def _get_ia(self, which, label=None, partial=False, as_list=False, as_inds=False, die=True, first=False):
-        """ Helper method for get_interventions() and get_analyzers(); see get_interventions() docstring """
-
-        # Handle inputs
-        if which not in ['interventions', 'analyzers']:  # pragma: no cover
-            errormsg = f'This method is only defined for interventions and analyzers, not "{which}"'
-            raise ValueError(errormsg)
-
-        ia_ndict = self.analyzers if which == 'analyzers' else self.interventions  # List of interventions or analyzers
-        n_ia = len(ia_ndict)  # Number of interventions/analyzers
-
-        position = 0 if first else -1  # Choose either the first or last element
-        if label is None:  # Get all interventions if no label is supplied, e.g. sim.get_interventions()
-            label = np.arange(n_ia)
-        if isinstance(label, np.ndarray):  # Allow arrays to be provided
-            label = label.tolist()
-        labels = sc.promotetolist(label)
-
-        # Calculate the matches
-        matches = []
-        match_inds = []
-
-        for label in labels:
-            if sc.isnumber(label):
-                matches.append(ia_ndict[label])
-                label = n_ia + label if label < 0 else label  # Convert to a positive number
-                match_inds.append(label)
-            elif sc.isstring(label) or isinstance(label, type):
-                for ind, ia_key, ia_obj in ia_ndict.enumitems():
-                    if sc.isstring(label) and ia_obj.label == label or (partial and (label in str(ia_obj.label))):
-                        matches.append(ia_obj)
-                        match_inds.append(ind)
-                    elif isinstance(label, type) and isinstance(ia_obj, label):
-                        matches.append(ia_obj)
-                        match_inds.append(ind)
-            else:  # pragma: no cover
-                errormsg = f'Could not interpret label type "{type(label)}": should be str, int, list, or {which} class'
-                raise TypeError(errormsg)
-
-        # Parse the output options
-        if as_inds:
-            output = match_inds
-        elif as_list:  # Used by get_interventions()
-            output = matches
-        else:
-            if len(matches) == 0:  # pragma: no cover
-                if die:
-                    errormsg = f'No {which} matching "{label}" were found'
-                    raise ValueError(errormsg)
-                else:
-                    output = None
-            else:
-                output = matches[
-                    position]  # Return either the first or last match (usually), used by get_intervention()
-
-        return output
-
-    def get_interventions(self, label=None, partial=False, as_inds=False):
-        """
-        Find the matching intervention(s) by label, index, or type. If None, return
-        all interventions. If the label provided is "summary", then print a summary
-        of the interventions (index, label, type).
-
-        Args:
-            label (str, int, Intervention, list): the label, index, or type of intervention to get; if a list, iterate over one of those types
-            partial (bool): if true, return partial matches (e.g. 'beta' will match all beta interventions)
-            as_inds (bool): if true, return matching indices instead of the actual interventions
-        """
-        return self._get_ia('interventions', label=label, partial=partial, as_inds=as_inds, as_list=True)
-
-    def get_intervention(self, label=None, partial=False, first=False, die=True):
-        """
-        Find the matching intervention(s) by label, index, or type.
-        If more than one intervention matches, return the last by default.
-        If no label is provided, return the last intervention in the list.
-
-        Args:
-            label (str, int, Intervention, list): the label, index, or type of intervention to get; if a list, iterate over one of those types
-            partial (bool): if true, return partial matches
-            first (bool): if true, return first matching intervention (otherwise, return last)
-            die (bool): whether to raise an exception if no intervention is found
-        """
-        return self._get_ia('interventions', label=label, partial=partial, first=first, die=die, as_inds=False,
-                            as_list=False)
-
-    def export_df(self):
-        """
-        Export results as a Pandas dataframe
-
-        :return:
-
-        """
-
+            sim = self.copy() # We need to do a deep copy to avoid modifying other objects
+
+        # Shrink the people and loop
+        shrunk = ss.utils.shrink()
+        sim.people = shrunk
+        with sc.tryexcept():
+            sim.loop.funcs = shrunk
+            sim.loop.plan = shrunk
+
+        # Shrink the networks
+        for network in sim.networks():
+            with sc.tryexcept():
+                network.edges = shrunk
+                network.participant = shrunk
+
+        # Shrink the distributions
+        for dist in sim.dists.dists.values():
+            with sc.tryexcept():
+                dist.slots = shrunk
+                dist._slots = shrunk
+                dist.module = shrunk
+                dist._n = shrunk
+                dist._uids = shrunk
+                dist.history = shrunk
+
+        # Finally, shrink the modules
+        for mod in sim.modules:
+            mod.sim = shrunk
+            for state in mod.states:
+                with sc.tryexcept():
+                    state.people = shrunk
+                    state.raw = shrunk
+
+            # Check that the module successfully shrunk
+        if size_limit:
+            for mod in sim.modules:
+                size = sc.checkmem(mod, descend=0).bytesize[0]/1e6
+                if size > size_limit:
+                    warnmsg = f'Module {mod.name} did not successfully shrink: {size:0.1f} MB > {size_limit:0.1f} MB'
+                    ss.warn(warnmsg)
+
+        # Finally, set a flag that the sim has been shrunken
+        sim.shrunken = True
+        return sim
+
+    def check_results_ready(self, errormsg=None):
+        """ Check that results are ready """
+        if errormsg is None:
+            errormsg = 'Please run the sim first'
         if not self.results_ready:  # pragma: no cover
-            errormsg = 'Please run the sim before exporting the results'
             raise RuntimeError(errormsg)
+        return
 
-        def flatten_results(d, prefix=''):
-            flat = {}
-            for key, val in d.items():
-                if isinstance(val, dict):
-                    flat.update(flatten_results(val, prefix=prefix+key+'.'))
-                else:
-                    flat[prefix+key] = val
-            return flat
-
-        resdict = flatten_results(self.results)
-        resdict['t'] = self.yearvec
-
-        df = sc.dataframe.from_dict(resdict).set_index('t')
+    def to_df(self, sep='_'):
+        """ Export results as a Pandas dataframe """
+        self.check_results_ready('Please run the sim before exporting the results')
+        df = self.results.to_df(sep=sep, descend=True)
         return df
 
-    def save(self, filename=None, keep_people=None, skip_attrs=None, **kwargs):
+    def save(self, filename=None, shrink=None, **kwargs):
         """
         Save to disk as a gzipped pickle.
 
         Args:
             filename (str or None): the name or path of the file to save to; if None, uses stored
-            keep_people (bool or None): whether to keep the people
-            skip_attrs (list): attributes to skip saving
+            shrink (bool or None): whether to shrink the sim prior to saving (reduces size by ~99%)
             kwargs: passed to sc.makefilepath()
 
         Returns:
@@ -519,13 +473,9 @@ class Sim(sc.prettyobj):
 
             sim.save() # Saves to a .sim file
         """
-
-        # Set keep_people based on whether we're in the middle of a run
-        if keep_people is None:
-            if self.initialized and not self.results_ready:
-                keep_people = True
-            else:
-                keep_people = False
+        # Set shrink based on whether we're in the middle of a run
+        if shrink is None:
+            shrink = False if self.initialized and not self.results_ready else True
 
         # Handle the filename
         if filename is None:
@@ -534,160 +484,189 @@ class Sim(sc.prettyobj):
         self.filename = filename  # Store the actual saved filename
 
         # Handle the shrinkage and save
-        if skip_attrs or not keep_people:
-            obj = self.shrink(skip_attrs=skip_attrs, in_place=False)
-        else:
-            obj = self
-        sc.save(filename=filename, obj=obj)
-
+        sim = self.shrink(inplace=False) if shrink else self
+        sc.save(filename=filename, obj=sim)
         return filename
 
     @staticmethod
     def load(filename, *args, **kwargs):
-        """ Load from disk from a gzipped pickle.  """
-
+        """ Load from disk from a gzipped pickle """
         sim = sc.load(filename, *args, **kwargs)
         if not isinstance(sim, Sim):  # pragma: no cover
             errormsg = f'Cannot load object of {type(sim)} as a Sim object'
             raise TypeError(errormsg)
         return sim
 
-    def export_pars(self, filename=None, indent=2, *args, **kwargs):
-        '''
-        Return parameters for JSON export -- see also to_json().
-
-        This method is required so that interventions can specify
-        their JSON-friendly representation.
-
-        Args:
-            filename (str): filename to save to; if None, do not save
-            indent (int): indent (int): if writing to file, how many indents to use per nested level
-            args (list): passed to savejson()
-            kwargs (dict): passed to savejson()
-
-        Returns:
-            pardict (dict): a dictionary containing all the parameter values
-        '''
-        pardict = {}
-        for key,item in self.pars.items():
-            if key in ss.module_map().keys():
-                if np.iterable(item):
-                    item = [mod.to_json() for mod in item]
-                else:
-                    try:
-                        item = item.to_json()
-                    except:
-                        pass
-            elif key == 'people':
-                continue
-            pardict[key] = item
-        if filename is not None:
-            sc.savejson(filename=filename, obj=pardict, indent=indent, *args, **kwargs)
-        return pardict
-
-    def to_json(self, filename=None, keys=None, tostring=False, indent=2, verbose=False, *args, **kwargs):
-        '''
+    def to_json(self, filename=None, keys=None, tostring=False, indent=2, verbose=False, **kwargs):
+        """
         Export results and parameters as JSON.
 
         Args:
             filename (str): if None, return string; else, write to file
-            keys (str or list): attributes to write to json (default: results, parameters, and summary)
-            tostring (bool): if not writing to file, whether to write to string (alternative is sanitized dictionary)
-            indent (int): if writing to file, how many indents to use per nested level
+            keys (str/list): attributes to write to json (choices: 'pars' and/or 'summary')
             verbose (bool): detail to print
-            args (list): passed to savejson()
-            kwargs (dict): passed to savejson()
+            kwargs (dict): passed to sc.jsonify()
 
         Returns:
-            A unicode string containing a JSON representation of the results,
-            or writes the JSON file to disk
+            A dictionary representation of the parameters and/or summary results
+            (or write that dictionary to a file)
 
         **Examples**::
 
             json = sim.to_json()
             sim.to_json('results.json')
             sim.to_json('summary.json', keys='summary')
-        '''
-
+        """
         # Handle keys
         if keys is None:
-            keys = ['results', 'pars', 'summary', 'short_summary']
+            keys = ['pars', 'summary']
         keys = sc.promotetolist(keys)
 
         # Convert to JSON-compatible format
-        d = {}
+        d = sc.objdict()
         for key in keys:
-            if key == 'results':
-                if self.results_ready:
-                    resdict = self.export_results(for_json=True)
-                    d['results'] = resdict
-                else:
-                    d['results'] = 'Results not available (Sim has not yet been run)'
-            elif key in ['pars', 'parameters']:
-                pardict = self.export_pars()
-                d['parameters'] = pardict
+            if key in ['pars', 'parameters']:
+                pardict = self.pars.to_json()
+                d.pars = pardict
             elif key == 'summary':
                 if self.results_ready:
-                    d['summary'] = dict(sc.dcp(self.summary))
+                    d.summary = dict(sc.dcp(self.summary))
                 else:
-                    d['summary'] = 'Summary not available (Sim has not yet been run)'
-            elif key == 'short_summary':
-                if self.results_ready:
-                    d['short_summary'] = dict(sc.dcp(self.short_summary))
-                else:
-                    d['short_summary'] = 'Full summary not available (Sim has not yet been run)'
+                    d.summary = 'Summary not available (Sim has not yet been run)'
             else:  # pragma: no cover
-                try:
-                    d[key] = sc.sanitizejson(getattr(self, key))
-                except Exception as E:
-                    errormsg = f'Could not convert "{key}" to JSON: {str(E)}; continuing...'
-                    print(errormsg)
-
-        if filename is None:
-            output = sc.jsonify(d, tostring=tostring, indent=indent, verbose=verbose, *args, **kwargs)
-        else:
-            output = sc.savejson(filename=filename, obj=d, indent=indent, *args, **kwargs)
-
-        return output
-
-    def plot(self, key=None):
-        with sc.options.with_style('fancy'):
-            flat = sc.flattendict(self.results, sep=': ')
-            yearvec = flat.pop('yearvec')
+                errormsg = f'Could not convert "{key}" to JSON; continuing...'
+                print(errormsg)
+
+        # Final conversion
+        if filename is not None:
+            sc.savejson(filename=filename, obj=d, **kwargs)
+        d = sc.jsonify(d)
+        return d
+
+    def plot(self, key=None, fig=None, style='fancy', show_data=True, show_skipped=False,
+             show_module=26, show_label=False, fig_kw=None, plot_kw=None, scatter_kw=None):
+        """
+        Plot all results in the Sim object
+
+        Args:
+            key (str/list): the results key to plot (by default, all); if a list, plot exactly those keys
+            fig (Figure): if provided, plot results into an existing figure
+            style (str): the plotting style to use (default "fancy"; other options are "simple", None, or any Matplotlib style)
+            show_data (bool): plot the data, if available
+            show_skipped (bool): show even results that are skipped by default
+            show_module (bool): whether to show the module as well as the result name; if an int, show if the label is less than that length; if -1, use a newline
+            show_label (str): if 'fig', reset the fignum; if 'title', set the figure suptitle
+            fig_kw (dict): passed to ``plt.subplots()``
+            plot_kw (dict): passed to ``plt.plot()``
+            scatter_kw (dict): passed to ``plt.scatter()``, for plotting the data
+        """
+        self.check_results_ready('Please run the sim before plotting')
+
+        # Configuration
+        flat = self.results.flatten()
+        if not show_skipped: # Skip plots with auto_plot set to False
+            for k in list(flat.keys()): # NB: can't call it "key", shadows argument
+                res = flat[k]
+                if isinstance(res, ss.Result) and not res.auto_plot:
+                    flat.pop(k)
+
+        # Set figure defaults
+        n_cols = np.ceil(np.sqrt(len(flat))) # Number of columns of axes
+        default_figsize = np.array([8, 6])
+        figsize_factor = np.clip((n_cols-3)/6+1, 1, 1.5) # Scale the default figure size based on the number of rows and columns
+        figsize = default_figsize*figsize_factor
+        if show_module is True: # Set no limit for the label length
+            show_module = 999
+
+        # Set plotting defaults
+        fig_kw     = sc.mergedicts(dict(figsize=figsize), fig_kw)
+        plot_kw    = sc.mergedicts(dict(lw=2), plot_kw)
+        scatter_kw = sc.mergedicts(dict(alpha=0.3, color='k'), scatter_kw)
+
+        # Do the plotting
+        with sc.options.with_style(style):
+
             if key is not None:
-                flat = {k:v for k,v in flat.items() if k.startswith(key)}
-            fig, axs = sc.getrowscols(len(flat), make=True)
-            for ax, (k, v) in zip(axs.flatten(), flat.items()):
-                ax.plot(yearvec, v)
-                ax.set_title(k)
-                ax.set_xlabel('Year')
-        return fig
+                if isinstance(key, str):
+                    flat = {k:v for k,v in flat.items() if (key in k)}
+                else:
+                    flat = {k:flat[k] for k in key}
+
+            # Get the figure
+            if fig is None:
+                if show_label in ['fig', 'fignum'] and self.label:
+                    plotlabel = self.label
+                    figlist = sc.autolist()
+                    while plt.fignum_exists(plotlabel):
+                        figlist += plotlabel
+                        plotlabel = sc.uniquename(self.label, figlist, human=True)
+                    fig_kw['num'] = plotlabel
+                fig, axs = sc.getrowscols(len(flat), make=True, **fig_kw)
+                if isinstance(axs, np.ndarray):
+                    axs = axs.flatten()
+            else:
+                axs = fig.axes
+            if not sc.isiterable(axs):
+                axs = [axs]
+
+            # Do the plotting
+            df = self.data if show_data else None # For plotting the data
+            for ax, (key, res) in zip(axs, flat.items()):
+
+                # Plot data
+                if df is not None:
+                    mod = res.module
+                    name = res.name
+                    found = False
+                    for dfkey in [f'{mod}.{name}', f'{mod}_{name}']: # Allow dot or underscore
+                        if dfkey in df.cols:
+                            found = True
+                            break
+                    if found:
+                        ax.scatter(df.index.values, df[dfkey].values, **scatter_kw)
+
+                # Plot results
+                ax.plot(res.timevec, res.values, **plot_kw, label=self.label)
+                if show_module == -1:
+                    label = res.full_label.replace(':', '\n')
+                elif len(res.full_label) > show_module:
+                    label = res.label
+                else:
+                    label = res.full_label
+
+                ax.set_title(label)
+                sc.commaticks(ax)
+                if res.has_dates:
+                    locator = mpl.dates.AutoDateLocator(minticks=2, maxticks=5) # Fewer ticks since lots of plots
+                    sc.dateformatter(ax, locator=locator)
+
+        if show_label in ['title', 'suptitle'] and self.label:
+            fig.suptitle(self.label, weight='bold')
+
+        sc.figlayout(fig=fig)
+
+        return ss.return_fig(fig)
 
 
 class AlreadyRunError(RuntimeError):
-    """
-    This error is raised if a simulation is run in such a way that no timesteps
-    will be taken. This error is a distinct type so that it can be safely caught
-    and ignored if required, but it is anticipated that most of the time, calling
-    :py:func:`Sim.run` and not taking any timesteps, would be an inadvertent error.
-    """
+    """ Raised if trying to re-run an already-run sim without re-initializing """
     pass
 
 
 def demo(run=True, plot=True, summary=True, show=True, **kwargs):
     """
     Create a simple demo simulation for Starsim
-    
+
     Defaults to using the SIR model with a random network, but these can be configured.
-    
+
     Args:
         run (bool): whether to run the sim
         plot (bool): whether to plot the results
         summary (bool): whether to print a summary of the results
         kwargs (dict): passed to ``ss.Sim()``
-    
+
     **Examples**::
-        
+
         ss.demo() # Run, plot, and show results
         ss.demo(diseases='hiv', networks='mf') # Run with different defaults
     """
@@ -702,7 +681,7 @@ def demo(run=True, plot=True, summary=True, show=True, **kwargs):
             if plot:
                 sim.plot()
                 if show:
-                    pl.show()
+                    plt.show()
     return sim
 
 
@@ -712,8 +691,8 @@ def diff_sims(sim1, sim2, skip_key_diffs=False, skip=None, full=False, output=Fa
     values which differ.
 
     Args:
-        sim1 (sim/dict): either a simulation object or the sim.summary dictionary
-        sim2 (sim/dict): ditto
+        sim1 (Sim/MultiSim/dict): either a simulation/MultiSim object or the sim.summary dictionary
+        sim2 (im/dict): ditto
         skip_key_diffs (bool): whether to skip keys that don't match between sims
         skip (list): a list of values to skip
         full (bool): whether to print out all values (not just those that differ)
@@ -728,15 +707,25 @@ def diff_sims(sim1, sim2, skip_key_diffs=False, skip=None, full=False, output=Fa
         ss.diff_sims(s1, s2)
     '''
 
-    if isinstance(sim1, Sim):
+    # Convert to dict
+    if isinstance(sim1, (Sim, ss.MultiSim)):
         sim1 = sim1.summarize()
-    if isinstance(sim2, Sim):
+    if isinstance(sim2, (Sim, ss.MultiSim)):
         sim2 = sim2.summarize()
     for sim in [sim1, sim2]:
         if not isinstance(sim, dict):  # pragma: no cover
             errormsg = f'Cannot compare object of type {type(sim)}, must be a sim or a sim.summary dict'
             raise TypeError(errormsg)
 
+
+    # Check if it's a multisim
+    sim1 = sc.objdict(sim1)
+    sim2 = sc.objdict(sim2)
+    multi = isinstance(sim1[0], dict) # If it's a dict, then it's a multisim
+    if multi:
+        for sim in [sim1, sim2]:
+            assert 'mean' in sim[0], f"Can only compare multisims with summarize(method='mean'), but you have keys {sim[0].keys()}"
+
     # Compare keys
     keymatchmsg = ''
     sim1_keys = set(sim1.keys())
@@ -746,7 +735,7 @@ def diff_sims(sim1, sim2, skip_key_diffs=False, skip=None, full=False, output=Fa
         missing = list(sim1_keys - sim2_keys)
         extra = list(sim2_keys - sim1_keys)
         if missing:
-            keymatchmsg += f'  Missing sim1 keys: {missing}\ns'
+            keymatchmsg += f'  Missing sim1 keys: {missing}\n'
         if extra:
             keymatchmsg += f'  Extra sim2 keys: {extra}\n'
 
@@ -757,68 +746,88 @@ def diff_sims(sim1, sim2, skip_key_diffs=False, skip=None, full=False, output=Fa
     skip = sc.tolist(skip)
     for key in sim2.keys():  # To ensure order
         if key in sim1_keys and key not in skip:  # If a key is missing, don't count it as a mismatch
-            sim1_val = sim1[key] if key in sim1 else 'not present'
-            sim2_val = sim2[key] if key in sim2 else 'not present'
-            mm = not np.isclose(sim1_val, sim2_val, equal_nan=True)
+            d = sc.objdict()
+            if multi:
+                d.sim1 = sim1[key]['mean']
+                d.sim2 = sim2[key]['mean']
+                d.sim1_sem = sim1[key]['sem']
+                d.sim2_sem = sim2[key]['sem']
+            else:
+                d.sim1 = sim1[key]
+                d.sim2 = sim2[key]
+            mm = not np.isclose(d.sim1, d.sim2, equal_nan=True)
             n_mismatch += mm
             if mm or full:
-                mismatches[key] = {'sim1': sim1_val, 'sim2': sim2_val}
+                mismatches[key] = d
 
+    df = sc.dataframe() # Preallocate in case there were no mismatches
     if len(mismatches):
         valmatchmsg = '\nThe following values differ between the two simulations:\n' if not full else ''
         df = sc.dataframe.from_dict(mismatches).transpose()
         diff = []
         ratio = []
         change = []
-        small_change = 1e-3  # Define a small change, e.g. a rounding error
-        for mdict in mismatches.values():
-            old = mdict['sim1']
-            new = mdict['sim2']
-            numeric = sc.isnumber(sim1_val) and sc.isnumber(sim2_val)
+        zscore = []
+        small_change = 1 + 1e-3  # Define a small change, e.g. a rounding error
+        for d in mismatches.values():
+            old = d.sim1
+            new = d.sim2
+            if multi:
+                old_sem = d.sim1_sem
+                new_sem = d.sim1_sem
+                sem = old_sem + new_sem
+                small_change = 1.96 # 95% CI, roughly speaking
+
+            numeric = sc.isnumber(old) and sc.isnumber(new) # Should all be numeric, but just in case
             if numeric and old > 0:
                 this_diff = new - old
                 this_ratio = new / old
-                abs_ratio = max(this_ratio, 1.0 / this_ratio)
+                if multi:
+                    abs_ratio = abs(this_diff)/sem
+                    this_zscore = abs_ratio
+                else:
+                    abs_ratio = max(this_ratio, 1.0/this_ratio)
+                    this_zscore = np.nan
 
                 # Set the character to use
-                if abs_ratio < small_change:
-                    change_char = '≈'
-                elif new > old:
-                    change_char = '↑'
-                elif new < old:
-                    change_char = '↓'
-                elif new == old:
-                    change_char = '='
+                approx_eq = abs_ratio < small_change
+                if approx_eq:    change_char = '≈'
+                elif new > old:  change_char = '↑'
+                elif new < old:  change_char = '↓'
+                elif new == old: change_char = '='
                 else:
                     errormsg = f'Could not determine relationship between sim1={old} and sim2={new}'
                     raise ValueError(errormsg)
 
                 # Set how many repeats it should have
                 repeats = 1
-                if abs_ratio == 0:
-                    repeats = 0
-                if abs_ratio >= 1.1:
-                    repeats = 2
-                if abs_ratio >= 2:
-                    repeats = 3
-                if abs_ratio >= 10:
-                    repeats = 4
-
+                if abs_ratio == 0:   repeats = 0
+                if abs_ratio >= 1.1: repeats = 2
+                if abs_ratio >= 2:   repeats = 3
+                if abs_ratio >= 10:  repeats = 4
                 this_change = change_char * repeats
             else:  # pragma: no cover
-                this_diff = np.nan
-                this_ratio = np.nan
+                this_diff =  np.nan
+                this_ratio  = np.nan
                 this_change = 'N/A'
+                this_zscore = np.nan
 
             diff.append(this_diff)
             ratio.append(this_ratio)
             change.append(this_change)
+            zscore.append(this_zscore)
 
         df['diff'] = diff
         df['ratio'] = ratio
-        for col in ['sim1', 'sim2', 'diff', 'ratio']:
+        numeric_cols = ['sim1', 'sim2', 'diff', 'ratio']
+        if multi:
+            numeric_cols += ['sim1_sem', 'sim2_sem']
+        for col in numeric_cols:
             df[col] = df[col].round(decimals=3)
         df['change'] = change
+        if multi:
+            df['zscore'] = zscore
+            df['statsig'] = df.zscore > small_change
         valmatchmsg += str(df)
 
     # Raise an error if mismatches were found
@@ -838,14 +847,30 @@ def diff_sims(sim1, sim2, skip_key_diffs=False, skip=None, full=False, output=Fa
 
 
 def check_sims_match(*args, full=False):
-    """ Shortcut to using ss.diff_sims() to check if multiple sims match """
-    s1 = args[0]
+    """
+    Shortcut to using ss.diff_sims() to check if multiple sims match
+
+    Args:
+        args (list): a list of 2 or more sims to compare
+        full (bool): if True, return whether each sim matches the first
+
+    **Example**::
+
+        s1 = ss.Sim(diseases='sir', networks='random')
+        s2 = ss.Sim(pars=dict(diseases='sir', networks='random'))
+        s3 = ss.Sim(diseases=ss.SIR(), networks=ss.RandomNet())
+        assert ss.check_sims_match(s1, s2, s3)
+    """
+    if len(args) < 2:
+        errormsg = 'Must compare at least 2 sims'
+        raise ValueError(errormsg)
+    base = args[0]
     matches = []
-    for s2 in args[1:]:
-        diff = diff_sims(s1, s2, full=False, output=False, die=False)
+    for other in args[1:]:
+        diff = diff_sims(base, other, full=False, output=False, die=False)
         matches.append(not(diff)) # Return the opposite of the diff
     if full:
         return matches
     else:
         return all(matches)
-        
+
diff --git a/starsim/states.py b/starsim/states.py
deleted file mode 100644
index 4c864ec..0000000
--- a/starsim/states.py
+++ /dev/null
@@ -1,379 +0,0 @@
-"""
-Define array-handling classes, including agent states
-"""
-
-import numpy as np
-import starsim as ss
-
-# Shorten these for performance
-ss_float = ss.dtypes.float
-ss_int   = ss.dtypes.int
-ss_bool  = ss.dtypes.bool
-
-__all__ = ['check_dtype', 'Arr', 'FloatArr', 'BoolArr', 'IndexArr', 'uids']
-
-
-def check_dtype(dtype, default=None):
-    """ Check that the supplied dtype is one of the supported options """
-    
-    # Handle dtype
-    if dtype is None:
-        if default is None:
-            errormsg = 'Must supply either a dtype or a default value'
-            raise ValueError(errormsg)
-        else:
-            dtype = type(default)
-    
-    if dtype in ['float', float, np.float64, np.float32]:
-        dtype = ss_float
-    elif dtype in ['int', int, np.int64, np.int32]:
-        dtype = ss_int
-    elif dtype in ['bool', bool, np.bool_]:
-        dtype = ss_bool
-    else:
-        warnmsg = f'Data type {type(default)} not a supported data type; set warn=False to suppress warning'
-        ss.warn(warnmsg)
-    
-    return dtype
-
-
-class Arr(np.lib.mixins.NDArrayOperatorsMixin):
-    """
-    Store a state of the agents (e.g. age, infection status, etc.) as an array.
-    
-    In practice, ``Arr`` objects can be used interchangeably with NumPy arrays.
-    They have two main data interfaces: ``Arr.raw`` contains the "raw", underlying
-    NumPy array of the data. ``Arr.values`` contains the "active" values, which
-    usually corresponds to agents who are alive.
-    
-    By default, operations are performed on active agents only (specified by ``Arr.auids``,
-    which is a pointer to ``sim.people.auids``). For example, ``sim.people.age.mean()``
-    will only use the ages of active agents. Thus, ``sim.people.age.mean()``
-    is equal to ``sim.people.age.values.mean()``, not ``sim.people.age.raw.mean()``.
-    
-    If indexing by an int or slice, ``Arr.values`` is used. If indexing by an
-    ``ss.uids`` object, ``Arr.raw`` is used. ``Arr`` objects can't be directly
-    indexed by a list or array of ints, as this would be ambiguous about whether
-    ``values`` or ``raw`` is intended. For example, if there are 1000 people in a 
-    simulation and 100 of them have died, ``sim.people.age[999]`` will return
-    an ``IndexError`` (since ``sim.people.age[899]`` is the last active agent),
-    whereas ``sim.people.age[ss.uids(999)]`` is valid.
-
-    Args: 
-        name (str): The name for the state (also used as the dictionary key, so should not have spaces etc.)
-        dtype (class): The dtype to use for this instance (if None, infer from value)
-        default (any): Specify default value for new agents. This can be
-        - A scalar with the same dtype (or castable to the same dtype) as the State
-        - A callable, with a single argument for the number of values to produce
-        - A ``ss.Dist`` instance
-        nan (any): the value to use to represent NaN (not a number); also used as the default value if not supplied
-        raw (arr): if supplied, the raw values to use
-        label (str): The human-readable name for the state
-        coerce (bool): Whether to ensure the the data is one of the supported data types
-        skip_init (bool): Whether to skip initialization with the People object (used for uid and slot states)
-    """
-    def __init__(self, name, dtype=None, default=None, nan=None, raw=None, label=None, coerce=True, skip_init=False):
-        if coerce:
-            dtype = check_dtype(dtype, default)
-        
-        # Set attributes
-        self.name = name
-        self.label = label or name
-        self.default = default
-        self.nan = nan
-        self.dtype = dtype
-        
-        # Properties that are initialized later
-        self.raw = np.empty(0, dtype=dtype)
-        self.people = None # Used solely for accessing people.auids
-        self.len_used = 0
-        self.len_tot = 0
-        self.initialized = skip_init
-        if raw is not None:
-            self.grow(new_uids=uids(np.arange(len(raw))), new_vals=raw)
-        return
-    
-    def __repr__(self):
-        arr_str = np.array2string(self.values, max_line_width=200)
-        string = f'<{self.__class__.__name__} "{str(self.name)}", len={len(self)}, {arr_str}>'
-        return string
-    
-    def __len__(self):
-        return len(self.auids)
-    
-    def _convert_key(self, key):
-        """
-        Used for getitem and setitem to determine whether the key is indexing
-        the raw array (``raw``) or the active agents (``values``), and to convert
-        the key to array indices if needed.
-        """
-        if isinstance(key, (uids, int)):
-            return key
-        elif isinstance(key, (BoolArr, IndexArr)):
-            return key.uids
-        elif isinstance(key, slice):
-            return self.auids[key]
-        elif not np.isscalar(key) and len(key) == 0: # Handle [], np.array([]), etc.
-            return uids()
-        else:
-            errormsg = f'Indexing an Arr ({self.name}) by ({key}) is ambiguous or not supported. Use ss.uids() instead, or index Arr.raw or Arr.values.'
-            raise Exception(errormsg)
-    
-    def __getitem__(self, key):
-        key = self._convert_key(key)
-        return self.raw[key]
-    
-    def __setitem__(self, key, value):
-        key = self._convert_key(key)
-        self.raw[key] = value
-        return
-            
-    def __getattr__(self, attr):
-        """ Make it behave like a regular array mostly -- enables things like sum(), mean(), etc. """
-        if attr in ['__deepcopy__', '__getstate__', '__setstate__']:
-            return self.__getattribute__(attr)
-        else:
-            return getattr(self.values, attr)
-        
-    def __gt__(self, other): return self.asnew(self.values > other,  cls=BoolArr)
-    def __lt__(self, other): return self.asnew(self.values < other,  cls=BoolArr)
-    def __ge__(self, other): return self.asnew(self.values >= other, cls=BoolArr)
-    def __le__(self, other): return self.asnew(self.values <= other, cls=BoolArr)
-    def __eq__(self, other): return self.asnew(self.values == other, cls=BoolArr)
-    def __ne__(self, other): return self.asnew(self.values != other, cls=BoolArr)
-    
-    def __and__(self, other): raise BooleanOperationError(self)
-    def __or__(self, other):  raise BooleanOperationError(self)
-    def __xor__(self, other): raise BooleanOperationError(self)
-    def __invert__(self):     raise BooleanOperationError(self)
-    
-    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
-        """ For almost everything else, behave like a normal NumPy array on Arr.values """
-        inputs = [x.values if isinstance(x, Arr) else x for x in inputs]
-        return getattr(ufunc, method)(*inputs, **kwargs)
-    
-    @property
-    def auids(self):
-        """ Link to the indices of active agents -- sim.people.auids """
-        try:
-            return self.people.auids
-        except:
-            ss.warn('Trying to access non-initialized States object')
-            return uids(np.arange(len(self.raw)))
-    
-    def count(self):
-        return np.count_nonzero(self.values)
-
-    @property
-    def values(self):
-        """ Return the values of the active agents """
-        return self.raw[self.auids]
-
-    def set(self, uids, new_vals=None):
-        """ Set the values for the specified UIDs"""
-        if new_vals is None: 
-            if isinstance(self.default, ss.Dist):
-                new_vals = self.default.rvs(uids)
-            elif callable(self.default):
-                new_vals = self.default(len(uids))
-            elif self.default is not None:
-                new_vals = self.default
-            else:
-                new_vals = self.nan
-        self.raw[uids] = new_vals
-        return new_vals
-    
-    def set_nan(self, uids):
-        """ Shortcut function to set values to NaN """
-        self.raw[uids] = self.nan
-        return
-    
-    def grow(self, new_uids=None, new_vals=None):
-        """
-        Add new agents to an Arr
-
-        This method is normally only called via `People.grow()`.
-
-        Args:
-            new_uids: Numpy array of UIDs for the new agents being added
-            new_vals: If provided, assign these state values to the new UIDs
-        """
-        if new_uids is None and new_vals is not None: # Used as a shortcut to avoid needing to supply twice
-            new_uids = new_vals
-        orig_len = self.len_used
-        n_new = len(new_uids)
-        self.len_used += n_new  # Increase the count of the number of agents by `n` (the requested number of new agents)
-        
-        # Physically reshape the arrays, if needed
-        if orig_len + n_new > self.len_tot:
-            n_grow = max(n_new, self.len_tot//2)  # Minimum 50% growth, since growing arrays is slow
-            new_empty = np.empty(n_grow, dtype=self.dtype) # 10x faster than np.zeros()
-            self.raw = np.concatenate([self.raw, new_empty], axis=0)
-            self.len_tot = len(self.raw)
-            if n_grow > n_new: # We added extra space at the end, set to NaN
-                nan_uids = np.arange(self.len_used, self.len_tot)
-                self.set_nan(nan_uids)
-        
-        # Set new values, and NaN if needed
-        self.set(new_uids, new_vals=new_vals) # Assign new default values to those agents
-        return
-    
-    def link_people(self, people):
-        """ Link a People object to this state, for access auids """
-        self.people = people # Link the people object to this state
-        people._link_state(self) # Ensure the state is linked to the People object as well
-        return
-    
-    def init_vals(self):
-        """ Actually populate the initial values and mark as initialized; only to be used on initialization """
-        if self.initialized:
-            errormsg = f'Cannot re-initialize state {self}; use set() instead'
-            raise RuntimeError(errormsg)
-        self.grow(self.people.uid)
-        self.initialized = True
-        return
-
-    def asnew(self, arr=None, cls=None):
-        """ Duplicate and copy (rather than link) data, optionally resetting the array """
-        if cls is None:
-            cls = self.__class__
-        if arr is None:
-            arr = self.values
-        new = object.__new__(cls) # Create a new Arr instance
-        new.__dict__ = self.__dict__.copy() # Copy pointers
-        new.dtype = arr.dtype # Set to correct dtype
-        new.raw = np.empty_like(new.raw, dtype=new.dtype) # Copy values, breaking reference
-        new.raw[new.auids] = arr
-        return new
-
-
-class FloatArr(Arr):
-    """ Subclass of Arr with defaults for floats """
-    def __init__(self, name, default=None, nan=np.nan, label=None, skip_init=False):
-        super().__init__(name=name, dtype=ss_float, default=default, nan=nan, label=label, coerce=False, skip_init=skip_init)
-        return
-    
-    @property
-    def isnan(self):
-        """ Return indices that are NaN """
-        return np.nonzero(np.isnan(self.values))[0]
-
-    @property
-    def notnan(self):
-        """ Return indices that are not-NaN """
-        return np.nonzero(~np.isnan(self.values))[0]
-    
-    @property
-    def notnanvals(self):
-        """ Return values that are not-NaN """
-        vals = self.values # Shorten and avoid double indexing
-        out = vals[np.nonzero(~np.isnan(vals))[0]]
-        return out
-
-    
-class BoolArr(Arr):
-    """ Subclass of Arr with defaults for booleans """
-    def __init__(self, name, default=None, nan=False, label=None, skip_init=False): # No good NaN equivalent for bool arrays
-        super().__init__(name=name, dtype=ss_bool, default=default, nan=nan, label=label, coerce=False, skip_init=skip_init)
-        return
-    
-    def __and__(self, other): return self.asnew(self.values & other)
-    def __or__(self, other):  return self.asnew(self.values | other)
-    def __xor__(self, other): return self.asnew(self.values ^ other)
-    def __invert__(self):     return self.asnew(~self.values)
-    
-    @property
-    def uids(self):
-        """ Efficiently convert True values to UIDs """
-        return self.auids[np.nonzero(self.values)[0]]
-
-    def true(self):
-        """ Alias to BoolArr.uids """
-        return self.uids
-
-    def false(self):
-        """ Reverse of true(); return UIDs of values that are false """
-        return self.auids[np.nonzero(~self.values)[0]]
-
-    def split(self):
-        """ Return UIDs of values that are true and false as separate arrays """
-        t_uids = self.true()
-        f_uids = self.false()
-        return t_uids, f_uids
-
-    
-class IndexArr(Arr):
-    """ A special class of IndexArr used for UIDs and RNG IDs """
-    def __init__(self, name, label=None):
-        super().__init__(name=name, dtype=ss_int, default=None, nan=-1, label=label, coerce=False, skip_init=True)
-        self.raw = uids(self.raw)
-        return
-    
-    @property
-    def uids(self):
-        """ Alias to self.values, to allow Arr.uids like BoolArr """
-        return self.values
-    
-    @property
-    def isnan(self):
-        return np.nonzero(self.values == self.nan)[0]
-
-    @property
-    def notnan(self):
-        return np.nonzero(self.values != self.nan)[0]
-    
-    def grow(self, new_uids=None, new_vals=None):
-        """ Change the size of the array """
-        super().grow(new_uids=new_uids, new_vals=new_vals)
-        self.raw = uids(self.raw)
-        return
-    
-    
-class uids(np.ndarray):
-    """
-    Class to specify that integers should be interpreted as UIDs.
-    
-    For all practical purposes, behaves like a NumPy integer array. However,
-    has additional methods ``uids.concat()`` (instance method), ``ss.uids.cat()``
-    (class method), ``uids.remove()``, and ``uids.intersect()`` to simplify common
-    UID operations.    
-    """
-    def __new__(cls, arr=None):
-        if isinstance(arr, np.ndarray): # Shortcut to typical use case, where the input is an array
-            return arr.astype(ss_int).view(cls)
-        elif isinstance(arr, BoolArr): # Shortcut for arr.uids
-            return arr.uids
-        elif arr is None: # Shortcut to return empty
-            return np.empty(0, dtype=ss_int).view(cls)
-        elif isinstance(arr, int): # Convert e.g. ss.uids(0) to ss.uids([0])
-            arr = [arr]
-        return np.asarray(arr, dtype=ss_int).view(cls) # Handle everything else
-    
-    def concat(self, other, **kw): # TODO: why can't they both be called cat()?
-        """ Equivalent to np.concatenate(), but return correct type """
-        return np.concatenate([self, other], **kw).view(self.__class__)
-    
-    @classmethod
-    def cat(cls, *args, **kw):
-        """ Equivalent to np.concatenate(), but return correct type """
-        arrs = args[0] if len(args) == 1 else args
-        return np.concatenate(arrs, **kw).view(cls)
-    
-    def remove(self, other, **kw):
-        """ Remove provided UIDs from current array"""
-        return np.setdiff1d(self, other, assume_unique=True, **kw).view(self.__class__)
-    
-    def intersect(self, other, **kw):
-        """ Keep only UIDs that match other array """
-        return np.intersect1d(self, other, assume_unique=True, **kw).view(self.__class__)
-    
-    def to_numpy(self):
-        """ Convert to a standard NumPy array """
-        return np.array(self)
-    
-
-class BooleanOperationError(NotImplementedError):
-    """ Raised when a logical operation is performed on a non-logical array """
-    def __init__(self, arr):
-        msg = f'Logical operations are only valid on Boolean arrays, not {arr.dtype}'
-        super().__init__(msg)
\ No newline at end of file
diff --git a/starsim/time.py b/starsim/time.py
new file mode 100644
index 0000000..6e03a52
--- /dev/null
+++ b/starsim/time.py
@@ -0,0 +1,916 @@
+"""
+Functions and classes for handling time
+"""
+import sciris as sc
+import numpy as np
+import pandas as pd
+import datetime as dt
+import dateutil as du
+import starsim as ss
+
+
+#%% Helper functions
+
+# Classes and objects that are externally visible
+__all__ = ['time_units', 'time_ratio', 'date_add', 'date_diff']
+
+# Allowable time arguments
+time_args = ['start', 'stop', 'dt', 'unit']
+
+# Define available time units
+time_units = sc.objdict(
+    day   = 1.0,
+    week  = 7.0,
+    month = 30.4375, # 365.25/12
+    year  = 365.25, # For consistency with months
+)
+
+# Define defaults
+default_dur = 50
+default_unit = 'year'
+default_start_year = 2000
+default_start_date = '2000-01-01'
+default_start = sc.objdict(
+    {k:default_start_date for k in ['day', 'week', 'month']} |
+    {k:default_start_year for k in ['year', 'unitless']}
+)
+
+
+def time_ratio(unit1='day', dt1=1.0, unit2='day', dt2=1.0, as_int=False):
+    """
+    Calculate the relationship between two sets of time factors
+
+    Args:
+        unit1 (str): units for the numerator
+        dt1 (float): timestep for the numerator
+        unit2 (str): units for the denominator
+        dt2 (float): timestep for the denominator
+        as_int (bool): round and convert to an integer
+
+    **Example**::
+        ss.time_ratio(unit1='week', dt1=2, unit2='day', dt2=1, as_int=True) # Returns 14
+    """
+    if dt1 == dt2:
+        dt_ratio = 1.0
+    else:
+        if dt1 is None or dt2 is None:
+            errormsg = f'Cannot convert between dt when one is None ({dt1}, {dt2})'
+            raise ValueError(errormsg)
+        dt_ratio = dt1/dt2
+
+    if unit1 == unit2:
+        unit_ratio = 1.0
+    else:
+        if is_unitless(unit1) or is_unitless(unit2):
+            errormsg = f'Cannot convert between units if only one is unitless (unit1={unit1}, unit2={unit2})'
+            raise ValueError(errormsg)
+        if unit1 is None or unit2 is None:
+            errormsg = f'Cannot convert between units when only one has been initialized (unit1={unit1}, unit2={unit2})'
+            raise ValueError(errormsg)
+        u1 = time_units[unit1]
+        u2 = time_units[unit2]
+        unit_ratio = u1/u2
+
+    factor = dt_ratio * unit_ratio
+    if as_int:
+        factor = int(round(factor))
+    return factor
+
+
+def date_add(start, dur, unit):
+    """ Add two dates (or integers) together """
+    if sc.isnumber(start):
+        stop = start + dur
+    else:
+        if unit in time_units:
+            ndays = int(round(time_units[unit]*dur))
+            stop = sc.datedelta(start, days=ndays)
+        else:
+            errormsg = f'Unknown unit {unit}, choices are: {sc.strjoin(time_units.keys())}'
+            raise ValueError(errormsg)
+    return stop
+
+
+def date_diff(start, stop, unit):
+    """ Find the difference between two dates (or integers) """
+    if sc.isnumber(start) and sc.isnumber(stop):
+        dur = stop - start
+    else:
+        if unit == 'year':
+            dur = sc.datetoyear(stop) - sc.datetoyear(start) # TODO: allow non-integer amounts
+        else:
+            dur = (ss.date(stop) - ss.date(start)).days
+            if unit != 'day':
+                dur *= time_ratio(unit1='day', unit2=unit)
+    return dur
+
+
+def round_tvec(tvec):
+    """ Round time vectors to a certain level of precision, to avoid floating point errors """
+    decimals = int(-np.log10(ss.options.time_eps))
+    tvec = np.round(np.array(tvec), decimals=decimals)
+    return tvec
+
+
+def years_to_dates(yearvec):
+    """ Convert a numeric year vector to a date vector """
+    datevec = np.array([date(sc.datetoyear(y, reverse=True)) for y in yearvec])
+    return datevec
+
+
+def dates_to_years(datevec):
+    """ Convert a date vector to a numeric year vector"""
+    yearvec = round_tvec([sc.datetoyear(d.date()) for d in datevec])
+    return yearvec
+
+
+def dates_to_days(datevec, start_date):
+    """ Convert a date vector into relative days since start date """
+    start_date = date(start_date)
+    dayvec = np.array([(d - start_date).days for d in datevec])
+    return dayvec
+
+
+#%% Time classes
+
+__all__ += ['date', 'Time']
+
+
+class date(pd.Timestamp):
+    """
+    Define a single date; based on ``pd.Timestamp``
+
+    Args:
+        date (int/float/str/datetime): Any type of date input (ints and floats will be interpreted as years)
+        kwargs (dict): passed to pd.Timestamp()
+
+    **Examples**::
+
+        ss.date(2020) # Returns <2020-01-01>
+        ss.date(year=2020) # Returns <2020-01-01>
+        ss.date(year=2024.75) # Returns <2024-10-01>
+        ss.date('2024-04-04') # Returns <2024-04-04>
+        ss.date(year=2024, month=4, day=4) # Returns <2024-04-04>
+    """
+    def __new__(cls, *args, **kwargs):
+        # Check if a year was supplied, and preprocess it
+        single_year_arg = False
+        if len(args) == 1:
+            arg = args[0]
+            if arg is None:
+                return pd.Timestamp(None)
+            elif sc.isnumber(arg):
+                single_year_arg = True
+            elif isinstance(arg, pd.Timedelta):
+                return pd.Timedelta(arg)
+        year_kwarg = len(args) == 0 and len(kwargs) == 1 and 'year' in kwargs
+        if single_year_arg:
+            return cls.from_year(args[0])
+        if year_kwarg:
+            return cls.from_year(kwargs['year'])
+
+        # Otherwise, proceed as normal
+        out = super(date, cls).__new__(cls, *args, **kwargs)
+        out = cls._reset_class(out)
+        return out
+
+    @classmethod
+    def _reset_class(cls, obj):
+        """ Manually reset the class from pd.Timestamp to ss.date """
+        try:
+            obj.__class__ = date
+        except:
+            warnmsg = f'Unable to convert {out} to ss.date(); proceeding with pd.Timestamp'
+            ss.warn(warnmsg)
+        return obj
+
+    def __repr__(self, bracket=True):
+        """ Show the date in brackets, e.g. <2024.04.04> """
+        _ = ss.options.date_sep
+        y = f'{self.year:04d}'
+        m = f'{self.month:02d}'
+        d = f'{self.day:02d}'
+        string = y + _ + m + _ + d
+        if bracket:
+            string = '<' + string + '>'
+        return string
+
+    def __str__(self):
+        """ Like repr, but just the date, e.g. 2024.04.04 """
+        return self.__repr__(bracket=False)
+
+    def disp(self, **kwargs):
+        """ Show the full object """
+        return sc.pr(self, **kwargs)
+
+    @classmethod
+    def from_year(cls, year):
+        """
+        Convert an int or float year to a date.
+
+        **Examples**::
+
+            ss.date.from_year(2020) # Returns <2020-01-01>
+            ss.date.from_year(2024.75) # Returns <2024-10-01>
+        """
+        if isinstance(year, int):
+            return cls(year=year, month=1, day=1)
+        else:
+            dateobj = sc.datetoyear(year, reverse=True)
+            return cls(dateobj)
+
+    def to_year(self):
+        """
+        Convert a date to a floating-point year
+
+        **Examples**::
+
+            ss.date('2020-01-01').to_year() # Returns 2020.0
+            ss.date('2024-10-01').to_year() # Returns 2024.7486
+        """
+        return sc.datetoyear(self.date())
+
+    def to_pandas(self):
+        """ Convert to a standard pd.Timestamp instance """
+        return pd.Timestamp(self.to_numpy()) # Need to convert to NumPy first or it doesn't do anything
+
+    @staticmethod
+    def _convert_other(other):
+        if isinstance(other, du.relativedelta.relativedelta):
+            tu = ss.time.time_units
+            days = other.days + tu.month*other.months + tu.year*other.years
+            int_days = int(round(days))
+            other = dt.timedelta(days=int_days)
+        elif isinstance(other, ss.dur):
+            factor = ss.time.time_units[other.unit]
+            int_days = int(round(factor*other.v))
+            other = dt.timedelta(days=int_days)
+        return other
+
+    def __add__(self, other):
+        other = self._convert_other(other)
+        out = super().__add__(other)
+        out = date(out)
+        return out
+
+    def __sub__(self, other):
+        other = self._convert_other(other)
+        out = super().__sub__(other)
+        out = date(out)
+        return out
+
+    def __radd__(self, other): return self.__add__(other)
+    def __iadd__(self, other): return self.__add__(other)
+    def __rsub__(self, other): return self.__sub__(other) # TODO: check if this should be reversed
+    def __isub__(self, other): return self.__sub__(other)
+
+
+class Time(sc.prettyobj):
+    """
+    Handle time vectors for both simulations and modules.
+
+    Args:
+        start (float/str/date): the start date for the simulation/module
+        stop (float/str/date): the end date for the simulation/module
+        dt (float): the step size, in units of "unit"
+        unit (str): the time unit; choices are "day", "week", "month", "year", or "unitless"
+        pars (dict): if provided, populate parameter values from this dictionary
+        parent (obj): if provided, populate missing parameter values from a 'parent" ``Time`` instance
+        name (str): if provided, name the ``Time`` object
+        init (bool): whether or not to immediately initialize the Time object
+        sim (bool/Sim): if True, initializes as a sim-specific ``Time`` instance; if a Sim instance, initialize the absolute time vector
+
+    The ``Time`` object, after initialization, has the following attributes:
+
+    - ``ti`` (int): the current timestep
+    -  ``dt_year`` (float): the timestep in units of years
+    - ``npts`` (int): the number of timesteps
+    - ``tvec`` (array): time starting at 0, in self units (e.g. ``[0, 0.1, 0.2, ... 10.0]`` if start=0, stop=10, dt=0.1)
+    - ``absvec`` (array): time relative to sim start, in units of sim units (e.g. ``[366, 373, 380, ...]`` if sim-start=2001, start=2002, sim-unit='day', unit='week')
+    - ``yearvec`` (array): time represented as floating-point years (e.g. ``[2000, 2000.1, 2000.2, ... 2010.0]`` if start=2000, stop=2010, dt=0.1)
+    - ``datevec`` (array): time represented as an array of ``ss.date`` objects (e.g. ``[<2000.01.01>, <2000.02.07>, ... <2010.01.01>]`` if start=2000, stop=2010, dt=0.1)
+    - ``timevec`` (array): the "native" time vector, which always matches one of ``tvec``, ``yearvec``, or ``datevec``
+
+    **Examples**::
+
+        t1 = ss.Time(start=2000, stop=2020, dt=1.0, unit='year') # Years, numeric units
+        t2 = ss.Time(start='2021-01-01', stop='2021-04-04', dt=2.0, unit='day') # Days, date units
+    """
+    def __init__(self, start=None, stop=None, dt=None, unit=None, pars=None, parent=None,
+                 name=None, init=True, sim=None):
+        self.name = name
+        self.start = start
+        self.stop = stop
+        self.dt = dt
+        self.unit = unit
+        self.ti = 0 # The time index, e.g. 0, 1, 2
+
+        # Prepare for later initialization
+        self.dt_year = None
+        self.npts    = None
+        self.tvec    = None
+        self.timevec = None
+        self.datevec = None
+        self.yearvec = None
+        self.abstvec = None
+        self.initialized = False
+
+        # Finalize
+        self.update(pars=pars, parent=parent)
+        if init and self.ready:
+            self.init(sim=sim)
+        return
+
+    def __bool__(self):
+        """ Always truthy """
+        return True
+
+    def __len__(self):
+        """ Length is the number of timepoints """
+        return sc.ifelse(self.npts, 0)
+
+    @property
+    def ready(self):
+        """ Check if all parameters are in place to be initialized """
+        return not any([getattr(self, k) is None for k in time_args])
+
+    @property
+    def is_numeric(self):
+        """ Check whether the fundamental simulation unit is numeric (as opposed to date-based) """
+        try:
+            return sc.isnumber(self.start)
+        except:
+            return False
+
+    @property
+    def is_unitless(self):
+        return is_unitless(self.unit)
+
+    def __setstate__(self, state):
+        """ Custom setstate to unpickle ss.date() instances correctly """
+        self.__dict__.update(state)
+        self._convert_timestamps()
+        return
+
+    def _convert_timestamps(self):
+        """ Replace pd.Timestamp instances with ss.date(); required due to pandas limitations with pickling """
+        objs = [self.start, self.stop]
+        objs += sc.tolist(self.datevec, coerce='full')
+        objs += sc.tolist(self.timevec, coerce='full')
+        objs = [obj for obj in objs if type(obj) == pd.Timestamp]
+        for obj in objs:
+            date._reset_class(obj)
+        return
+
+    def update(self, pars=None, parent=None, reset=True, force=None, **kwargs):
+        """ Reconcile different ways of supplying inputs """
+        pars = sc.mergedicts(pars)
+        stale = False
+
+        for key in time_args:
+            current_val = getattr(self, key, None)
+            parent_val = getattr(parent, key, None)
+            kw_val = kwargs.get(key)
+            par_val = pars.get(key)
+
+            # Special handling for dt: don't inherit dt if the units are different
+            if key == 'dt':
+                if isinstance(parent, Time):
+                    if parent.unit != self.unit:
+                        parent_val = 1.0
+
+            if force is False: # Only update missing (None) values
+                val = sc.ifelse(current_val, kw_val, par_val, parent_val)
+            elif force is None: # Prioritize current value
+                val = sc.ifelse(kw_val, par_val, current_val, parent_val)
+            elif force is True: # Prioritize parent value
+                val = sc.ifelse(kw_val, par_val, parent_val, current_val)
+            else:
+                errormsg = f'Invalid value {force} for force: must be False, None, or True'
+                raise ValueError(errormsg)
+
+            if val != current_val:
+                setattr(self, key, val)
+                stale = True
+
+        if stale and reset and self.initialized:
+            self.init()
+        return
+
+    def init(self, sim=None):
+        """ Initialize all vectors """
+        # Initial validation
+        self.unit = validate_unit(self.unit)
+
+        # Copy missing values from sim
+        if isinstance(sim, ss.Sim):
+            self.unit = sc.ifelse(self.unit, sim.t.unit)
+            if self.unit == sim.t.unit: # Units match, use directly
+                sim_dt = sim.t.dt
+                sim_start = sim.t.start
+                sim_stop = sim.t.stop
+            else: # Units don't match, use datevec instead
+                sim_dt = 1.0 # Don't try to reset the dt if the units don't match
+                sim_start = sim.t.datevec[0]
+                sim_stop = sim.t.datevec[-1]
+            self.dt = sc.ifelse(self.dt, sim_dt)
+            self.start = sc.ifelse(self.start, sim_start)
+            self.stop = sc.ifelse(self.stop, sim_stop)
+
+        # Handle start and stop
+        self.start = self.start if self.is_numeric else date(self.start)
+        self.stop  = self.stop  if self.is_numeric else date(self.stop)
+
+        # Convert start and stop to dates
+        date_start = self.start
+        date_stop = self.stop
+        date_unit = 'year' if not has_units(self.unit) else self.unit # Use year by default
+        dt_year = time_ratio(unit1=date_unit, dt1=self.dt, unit2='year', dt2=1.0) # Timestep in units of years
+        offset = 0
+        if self.is_numeric and date_start == 0:
+            date_start = ss.date(ss.time.default_start[date_unit])
+            date_stop = date_start + ss.dur(date_stop, unit=date_unit)
+            offset = date_start.year
+
+        # If numeric, treat that as the ground truth
+        if self.is_numeric:
+            ratio = time_ratio(unit1=date_unit, unit2='year')
+            timevec = round_tvec(sc.inclusiverange(self.start, self.stop, self.dt))
+            yearvec = round_tvec((timevec-timevec[0])*ratio + offset + timevec[0]) # TODO: simplify
+            datevec = years_to_dates(yearvec)
+
+        # If unitless, just use that
+        elif self.is_unitless:
+            timevec = round_tvec(sc.inclusiverange(self.start, self.stop, self.dt))
+            yearvec = round_tvec(timevec)
+            datevec = timevec
+
+        # If the unit is years, handle that
+        elif date_unit == 'year': # For years, the yearvec is the most robust representation
+            start_year = sc.datetoyear(date_start.date())
+            stop_year = sc.datetoyear(date_stop.date())
+            yearvec = round_tvec(sc.inclusiverange(start_year, stop_year, self.dt))
+            datevec = years_to_dates(yearvec)
+            timevec = datevec
+
+        # Otherwise, use dates as the ground truth
+        else:
+            if int(self.dt) == self.dt: # The step is integer-like, use exactly
+                key = date_unit + 's' # e.g. day -> days
+                datelist = sc.daterange(date_start, date_stop, interval={key:int(self.dt)})
+            else: # Convert to the sim unit instead
+                day_delta = time_ratio(unit1=date_unit, dt1=self.dt, unit2='day', dt2=1.0, as_int=True)
+                if day_delta >= 1:
+                    datelist = sc.daterange(date_start, date_stop, interval={'days':day_delta})
+                else:
+                    errormsg = f'Timestep {dt} is too small; must be at least 1 day'
+                    raise ValueError(errormsg)
+            datevec = np.array([ss.date(d) for d in datelist])
+            yearvec = dates_to_years(datevec)
+            timevec = datevec
+
+        # Store things
+        self.dt_year = dt_year
+        self.npts = len(timevec) # The number of points in the sim
+        self.tvec = round_tvec(np.arange(self.npts)*self.dt) # Absolute time array
+        self.timevec = timevec
+        self.datevec = datevec
+        self.yearvec = yearvec
+        if sim == True: # It's the sim itself, the tvec is the absolute time vector
+            self.abstvec = self.tvec
+        elif sim is not None:
+            self.make_abstvec(sim)
+        else:
+            self.abstvec = None # Intentionally set to None, cannot be used in the sim loop until populated
+        self.initialized = True
+        return
+
+    def make_abstvec(self, sim):
+        """ Convert the current time vector into sim units """
+        # Validation
+        if self.is_unitless != sim.t.is_unitless:
+            errormsg = f'Cannot mix units with unitless time: sim.unit={sim.t.unit} {self.name}.unit={self.unit}'
+            raise ValueError(errormsg)
+
+        # Both are unitless or numeric
+        both_unitless = self.is_unitless and sim.t.is_unitless
+        both_numeric = self.is_numeric and sim.t.is_numeric
+        if both_unitless or both_numeric:
+            abstvec = self.tvec.copy() # Start by copying the current time vector
+            ratio = time_ratio(unit1=self.unit, dt1=1.0, unit2=sim.t.unit, dt2=1.0) # tvec has sim units, but not dt
+            if ratio != 1.0:
+                abstvec *= ratio # TODO: CHECK
+            start_diff = self.start - sim.t.start
+            if start_diff != 0.0:
+                abstvec += start_diff
+
+        # The sim uses years; use yearvec
+        elif sim.t.unit == 'year':
+            abstvec = self.yearvec.copy()
+            abstvec -= sim.t.yearvec[0] # Start relative to sim start
+
+        # Otherwise (days, weeks, months), use datevec and convert to days
+        else:
+            dayvec = dates_to_days(self.datevec, start_date=sim.t.datevec[0])
+            ratio = time_ratio(unit1='day', dt1=1.0, unit2=sim.t.unit, dt2=1.0)
+            abstvec = dayvec*ratio # Convert into sim time units
+
+        self.abstvec = round_tvec(abstvec) # Avoid floating point inconsistencies
+        return
+
+    def now(self, key=None):
+        """
+        Get the current simulation time
+
+        Args:
+            which (str): which type of time to get: default (None), "year", "date", "tvec", or "str"
+
+        **Examples**::
+
+            t = ss.Time(start='2021-01-01', stop='2022-02-02', dt=1, unit='week')
+            t.ti = 25
+            t.now() # Returns <2021-06-25>
+            t.now('date') # Returns <2021-06-25>
+            t.now('year') # Returns 2021.479
+            t.now('str') # Returns '2021-06-25'
+        """
+        if key in [None, 'none', 'time', 'str']:
+            vec = self.timevec
+        elif key == 'tvec':
+            vec = self.tvec
+        elif key == 'date':
+            vec = self.datevec
+        elif key == 'year':
+            vec = self.yearvec
+        else:
+            errormsg = f'Invalid key "{key}": must be None, abs, date, or year'
+            raise ValueError(errormsg)
+
+        now = vec[min(self.ti, len(vec)-1)]
+        if key == 'str':
+            now = f'{now:0.1f}' if isinstance(now, float) else str(now)
+        return now
+
+
+#%% TimePar classes
+
+__all__ += ['TimePar', 'dur', 'days', 'years', 'rate', 'perday', 'peryear',
+            'time_prob', 'beta', 'rate_prob']
+
+class TimePar(ss.BaseArr):
+    """
+    Base class for time-aware parameters, durations and rates
+
+    NB, because the factor needs to be recalculated, do not set values directly.
+    """
+    def __new__(cls, v=None, *args, **kwargs):
+        """ Allow TimePars to wrap distributions and return the distributions """
+
+        # Special distribution handling
+        if isinstance(v, ss.Dist):
+            if len(args):
+                errormsg = f'When wrapping a distribution with a TimePar, args not allowed ({args}); use kwargs'
+                raise ValueError(errormsg)
+            dist = v
+            dist.pars[0] = cls(dist.pars[0], **kwargs) # Convert the first parameter to a TimePar (the same scale is applied to all parameters)
+            return dist
+
+        # Otherwise, do the usual initialization
+        else:
+            return super().__new__(cls)
+
+    def __init__(self, v, unit=None, parent_unit=None, parent_dt=None, self_dt=1.0):
+        self.v = v
+        self.unit = unit
+        self.parent_unit = parent_unit
+        self.parent_dt = parent_dt
+        self.self_dt = self_dt
+        self.factor = None
+        self.values = None
+        self.initialized = False
+        self.validate_units()
+        return
+
+    def validate_units(self):
+        """ Check that the units entered are valid """
+        try:
+            self.unit = unit_mapping[self.unit]
+        except KeyError:
+            errormsg = f'Invalid unit "{self.unit}"; must be one of: {sc.strjoin(time_units.keys())}'
+            raise ValueError(errormsg)
+        try:
+            self.parent_unit = unit_mapping[self.parent_unit]
+        except KeyError:
+            errormsg = f'Invalid parent unit "{self.parent_unit}"; must be one of: {sc.strjoin(time_units.keys())}'
+            raise ValueError(errormsg)
+        return
+
+    def init(self, parent=None, parent_unit=None, parent_dt=None, update_values=True, die=True):
+        """ Link to the sim and/or module units """
+        if parent is None:
+            parent = sc.dictobj(unit=parent_unit, dt=parent_dt)
+        else:
+            if parent_dt is not None:
+                errormsg = f'Cannot override parent {parent} by setting parent_dt; set in parent object instead'
+                raise ValueError(errormsg)
+
+        if parent.unit is not None:
+            self.parent_unit = parent.unit
+
+        if parent.dt is not None:
+            self.parent_dt = parent.dt
+
+        # Set defaults if not yet set
+        self.unit = sc.ifelse(self.unit, self.parent_unit) # If unit isn't defined but parent is, set to parent
+        self.parent_unit = sc.ifelse(self.parent_unit, self.unit) # If parent isn't defined but unit is, set to self
+        self.parent_dt = sc.ifelse(self.parent_dt, self.self_dt, 1.0) # If dt isn't defined, assume 1 (self_dt is defined by default)
+
+        # Calculate the actual conversion factor to be used in the calculations
+        self.update_cached(update_values=update_values, die=die)
+        self.initialized = True
+        self.validate_units()
+        return self
+
+    def __repr__(self):
+        name = self.__class__.__name__
+
+        if self.initialized:
+            if self.factor == 1.0:
+                xstr = ''
+            else:
+                xstr = f', values={self.values}'
+        else:
+            xstr = ', initialized=False'
+
+        if (self.parent_unit is not None) and (self.unit != self.parent_unit):
+            parentstr = f', parent={self.parent_unit}'
+        else:
+            parentstr = ''
+
+        default_dt = sc.ifelse(self.self_dt, 1.0) == 1.0
+        if not default_dt:
+            dtstr = f', self_dt={self.self_dt}'
+        else:
+            dtstr = ''
+
+        # Rather than ss.dur(3, unit='day'), dispaly as ss.days(3)
+        prefixstr = 'ss.'
+        key = (name, self.unit)
+        mapping = {
+            ('dur',  'day'):  'days',
+            ('dur',  'year'): 'years',
+            ('rate', 'day'):  'perday',
+            ('rate', 'year'): 'peryear',
+        }
+
+        if key in mapping and default_dt:
+            prefixstr += mapping[key]
+            unitstr = ''
+        else:
+            prefixstr += name
+            unitstr = f', unit={self.unit}'
+
+        suffixstr = unitstr + parentstr + dtstr + xstr
+
+        return f'{prefixstr}({self.v}{suffixstr})'
+
+    @property
+    def isarray(self):
+        """ Check if the value is an array """
+        return isinstance(self.v, np.ndarray)
+
+    def set(self, v=None, unit=None, parent_unit=None, parent_dt=None, self_dt=None, force=False):
+        """ Set the specified parameter values (ignoring None values) and update stored values """
+        if v           is not None: self.v           = v
+        if unit        is not None: self.unit        = unit
+        if parent_unit is not None: self.parent_unit = parent_unit
+        if parent_dt   is not None: self.parent_dt   = parent_dt
+        if self_dt     is not None: self.self_dt     = self_dt
+        if self.initialized or force: # Don't try to set these unless it's been initialized
+            self.update_cached()
+        self.validate_units()
+        return self
+
+    def update_cached(self, update_values=True, die=True):
+        """ Update the cached factor and values """
+        try:
+            self.update_factor()
+            if update_values:
+                self.update_values()
+        except TypeError as E: # For a known error, skip silently if die=False
+            if die:
+                errormsg = f'Update failed for {self}. Argument v={self.v} should be a number or array; if a function, use update_values=False. Error: {E}'
+                raise TypeError(errormsg) from E
+        except Exception as E: # For other errors, raise a warning
+            if die:
+                raise E
+            else:
+                tb = sc.traceback(E)
+                warnmsg = f'Uncaught error encountered while updating {self}, but die=False. Traceback:\n{tb}'
+                ss.warn(warnmsg)
+
+        return self
+
+    def update_factor(self):
+        """ Set factor used to multiply the value to get the output """
+        self.factor = time_ratio(unit1=self.unit, dt1=self.self_dt, unit2=self.parent_unit, dt2=self.parent_dt)
+        return
+
+    def update_values(self):
+        """ Convert from self.v to self.values based on self.factor -- must be implemented by derived classes """
+        raise NotImplementedError
+
+    def to(self, unit=None, dt=None):
+        """ Create a new timepar based on the current one but with a different unit and/or dt """
+        new = self.asnew()
+        unit = sc.ifelse(unit, self.parent_unit, self.unit)
+        parent_dt = sc.ifelse(dt, 1.0)
+        new.factor = time_ratio(unit1=self.unit, dt1=self.self_dt, unit2=unit, dt2=parent_dt) # Calculate the new factor
+        new.update_values() # Update values
+        new.v = new.values # Reset the base value
+        new.factor = 1.0 # Reset everything else to be 1
+        new.unit = unit
+        new.self_dt = parent_dt
+        new.parent_unit = unit
+        new.parent_dt = parent_dt
+        return new
+
+    def to_parent(self):
+        """ Create a new timepar with the same units as the parent """
+        unit = self.parent_unit
+        dt = self.parent_dt
+        return self.to(unit=unit, dt=dt)
+
+    def to_json(self):
+        """ Export to JSON """
+        attrs = ['v', 'unit', 'parent_unit', 'parent_dt', 'self_dt', 'factor']
+        out = {'classname': self.__class__.__name__}
+        out.update({attr:getattr(self, attr) for attr in attrs})
+        out['values'] = sc.jsonify(self.values)
+        return out
+
+    # Act like a float -- TODO, add type checking
+    def __add__(self, other): return self.values + other
+    def __sub__(self, other): return self.values - other
+    def __mul__(self, other): return self.asnew().set(v=self.v * other)
+    def __pow__(self, other): return self.values ** other
+    def __truediv__(self, other): return self.asnew().set(v=self.v / other)
+
+    # ...from either side
+    def __radd__(self, other): return other + self.values
+    def __rsub__(self, other): return other - self.values
+    def __rmul__(self, other): return self.asnew().set(v= other * self.v)
+    def __rpow__(self, other): return other ** self.values
+    def __rtruediv__(self, other): return other / self.values # TODO: should be a rate?
+
+    # Handle modify-in-place methods
+    def __iadd__(self, other): return self.set(v=self.v + other)
+    def __isub__(self, other): return self.set(v=self.v - other)
+    def __imul__(self, other): return self.set(v=self.v * other)
+    def __itruediv__(self, other): return self.set(v=self.v / other)
+
+    # Other methods
+    def __neg__(self): return self.asnew().set(v=-self.v)
+
+
+class dur(TimePar):
+    """ Any number that acts like a duration """
+    def update_values(self):
+        self.values = self.v*self.factor
+        return self.values
+
+
+def days(v, parent_unit=None, parent_dt=None):
+    """ Shortcut to ss.dur(value, units='day') """
+    return dur(v=v, unit='day', parent_unit=parent_unit, parent_dt=parent_dt)
+
+
+def years(v, parent_unit=None, parent_dt=None):
+    """ Shortcut to ss.dur(value, units='year') """
+    return dur(v=v, unit='year', parent_unit=parent_unit, parent_dt=parent_dt)
+
+
+class rate(TimePar):
+    """ Any number that acts like a rate; can be greater than 1 """
+    def update_values(self):
+        self.values = self.v/self.factor
+        return self.values
+
+
+def perday(v, parent_unit=None, parent_dt=None):
+    """ Shortcut to ss.rate(value, units='day') """
+    return rate(v=v, unit='day', parent_unit=parent_unit, parent_dt=parent_dt)
+
+
+def peryear(v, parent_unit=None, parent_dt=None):
+    """ Shortcut to ss.rate(value, units='year') """
+    return rate(v=v, unit='year', parent_unit=parent_unit, parent_dt=parent_dt)
+
+
+class time_prob(TimePar):
+    """
+    A probability over time (a.k.a. a cumulative hazard rate); must be >=0 and <=1.
+
+    Note: ``ss.time_prob()`` converts one cumulative hazard rate to another with a
+    different time unit. ``ss.rate_prob()`` converts an exponential rate to a cumulative
+    hazard rate.
+    """
+    def update_values(self):
+        v = self.v
+        if self.isarray:
+            self.values = v.copy()
+            inds = np.logical_and(0.0 < v, v < 1.0)
+            if inds.sum():
+                rates = -np.log(1 - v[inds])
+                self.values[inds] = 1 - np.exp(-rates/self.factor)
+            invalid = np.logical_or(v < 0.0, 1.0 < v)
+            if invalid.sum():
+                errormsg = f'Invalid value {self.v} for {self}: must be 0-1. If using in a calculation, use .values instead.'
+                raise ValueError(errormsg)
+        else:
+            if v == 0:
+                self.values = 0
+            elif v == 1:
+                self.values = 1
+            elif 0 <= v <= 1:
+                rate = -np.log(1 - v)
+                self.values = 1 - np.exp(-rate/self.factor)
+            else:
+                errormsg = f'Invalid value {self.v} for {self}: must be 0-1. If using in a calculation, use .values instead.'
+                raise ValueError(errormsg)
+        return self.values
+
+
+class rate_prob(TimePar):
+    """
+    An instantaneous rate converted to a probability; must be >=0.
+
+    Note: ``ss.time_prob()`` converts one cumulative hazard rate to another with a
+    different time unit. ``ss.rate_prob()`` converts an exponential rate to a cumulative
+    hazard rate.
+    """
+    def update_values(self):
+        v = self.v
+        if self.isarray:
+            self.values = v.copy()
+            inds = v > 0.0
+            if inds.sum():
+                self.values[inds] = 1 - np.exp(-v[inds]/self.factor)
+            invalid = v < 0.0
+            if invalid.sum():
+                errormsg = f'Invalid value {self.v} for {self}: must be >=0. If using in a calculation, use .values instead.'
+                raise ValueError(errormsg)
+        else:
+            if v == 0:
+                self.values = 0
+            elif v > 0:
+                self.values = 1 - np.exp(-v/self.factor)
+            else:
+                errormsg = f'Invalid value {self.value} for {self}: must be >=0. If using in a calculation, use .values instead.'
+                raise ValueError(errormsg)
+        return self.values
+
+
+class beta(time_prob):
+    """ A container for beta (i.e. the disease transmission rate) """
+    pass
+
+
+#%% Unit handling
+
+# Map different units onto the time units -- placed at the end to include the functions
+unit_mapping_reverse = {
+    None: [None],
+    'unitless': ['unitless', 'none'],
+    'day': ['d', 'day', 'days', 'perday', days, perday],
+    'year': ['y', 'yr', 'year', 'years', 'peryear', years, peryear],
+    'week': ['w', 'wk', 'week', 'weeks'],
+    'month': ['m', 'mo', 'month', 'months'],
+}
+unit_mapping = {v:k for k,vlist in unit_mapping_reverse.items() for v in vlist}
+
+
+def validate_unit(unit):
+    """ Check that the unit is valid, and convert to a standard type """
+    try:
+        unit = unit_mapping[unit]
+    except KeyError as E:
+        errormsg = f'Invalid unit "{unit}". Valid units are:\n{sc.pp(unit_mapping_reverse, output=True)}'
+        raise sc.KeyNotFoundError(errormsg) from E
+    return unit
+
+
+def is_unitless(unit):
+    """ Check if explicitly unitless (excludes None; use not has_units() for that) """
+    return unit in unit_mapping_reverse['unitless']
+
+
+def has_units(unit):
+    """ Check that the unit is valid and is not unitless or None """
+    unit = validate_unit(unit)
+    if unit is None:
+        return False
+    elif is_unitless(unit):
+        return False
+    else:
+        return True
diff --git a/starsim/utils.py b/starsim/utils.py
index 3ec4cd9..fc5972e 100644
--- a/starsim/utils.py
+++ b/starsim/utils.py
@@ -1,18 +1,19 @@
 """
 Numerical utilities
 """
-
 import warnings
 import numpy as np
-import sciris as sc
-import starsim as ss
 import numba as nb
 import pandas as pd
+import sciris as sc
+import matplotlib.pyplot as plt
+import starsim as ss
 
 # %% Helper functions
 
-# What functions are externally visible -- note, this gets populated in each section below
-__all__ = ['ndict', 'warn', 'unique', 'find_contacts']
+# What functions are externally visible
+__all__ = ['ndict', 'warn', 'find_contacts', 'set_seed', 'check_requires', 'standardize_netkey',
+           'standardize_data', 'validate_sim_data', 'return_fig']
 
 
 class ndict(sc.objdict):
@@ -40,7 +41,7 @@ class ndict(sc.objdict):
         self.setattribute('_overwrite', overwrite)
         self.extend(*args, **kwargs)
         return
-    
+
     def __call__(self):
         """ Shortcut for returning values """
         return self.values()
@@ -76,8 +77,8 @@ class ndict(sc.objdict):
         else:
             errormsg = f'Could not interpret argument {arg}: does not have expected attribute "{self._nameattr}"'
             raise TypeError(errormsg)
-        return
-    
+        return self
+
     def _check_key(self, key, overwrite=None):
         if overwrite is None: overwrite = self._overwrite
         if key in self:
@@ -88,11 +89,11 @@ class ndict(sc.objdict):
             else:
                 ss.warn(f'Overwriting existing ndict entry "{key}"')
         return
-    
+
     def _check_type(self, arg):
         """ Check types """
         if self._type is not None:
-            if not isinstance(arg, self._type):
+            if not isinstance(arg, self._type) and not isinstance(arg, ss.Module): # Module is a valid argument anywhere
                 errormsg = f'The following item does not have the expected type {self._type}:\n{arg}'
                 raise TypeError(errormsg)
         return
@@ -104,28 +105,35 @@ class ndict(sc.objdict):
             self.append(arg)
         for key, arg in kwargs.items():
             self.append(arg, key=key)
-        return
+        return self
+
+    def merge(self, other):
+        """ Merge another dictionary with this one """
+        for key, arg in other.items():
+            self.append(arg, key=key)
+        return self
 
     def copy(self):
+        """ Shallow copy """
         new = self.__class__.__new__(nameattr=self._nameattr, type=self._type, strict=self._strict)
         new.update(self)
         return new
 
-    def __add__(self, dict2):
+    def __add__(self, other):
         """ Allow c = a + b """
         new = self.copy()
-        if isinstance(dict2, list):
-            new.extend(dict2)
+        if isinstance(other, list):
+            new.extend(other)
         else:
-            new.append(dict2)
+            new.append(other)
         return new
 
-    def __iadd__(self, dict2):
+    def __iadd__(self, other):
         """ Allow a += b """
-        if isinstance(dict2, list):
-            self.extend(dict2)
+        if isinstance(other, list):
+            self.extend(other)
         else:
-            self.append(dict2)
+            self.append(other)
         return self
 
 
@@ -159,18 +167,6 @@ def warn(msg, category=None, verbose=None, die=None):
     return
 
 
-def unique(arr):
-    """
-    Find the unique elements and counts in an array.
-    Equivalent to np.unique(return_counts=True) but ~5x faster, and
-    only works for arrays of positive integers.
-    """
-    counts = np.bincount(arr.ravel())
-    unique = np.flatnonzero(counts)
-    counts = counts[unique]
-    return unique, counts
-
-
 def find_contacts(p1, p2, inds):  # pragma: no cover
     """
     Variation on Network.find_contacts() that avoids sorting.
@@ -189,9 +185,19 @@ def find_contacts(p1, p2, inds):  # pragma: no cover
     return pairing_partners
 
 
-# %% Seed methods
+def check_requires(sim, requires, *args):
+    """ Check that the module's requirements (of other modules) are met """
+    errs = sc.autolist()
+    all_classes = [m.__class__ for m in sim.modules]
+    all_names = [m.name for m in sim.modules]
+    for req in sc.mergelists(requires, *args):
+        if req not in all_classes + all_names:
+            errs += req
+    if len(errs):
+        errormsg = f'The following module(s) are required, but the Sim does not contain them: {sc.strjoin(errs)}'
+        raise AttributeError(errormsg)
+    return
 
-__all__ += ['set_seed']
 
 def set_seed(seed=None):
     '''
@@ -224,74 +230,172 @@ def set_seed(seed=None):
 
 # %% Data cleaning and processing
 
-__all__ += ['standardize_data']
+def standardize_netkey(key):
+    """ Networks can be upper or lowercase, and have a suffix 'net' or not; this function standardizes them """
+    return key.lower().removesuffix('net')
 
 
-def standardize_data(data=None, metadata=None, max_age=120, min_year=1800):
+def standardize_data(data=None, metadata=None, min_year=1800, out_of_range=0, default_age=0, default_year=2024):
     """
+    Standardize formats of input data
+
+    Input data can arrive in many different forms. This function accepts a variety of data
+    structures, and converts them into a Pandas Series containing one variable, based on
+    specified metadata, or an ``ss.Dist`` if the data is already an ``ss.Dist`` object.
+
+    The metadata is a dictionary that defines columns of the dataframe or keys
+    of the dictionary to use as indices in the output Series. It should contain:
+
+    - ``metadata['data_cols']['value']`` specifying the name of the column/key to draw values from
+    - ``metadata['data_cols']['year']`` optionally specifying the column containing year values; otherwise the default year will be used
+    - ``metadata['data_cols']['age']`` optionally specifying the column containing age values; otherwise the default age will be used
+    - ``metadata['data_cols'][<arbitrary>]`` optionally specifying any other columns to use as indices. These will form part of the multi-index for the standardized Series output.
+
+    If a ``sex`` column is part of the index, the metadata can also optionally specify a string mapping to convert
+    the sex labels in the input data into the 'm'/'f' labels used by Starsim. In that case, the metadata can contain
+    an additional key like ``metadata['sex_keys'] = {'Female':'f','Male':'m'}`` which in this case would map the strings
+    'Female' and 'Male' in the original data into 'm'/'f' for Starsim.
+
     Args:
-        data (pandas.DataFrame, pandas.Series, dict, int, float): An associative array  or a number, with the
-        input data to be standardized.
-        metadata (dict): The metadata containing information about the columns of the data.
-        max_age (float): The maximum age allowed in the data. Default is 120 years.
-        min_year (float): The minimum year allowed in the data. Default is 1800.
+        data (pandas.DataFrame, pandas.Series, dict, int, float): An associative array  or a number, with the input data to be standardized.
+        metadata (dict): Dictionary specifiying index columns, the value column, and optionally mapping for sex labels
+        min_year (float): Optionally specify a minimum year allowed in the data. Default is 1800.
+        out_of_range (float): Value to use for negative ages - typically 0 is a reasonable choice but other values (e.g., np.inf or np.nan) may be useful depending on the calculation. This will automatically be added to the dataframe with an age of ``-np.inf``
 
     Returns:
-        df (pandas.DataFrame or sciris.dataframe): The standardized data
 
-    Raises:
-        ValueError: If the columns in `data` do not match the column names in metadata.data_cols
-        or if the index of the data series is not understood.
+        - A `pd.Series` for all supported formats of `data` *except* an ``ss.Dist``. This series will contain index columns for 'year'
+          and 'age' (in that order) and then subsequent index columns for any other variables specified in the metadata, in the order
+          they appeared in the metadata (except for year and age appearing first).
+        - An ``ss.Dist`` instance - if the ``data`` input is an ``ss.Dist``, that same object will be returned by this function
     """
-    metadata = sc.objdict(metadata)
-
-    if isinstance(data, pd.DataFrame):
-        if not set(metadata.data_cols.values()).issubset(data.columns):
-            errormsg = 'Please ensure the columns of the data match the values in metadata.data_cols.'
-            raise ValueError(errormsg)
-        df = data
-
-    elif isinstance(data, pd.Series):
-        if metadata.data_cols.get('age'):
-            if (data.index <= max_age).all():  # Assume index is age bins
-                df = sc.dataframe({
-                    metadata.data_cols['year']: 2000,
-                    metadata.data_cols['age']: data.index.values,
-                    metadata.data_cols['value']: data.values,
-                })
-            elif (data.index >= min_year).all():  # Assume index year
-                df = sc.dataframe({
-                    metadata.data_cols['year']: data.index.values,
-                    metadata.data_cols['age']: 0,
-                    metadata.data_cols['value']: data.values,
-                })
+    # It's a format that can be used directly: return immediately
+    if sc.isnumber(data) or isinstance(data, (ss.Dist, ss.TimePar)):
+        return data
+
+    # Convert series and dataframe inputs into dicts
+    if isinstance(data, pd.Series) or isinstance(data, pd.DataFrame):
+        data = data.reset_index().to_dict(orient='list')
+
+    # Check that the input is now a dict (scalar types have already been handled above
+    assert isinstance(data, dict), 'Supported inputs are ss.Dict, scalar numbers, DataFrames, Series, or dictionaries'
+
+    # Extract the values and index columns
+    assert 'value' in metadata['data_cols'], 'The metadata is missing a column name for "value", which must be provided if the input data is in the form of a DataFrame, Series, or dict'
+    values = sc.promotetoarray(data[metadata['data_cols']['value']])
+    index = sc.objdict()
+    for k, col in metadata['data_cols'].items():
+        if k != 'value':
+            index[k] = data[col]
+
+    # Add defaults for year and age
+    if 'year' not in index:
+        index['year'] = np.full(values.shape, fill_value=default_year, dtype=ss.dtypes.float)
+    if 'age' not in index:
+        index['age'] = np.full(values.shape, fill_value=default_age, dtype=ss.dtypes.float)
+
+    # Reorder the index so that it starts with age first
+    index.insert(0, 'age', index.pop('age'))
+    index.insert(0, 'year', index.pop('year'))
+
+    # Map sex values
+    if 'sex' in index:
+        if 'sex_keys' in metadata:
+            index['sex'] = [metadata['sex_keys'][x] for x in index['sex']]
+        assert set(index['sex']) == {'f','m'}, 'If standardized data contains a "sex" column, it should use "m" and "f" to specify the sex.'
+
+    # Create the series
+    output = pd.Series(data=values, index=pd.MultiIndex.from_arrays(index.values(), names=index.keys()))
+
+    # Add an entry for negative ages
+    new_entries = output.index.set_codes([0] * len(output), level=1).set_levels([-np.inf], level=1).unique()
+    new = pd.Series(data=out_of_range, index=new_entries)
+    output = pd.concat([output, new])
+
+    # Truncate years
+    output = output.loc[output.index.get_level_values('year')>min_year]
+
+    # Perform a final sort to prevent "indexing past lexsort depth" warnings
+    output = output.sort_index()
+
+    return output
+
+
+def validate_sim_data(data=None, die=None):
+    """
+    Validate data intended to be compared to the sim outputs, e.g. for calibration
+
+    Args:
+        data (df/dict): a dataframe (or dict) of data, with a column "time" plus data columns of the form "module.result", e.g. "hiv.new_infections"
+        die (bool): whether to raise an exception if the data cannot be converted (default: die if data is not None but cannot be converted)
+
+    """
+    success = False
+    if data is not None:
+        # Try loading the data
+        try:
+            data = sc.dataframe(data) # Convert it to a dataframe
+            timecols = ['t', 'timevec', 'tvec', 'time', 'day', 'date', 'year'] # If a time column is supplied, use it as the index
+            found = False
+            for timecol in timecols:
+                if timecol in data.cols:
+                    if found:
+                        errormsg = f'Multiple time columns found: please ensure only one of {timecols} is present; you supplied {data.cols}.'
+                        raise ValueError(errormsg)
+                    data.set_index(timecol, inplace=True)
+                    found = True
+            success = True
+
+        # Data loading failed
+        except Exception as E:
+            errormsg = f'Failed to add data "{data}": expecting a dataframe-compatible object. Error:\n{E}'
+            if die == False:
+                print(errormsg)
             else:
-                errormsg = 'Could not understand index of data series: should be age (all values less than 120) or year (all values greater than 1900).'
                 raise ValueError(errormsg)
-        else:
-            df = sc.dataframe({
-                metadata.data_cols['year']: data.index.values,
-                metadata.data_cols['value']: data.values,
-            })
 
-        if metadata.data_cols.get('sex'):
-            df = pd.concat([df, df])
-            df[metadata.data_cols['sex']] = np.repeat(list(metadata.sex_keys.values()), len(data))
-
-    elif isinstance(data, dict):
-        if not set(metadata.data_cols.values()).issubset(data.keys()):
-            errormsg = 'Please ensure the keys of the data dict match the values in metadata.data_cols.'
-            raise ValueError(errormsg)
-        new_data = dict()
-        for sim_name, col_name in metadata.data_cols.items():
-            new_data[sim_name] = sc.tolist(data[col_name])
-        df = sc.dataframe(new_data)
-
-    elif sc.isnumber(data) or isinstance(data, ss.Dist):
-        df = data  # Just return it as-is
-
-    else:
-        errormsg = f'Data type {type(data)} not understood.'
+    # Validation
+    if not success and die == True:
+        errormsg = 'Data "{data}" could not be converted and die == True'
         raise ValueError(errormsg)
-        
-    return df
+
+    return data
+
+
+def combine_rands(a, b):
+    """
+    Efficient algorithm for combining two arrays of random integers into an array
+    of floats.
+
+    See ss.multi_random() for the user-facing version.
+
+    Args:
+        a (array): array of random integers between 0 and np.iinfo(np.uint64).max, as from ss.rand_raw()
+        b (array): ditto, same size as a
+
+    Returns:
+        A new array of random numbers the same size as a and b
+    """
+    c = np.bitwise_xor(a*b, a-b)
+    u = c / np.iinfo(np.uint64).max
+    return u
+
+
+#%% Other helper functions
+
+class shrink:
+    """ Define a class to indicate an object has been shrunken """
+    def __repr__(self):
+        s = 'This object has been intentionally "shrunken"; it is a placeholder and has no functionality. Use the non-shrunken object instead.'
+        return s
+
+
+def return_fig(fig, **kwargs):
+    """ Do postprocessing on the figure: by default, don't return if in Jupyter, but show instead """
+    is_jupyter = [False, True, sc.isjupyter()][ss.options.jupyter]
+    if is_jupyter:
+        print(fig)
+        plt.show()
+        return None
+    else:
+        return fig
\ No newline at end of file
diff --git a/starsim/version.py b/starsim/version.py
index 11c9f8e..99811c1 100644
--- a/starsim/version.py
+++ b/starsim/version.py
@@ -1,9 +1,9 @@
-'''
+"""
 Version and license information.
-'''
+"""
 
 __all__ = ['__version__', '__versiondate__', '__license__']
 
-__version__ = '0.5.2'
-__versiondate__ = '2024-06-04'
+__version__ = '2.1.1'
+__versiondate__ = '2024-11-8'
 __license__ = f'Starsim {__version__} ({__versiondate__}) — © 2023-2024 by IDM'
diff --git a/tests/baseline.json b/tests/baseline.json
index 43bc42f..0e7720a 100644
--- a/tests/baseline.json
+++ b/tests/baseline.json
@@ -1,26 +1,26 @@
 {
   "summary": {
-    "yearvec": 2010.1000000000026,
-    "births_new": 65.25490196078431,
-    "births_cumulative": 3262.4313725490197,
-    "births_cbr": 29.713410489238804,
-    "deaths_new": 44.68627450980392,
-    "deaths_cumulative": 2227.549019607843,
-    "deaths_cmr": 20.34315186671041,
-    "sir_n_susceptible": 2429.970588235294,
-    "sir_n_infected": 3579.8823529411766,
-    "sir_n_recovered": 4970.764705882353,
-    "sir_prevalence": 0.334889084274871,
-    "sir_new_infections": 128.2156862745098,
-    "sir_cum_infections": 13078.0,
-    "sis_n_susceptible": 3951.1960784313724,
-    "sis_n_infected": 7029.421568627451,
-    "sis_prevalence": 0.627871954232106,
-    "sis_new_infections": 209.7843137254902,
-    "sis_cum_infections": 21398.0,
-    "sis_rel_sus": 0.46047714966479397,
-    "n_alive": 10980.617647058823,
-    "new_deaths": 45.705882352941174,
-    "cum_deaths": 4625.0
+    "timevec": 2020.0,
+    "births_new": 46.84158415841584,
+    "births_cumulative": 2267.7425742574255,
+    "births_cbr": 19.93833106141367,
+    "deaths_new": 9.673267326732674,
+    "deaths_cumulative": 468.5742574257426,
+    "deaths_cmr": 4.118825151847284,
+    "sir_n_susceptible": 2440.029702970297,
+    "sir_n_infected": 3630.3960396039606,
+    "sir_n_recovered": 5676.693069306931,
+    "sir_prevalence": 0.32402568798505815,
+    "sir_new_infections": 122.34653465346534,
+    "sir_cum_infections": 12357.0,
+    "sis_n_susceptible": 4784.306930693069,
+    "sis_n_infected": 6973.504950495049,
+    "sis_prevalence": 0.5720906510271361,
+    "sis_new_infections": 193.5742574257426,
+    "sis_cum_infections": 19551.0,
+    "sis_rel_sus": 0.5019197711850157,
+    "n_alive": 11747.118811881188,
+    "new_deaths": 10.693069306930694,
+    "cum_deaths": 1072.0
   }
 }
\ No newline at end of file
diff --git a/tests/baseline_multisim.json b/tests/baseline_multisim.json
new file mode 100644
index 0000000..dfca24f
--- /dev/null
+++ b/tests/baseline_multisim.json
@@ -0,0 +1,112 @@
+{
+  "yearvec": {
+    "mean": 2010.1000000000026,
+    "std": 0.0,
+    "sem": 0.0
+  },
+  "births_new": {
+    "mean": 65.42156862745097,
+    "std": 0.1636403441859318,
+    "sem": 0.05174762047214366
+  },
+  "births_cumulative": {
+    "mean": 3268.022549019608,
+    "std": 7.404566545623425,
+    "sem": 2.3415295370455103
+  },
+  "births_cbr": {
+    "mean": 29.722512541939885,
+    "std": 0.006276951230389925,
+    "sem": 0.001984946264982848
+  },
+  "deaths_new": {
+    "mean": 44.380392156862754,
+    "std": 0.31770757109406206,
+    "sem": 0.10046795545371096
+  },
+  "deaths_cumulative": {
+    "mean": 2206.050980392157,
+    "std": 20.506215616069515,
+    "sem": 6.484634753729258
+  },
+  "deaths_cmr": {
+    "mean": 20.155330390777614,
+    "std": 0.14640525779385213,
+    "sem": 0.04629740760526911
+  },
+  "sir_n_susceptible": {
+    "mean": 2440.7539215686274,
+    "std": 28.746250762671917,
+    "sem": 9.090362660039563
+  },
+  "sir_n_infected": {
+    "mean": 3592.6529411764704,
+    "std": 15.832047055140144,
+    "sem": 5.006532871720426
+  },
+  "sir_n_recovered": {
+    "mean": 4971.801960784314,
+    "std": 31.176074975909064,
+    "sem": 9.858740542805167
+  },
+  "sir_prevalence": {
+    "mean": 0.33524628593554295,
+    "std": 0.0006949779189371683,
+    "sem": 0.0002197713147365318
+  },
+  "sir_new_infections": {
+    "mean": 128.78137254901958,
+    "std": 0.6174299338251982,
+    "sem": 0.19524848864546648
+  },
+  "sir_cum_infections": {
+    "mean": 13135.7,
+    "std": 62.97785325017042,
+    "sem": 19.915345841837645
+  },
+  "sis_n_susceptible": {
+    "mean": 4016.530392156862,
+    "std": 103.15173055519776,
+    "sem": 32.61944131424099
+  },
+  "sis_n_infected": {
+    "mean": 6988.678431372548,
+    "std": 112.41894818744964,
+    "sem": 35.54999284327985
+  },
+  "sis_prevalence": {
+    "mean": 0.622135221279589,
+    "std": 0.00994225067508044,
+    "sem": 0.003144015720160086
+  },
+  "sis_new_infections": {
+    "mean": 208.82450980392156,
+    "std": 2.531950580258016,
+    "sem": 0.8006730756600289
+  },
+  "sis_cum_infections": {
+    "mean": 21300.1,
+    "std": 258.2589591863175,
+    "sem": 81.6686537173229
+  },
+  "sis_rel_sus": {
+    "mean": 0.46661987224910195,
+    "std": 0.00995264046990363,
+    "sem": 0.003147301261766397
+  },
+  "n_alive": {
+    "mean": 11005.20882352941,
+    "std": 27.11539023756586,
+    "sem": 8.574639279500229
+  },
+  "new_deaths": {
+    "mean": 45.478431372549025,
+    "std": 0.3597865572558359,
+    "sem": 0.11377449924390214
+  },
+  "cum_deaths": {
+    "mean": 4589.7,
+    "std": 36.32093060481793,
+    "sem": 11.485686744814172
+  }
+}
\ No newline at end of file
diff --git a/tests/benchmark.json b/tests/benchmark.json
index aefe3c2..00f78bb 100644
--- a/tests/benchmark.json
+++ b/tests/benchmark.json
@@ -1,12 +1,12 @@
 {
   "time": {
-    "initialize": 0.015,
-    "run": 1.082
+    "initialize": 0.055,
+    "run": 1.013
   },
   "parameters": {
     "n_agents": 10000,
-    "n_years": 20,
+    "dur": 20,
     "dt": 0.2
   },
-  "cpu_performance": 0.9927627642937098
+  "cpu_performance": 0.9665005580733697
 }
\ No newline at end of file
diff --git a/tests/benchmark_full.py b/tests/benchmark_full.py
index 9cc54af..1286d8a 100644
--- a/tests/benchmark_full.py
+++ b/tests/benchmark_full.py
@@ -10,22 +10,22 @@ import starsim as ss
 repeats = 10
 n_agents = 100_000
 pars = sc.objdict(
-    n_years       = 100,        # Number of years to simulate
-    dt            = 0.5,        # Timestep
-    verbose       = 0,          # Don't print details of the run
+    dur     = 100, # Number of years to simulate
+    dt      = 0.5, # Timestep
+    verbose = 0,   # Don't print details of the run
 )
 
 def make_run_sim():
     """ Make and run a decent-sized default simulation """
     # Make the people
     ppl = ss.People(n_agents=n_agents)
-    
+
     # Make the components
-    sir = ss.SIR()
+    sir = ss.SIS()
     hiv = ss.HIV()
-    hiv.pars['beta'] = {'mf': [0.15, 0.10], 'maternal': [0.2, 0]}
-    networks = [ss.MFNet(), ss.MaternalNet()]
-    
+    hiv.pars['beta'] = {'mf': [0.15, 0.10], 'maternal': [0.2, 0], 'random': [0,0]}
+    networks = [ss.RandomNet(), ss.MFNet(), ss.MaternalNet()]
+
     # Make the sim
     sim = ss.Sim(pars=pars, people=ppl, networks=networks, demographics=ss.Pregnancy(), diseases=[sir, hiv])
 
@@ -36,10 +36,10 @@ def make_run_sim():
 
 
 if __name__ == '__main__':
-    
+
     T = sc.timer()
     for r in range(repeats):
         make_run_sim()
         T.tt(f'Trial {r+1}/{repeats}')
-        
+
     sc.heading(f'Average: {T.mean()*1000:0.0f} ± {T.std()/len(T)**0.5*1000:0.0f} ms')
\ No newline at end of file
diff --git a/tests/benchmark_simple.py b/tests/benchmark_simple.py
index 54e2a44..b1fdee7 100644
--- a/tests/benchmark_simple.py
+++ b/tests/benchmark_simple.py
@@ -1,5 +1,5 @@
 import sciris as sc
-import matplotlib.pyplot as pl
+import matplotlib.pyplot as plt
 import starsim as ss
 
 do_plot = False
@@ -10,11 +10,11 @@ with sc.timer():
 
     hiv = ss.HIV()
     hiv.pars['beta'] = {'simple_sexual': [0.0008, 0.0004], 'maternal': [0.2, 0]}
-    
-    sim = ss.Sim(start=1950, end=2050, people=ppl, networks=networks, demographics=ss.Pregnancy(), diseases=hiv)
-    sim.initialize()
+
+    sim = ss.Sim(start=1950, stop=2050, people=ppl, networks=networks, demographics=ss.Pregnancy(), diseases=hiv)
+    sim.init()
     sim.run()
 
 if do_plot:
-    pl.plot(sim.tivec, sim.results.hiv.n_infected)
-    pl.show()
+    plt.plot(sim.tivec, sim.results.hiv.n_infected)
+    plt.show()
diff --git a/tests/check_style b/tests/check_style
new file mode 100755
index 0000000..cd6b417
--- /dev/null
+++ b/tests/check_style
@@ -0,0 +1,12 @@
+#!/bin/bash
+# Check code quality by running pylint
+
+echo 'Running pylint...'
+cd ..
+start=$(date +%s)
+pylint starsim | tee tests/pylint_report.txt
+end=$(date +%s)
+
+echo 
+echo "Took $(($end - $start)) s; output saved to:"
+echo "pylint_report.txt"
diff --git a/tests/devtests/devtest_dem_data.py b/tests/devtests/devtest_dem_data.py
index 95dc3c1..7589211 100644
--- a/tests/devtests/devtest_dem_data.py
+++ b/tests/devtests/devtest_dem_data.py
@@ -30,7 +30,7 @@ def test_series_death_rate():
     ppl = ss.People(1000)
     death_rate = ss.standardize_data(data=series_death, metadata=ss.omerge({
         'data_cols': {'year': 'Time', 'sex': 'Sex', 'age': 'AgeGrpStart', 'value': 'mx'},
-        'sex_keys': {'f': 'Female', 'm': 'Male'},
+        'sex_keys': {'Female':'f', 'Male':'m'},
     }))
     bdm2 = ss.Deaths(pars={'death_rate': death_rate})
     sim2 = ss.Sim(people=ppl, demographics=bdm2, label='Using age-specific data from a pandas series')
diff --git a/tests/devtests/devtest_rngtrans.py b/tests/devtests/devtest_rngtrans.py
new file mode 100644
index 0000000..2d3c6ac
--- /dev/null
+++ b/tests/devtests/devtest_rngtrans.py
@@ -0,0 +1,166 @@
+import networkx as nx
+import numpy as np
+import matplotlib.pyplot as plt
+import pandas as pd
+import seaborn as sns
+from pandas.util import hash_pandas_object
+import hashlib
+import sciris as sc
+
+from starsim.utils import combine_rands
+
+import warnings
+warnings.filterwarnings("ignore", "overflow encountered in scalar subtract")
+warnings.filterwarnings("ignore", "overflow encountered in scalar multiply")
+ 
+n = 8 # Number of nodes
+n_sources = 2 # Number of sources (seed infections)
+reps = 1_000_000
+edge_prob = 0.7 # Edge probability
+trans_prob = 0.4
+seed = 1
+
+def hash(df):
+    #return int(hashlib.sha256(hash_pandas_object(df, index=True).values).hexdigest(), 16)
+    return hashlib.sha256(hash_pandas_object(df, index=True).values).hexdigest()[:6]
+
+def random(G):
+    src = nx.get_node_attributes(G, 'infected')
+    infected = []
+    tx = []
+
+    # Randomize in case a node is infected multiple times
+    el = list(G.edges())
+    np.random.shuffle(el)
+
+    for (n1,n2) in el:
+        # n1 --> n2
+        if src[n1] and (not src[n2]) and (n2 not in infected) and (np.random.rand() < trans_prob):
+            tx.append((n1, n2))
+            infected.append(n2)
+        # n2 --> n1
+        if src[n2] and (not src[n1]) and (n1 not in infected) and (np.random.rand() < trans_prob):
+            tx.append((n2, n1))
+            infected.append(n1)
+    return tx
+
+
+def modulo(G):
+    src = nx.get_node_attributes(G, 'infected')
+    infected = []
+    tx = []
+    r1 = np.random.rand(n)
+    r2 = np.random.rand(n)
+    el = list(G.edges())
+    np.random.shuffle(el)
+    for (n1,n2) in el:
+        # n1 --> n2
+        if (src[n1]) and (not src[n2]) and (n2 not in infected) and (((r1[n1]+r2[n2])%1) < trans_prob):
+            tx.append((n1, n2))
+            infected.append(n2)
+        # n2 --> n1
+        if (src[n2]) and (not src[n1]) and (n1 not in infected) and (((r1[n2]+r2[n1])%1) < trans_prob):
+            tx.append((n2, n1))
+            infected.append(n1)
+    return tx
+
+
+def combine_hash(G):
+    src = nx.get_node_attributes(G, 'infected')
+    infected = []
+    tx = []
+    el = list(G.edges())
+    r1 = np.random.randint(low=0, high=np.iinfo(np.uint64).max, dtype=np.uint64, size=n)
+    r2 = np.random.randint(low=0, high=np.iinfo(np.uint64).max, dtype=np.uint64, size=n)
+    np.random.shuffle(el)
+    for (n1,n2) in el:
+        # n1 --> n2
+        r = combine_rands(r1[n1], r2[n2])
+        if (src[n1]) and (not src[n2]) and (n2 not in infected) and (r < trans_prob):
+            tx.append((n1, n2))
+            infected.append(n2)
+        # n2 --> n1
+        r = combine_rands(r1[n2], r2[n1])
+        if (src[n2]) and (not src[n1]) and (n1 not in infected) and (r < trans_prob):
+            tx.append((n2, n1))
+            infected.append(n1)
+    return tx
+
+def roulette(G):
+    src = nx.get_node_attributes(G, 'infected')
+    tx = []
+    for n2 in G.nodes():
+        # All nodes --> n2
+        if not src[n2]:
+            srcs = [n for n in G.neighbors(n2) if src[n]] #[src[n] for n in G.neighbors(n2)] # Count infected neighbors
+            cnt = len(srcs)
+            if np.random.rand() < 1-(1-trans_prob)**cnt:
+                n1 = np.random.choice(srcs)
+                tx.append((n1, n2))
+    return tx
+ 
+
+def transmit(G, trans_fn):
+    # Align transmissions from tx_in if provided
+    txs = {}
+    counts = {}
+ 
+    for _ in np.arange(reps):
+        txl = trans_fn(G)
+        tx = pd.DataFrame(txl, columns=['src', 'dst']).sort_values(['src', 'dst']).reset_index(drop=True)
+        
+        h = hash(tx)
+
+        if h not in txs:
+            txs[h] = tx
+
+        counts[h] = counts.get(h, 0) + 1
+
+    df = pd.DataFrame(counts.values(), index=pd.Index(counts.keys(), name='Hash'), columns=['Counts'])
+    return txs, df
+
+
+# Build the graph
+G = nx.random_graphs.erdos_renyi_graph(n=n, p=edge_prob, seed=seed)
+
+# Seed infections
+infected = {i:False for i in range(n)}
+sources = np.random.choice(a=range(n), size=n_sources, replace=False)
+for source in sources:
+    infected[source] = True
+nx.set_node_attributes(G, infected, 'infected')
+ 
+# Do transmissions via each method in parallel
+results = sc.parallelize(transmit, iterkwargs=[{'trans_fn':random}, {'trans_fn':modulo}, {'trans_fn':combine_hash}, {'trans_fn':roulette}], kwargs={'G':G}, die=True, serial=False)
+tx, cnt = zip(*results)
+
+df = pd.concat(cnt, axis=1) \
+    .fillna(0) \
+    .astype(int)
+df.columns = ['Random', 'Modulo', 'CombineHash', 'Roulette']
+
+# Manipulate results
+df.reset_index(inplace=True)
+dfm = df.melt(id_vars='Hash', var_name='Method', value_name='Count')
+
+# Plot
+g = sns.barplot(data=dfm, x='Hash', y='Count', hue='Method')
+plt.xticks(rotation=90)
+g.figure.tight_layout()
+
+txc = tx[0].copy()
+for i in range(1, len(tx)):
+    txc.update(tx[i])
+for h, v in txc.items():
+    print(f'\nUnique transmission tree #{h}')
+    print(v)
+
+plt.figure()
+pos = nx.spring_layout(G, seed=3113794652)  # positions for all nodes
+ec = nx.draw_networkx_edges(G, pos, alpha=0.2)
+colors = ['red' if infected else 'blue' for infected in nx.get_node_attributes(G, 'infected').values()]
+nc = nx.draw_networkx_nodes(G, pos, nodelist=G.nodes(), node_color=colors, node_size=100)
+nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)
+nx.draw_networkx_labels(G, pos)
+
+plt.show()
\ No newline at end of file
diff --git a/tests/multisim_baseline.py b/tests/multisim_baseline.py
new file mode 100755
index 0000000..ede2f48
--- /dev/null
+++ b/tests/multisim_baseline.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+
+"""
+Run this script to save or check the multisim baseline.
+
+You can supply command line arguments for "save" and "n_runs" as integers, e.g.
+    ./multisim_baseline.py 0 20
+"""
+
+import sys
+import test_baselines
+
+save = False
+n_runs = 10
+
+if len(sys.argv) > 1:
+    save = int(sys.argv[1])
+    assert save in [0,1] # Avoid confusing with n_runs
+if len(sys.argv) > 2:
+    n_runs = int(sys.argv[2])
+
+test_baselines.multisim_baseline(save, n_runs)
diff --git a/tests/profile_sim.py b/tests/profile_sim.py
new file mode 100644
index 0000000..95051fa
--- /dev/null
+++ b/tests/profile_sim.py
@@ -0,0 +1,21 @@
+import sciris as sc
+import starsim as ss
+
+kw = dict(n_agents=10e3, start=2000, dur=100, diseases='sis', networks='random', demographics=True)
+sim = ss.Sim(**kw)
+
+prof = ['profile', 'cprofile', 'time'][1]
+
+if prof == 'profile':
+    prf = sc.profile(run=sim.run, follow=[sim.run])
+
+elif prof == 'cprofile':
+    cprf = sc.cprofile(sort='selfpct', mintime=1e-3, maxitems=None, maxfunclen=None, maxpathlen=None)
+    with cprf:
+        sim.run()
+
+else:
+    with sc.timer() as T:
+        sim.run()
+
+sim.loop.plot_cpu()
\ No newline at end of file
diff --git a/tests/quick_benchmark b/tests/quick_benchmark
new file mode 100755
index 0000000..a41c899
--- /dev/null
+++ b/tests/quick_benchmark
@@ -0,0 +1,8 @@
+#!/usr/bin/env python3
+"""
+Quickly check the performance benchmark
+"""
+
+import test_baselines
+
+test_baselines.test_benchmark(do_save=False, repeats=5)
diff --git a/tests/requirements.txt b/tests/requirements.txt
index fce2743..a2bea3c 100644
--- a/tests/requirements.txt
+++ b/tests/requirements.txt
@@ -1,4 +1,5 @@
 pytest>=7.3
 pytest-cov
 pytest-env
-pytest-xdist
\ No newline at end of file
+pytest-xdist
+optuna
\ No newline at end of file
diff --git a/tests/test_baselines.py b/tests/test_baselines.py
index 45f8714..b51d2ea 100644
--- a/tests/test_baselines.py
+++ b/tests/test_baselines.py
@@ -8,30 +8,31 @@ import sciris as sc
 import starsim as ss
 
 baseline_filename  = sc.thisdir(__file__, 'baseline.json')
+multisim_filename  = sc.thisdir(__file__, 'baseline_multisim.json')
 benchmark_filename = sc.thisdir(__file__, 'benchmark.json')
 parameters_filename = sc.thisdir(ss.__file__, 'regression', f'pars_v{ss.__version__}.json')
 sc.options(interactive=False) # Assume not running interactively
 
 # Define the parameters
 pars = sc.objdict(
-    n_agents   = 10e3, # Number of agents
-    start      = 2000, # Starting year
-    n_years    = 20,   # Number of years to simulate
-    dt         = 0.2,  # Timestep
-    verbose    = 0,    # Don't print details of the run
-    rand_seed  = 2,    # Set a non-default seed
+    n_agents  = 10e3, # Number of agents
+    start     = 2000, # Starting year
+    dur       = 20,   # Number of years to simulate
+    dt        = 0.2,  # Timestep
+    verbose   = 0,    # Don't print details of the run
+    rand_seed = 2,    # Set a non-default seed
 )
 
 
-def make_sim(run=False):
+def make_sim(run=False, **kwargs):
     """
-    Define a default simulation for testing the baseline. If run directly (not 
+    Define a default simulation for testing the baseline. If run directly (not
     via pytest), also plot the sim by default.
     """
     diseases = ['sir', 'sis']
     networks = ['random', 'mf', 'maternal']
-    sim = ss.Sim(pars=pars, networks=networks, diseases=diseases, demographics=True)
-    
+    sim = ss.Sim(pars=pars | kwargs, networks=networks, diseases=diseases, demographics=True)
+
     # Optionally run and plot
     if run:
         sim.run()
@@ -53,17 +54,42 @@ def save_baseline():
 
     # Export results
     sim.to_json(filename=baseline_filename, keys='summary')
-    
-    # CK: To restore once export_pars is fixed
-    # sim.export_pars(filename=parameters_filename) # If not different from previous version, can safely delete
+
+    # Save parameters
+    sim.to_json(filename=parameters_filename, keys='pars') # If not different from previous version, can safely delete
 
     print('Done.')
     return
 
 
+def multisim_baseline(save=False, n_runs=10, **kwargs):
+    """
+    Check or update the multisim baseline results; not part of the integration tests
+    """
+    word = 'Saving' if save else 'Checking'
+    sc.heading(f'{word} MultiSim baseline...')
+
+    # Make and run sims
+    kwargs.setdefault('verbose', ss.options.verbose/n_runs*2)
+    sim = make_sim(**kwargs)
+    msim = ss.MultiSim(base_sim=sim)
+    msim.run(n_runs)
+    summary = msim.summarize()
+
+    # Export results
+    if save:
+        sc.savejson(multisim_filename, summary)
+        print('Done.')
+    else:
+        baseline = sc.loadjson(multisim_filename)
+        ss.diff_sims(baseline, summary, die=False)
+
+    return
+
+
 def test_baseline():
     """ Compare the current default sim against the saved baseline """
-    
+
     # Load existing baseline
     baseline = sc.loadjson(baseline_filename)
     old = baseline['summary']
@@ -80,7 +106,7 @@ def test_baseline():
 
 def test_benchmark(do_save=False, repeats=1, verbose=True):
     """ Compare benchmark performance """
-    
+
     if verbose: print('Running benchmark...')
     try:
         previous = sc.loadjson(benchmark_filename)
@@ -115,13 +141,13 @@ def test_benchmark(do_save=False, repeats=1, verbose=True):
 
     # Do the actual benchmarking
     for r in range(repeats):
-        
+
         print(f'Repeat {r}')
-        
+
         # Time initialization
         t0 = sc.tic()
         sim = make_sim()
-        sim.initialize()
+        sim.init()
         t_init = sc.toc(t0, output=True)
 
         # Time running
@@ -147,7 +173,7 @@ def test_benchmark(do_save=False, repeats=1, verbose=True):
                 },
             'parameters': {
                 'n_agents': sim.pars.n_agents,
-                'n_years':  sim.pars.n_years,
+                'dur':      sim.pars.dur,
                 'dt':       sim.pars.dt,
                 },
             'cpu_performance': ratio,
diff --git a/tests/test_calibration.py b/tests/test_calibration.py
new file mode 100644
index 0000000..2d89ebb
--- /dev/null
+++ b/tests/test_calibration.py
@@ -0,0 +1,146 @@
+"""
+Test calibration
+"""
+
+#%% Imports and settings
+import sciris as sc
+import starsim as ss
+
+do_plot = 1
+do_save = 0
+n_agents = 2e3
+
+
+#%% Helper functions
+
+def make_sim():
+    hiv = ss.HIV(
+        beta = {'random': [0.01]*2, 'maternal': [1, 0]},
+        init_prev = 0.15,
+    )
+    pregnancy = ss.Pregnancy(fertility_rate=20)
+    death = ss.Deaths(death_rate=10)
+    random = ss.RandomNet(n_contacts=4)
+    maternal = ss.MaternalNet()
+
+    sim = ss.Sim(
+        dt = 1,
+        n_agents = n_agents,
+        total_pop = 9980999,
+        start = 1990,
+        dur = 40,
+        diseases = [hiv],
+        networks = [random, maternal],
+        demographics = [pregnancy, death],
+    )
+
+    return sim
+
+
+def make_data():
+    """ Define the calibration target data """
+    target_data = [
+    ['time', 'n_alive', 'hiv.prevalence', 'hiv.n_infected', 'hiv.new_infections', 'hiv.new_deaths'],
+    [  1990,  10432409,        0.0699742,          730000 ,               210000,           25000],
+    [  1991,  10681008,        0.0851979,          910000 ,               220000,           33000],
+    [  1992,  10900511,        0.1009127,          1100000,               220000,           43000],
+    [  1993,  11092775,        0.1081785,          1200000,               210000,           53000],
+    [  1994,  11261752,        0.1154349,          1300000,               200000,           63000],
+    [  1995,  11410721,        0.1226916,          1400000,               180000,           74000],
+    [  1996,  11541215,        0.1299689,          1500000,               160000,           84000],
+    [  1997,  11653254,        0.1287194,          1500000,               150000,           94000],
+    [  1998,  11747079,        0.1362040,          1600000,               140000,           100000],
+    [  1999,  11822722,        0.1353326,          1600000,               130000,           110000],
+    [  2000,  11881482,        0.1346633,          1600000,               120000,           120000],
+    [  2001,  11923906,        0.1341842,          1600000,               110000,           130000],
+    [  2002,  11954293,        0.1254779,          1500000,               100000,           130000],
+    [  2003,  11982219,        0.1251854,          1500000,               94000 ,           130000],
+    [  2004,  12019911,        0.1164734,          1400000,               89000 ,           120000],
+    [  2005,  12076697,        0.1159257,          1400000,               83000 ,           120000],
+    [  2006,  12155496,        0.1069475,          1300000,               78000 ,           110000],
+    [  2007,  12255920,        0.1060711,          1300000,               74000 ,           93000],
+    [  2008,  12379553,        0.1050118,          1300000,               69000 ,           80000],
+    [  2009,  12526964,        0.0957933,          1200000,               65000 ,           68000],
+    [  2010,  12697728,        0.0945050,          1200000,               62000 ,           54000],
+    [  2011,  12894323,        0.0930642,          1200000,               56000 ,           42000],
+    [  2012,  13115149,        0.0914972,          1200000,               49000 ,           34000],
+    [  2013,  13350378,        0.0973755,          1300000,               47000 ,           28000],
+    [  2014,  13586710,        0.0956817,          1300000,               45000 ,           25000],
+    [  2015,  13814642,        0.0941030,          1300000,               44000 ,           24000],
+    [  2016,  14030338,        0.0926563,          1300000,               43000 ,           23000],
+    [  2017,  14236599,        0.0913139,          1300000,               34000 ,           23000],
+    [  2018,  14438812,        0.0900351,          1300000,               27000 ,           22000],
+    [  2019,  14645473,        0.0920401,          1347971,               23000 ,           None],
+    [  2020,  14862927,        0.0874659,          1300000,               20000 ,           None],
+    [  2021,  15085870,        0.0861733,          1300000,               19000 ,           None],
+    [  2022,  15312158,        0.0848998,          1300000,               17000 ,           None],
+    ]
+    df = sc.dataframe(target_data[1:], columns=target_data[0])
+    return df
+
+#%% Define the tests
+
+def test_calibration(do_plot=False):
+    sc.heading('Testing calibration')
+
+    # Define the calibration parameters
+    calib_pars = dict(
+        init_prev = dict(low=0.01, high=0.30, guess=0.15, path=('diseases', 'hiv', 'init_prev')),
+        n_contacts = dict(low=2, high=10, guess=4, path=('networks', 'randomnet', 'n_contacts')),
+    )
+
+    # Make the sim and data
+    sim = make_sim()
+    data = make_data()
+
+    # Define weights for the data
+    weights = {
+        'n_alive':            1.0,
+        'hiv.prevalence':     1.0,
+        'hiv.n_infected':     1.0,
+        'hiv.new_infections': 1.0,
+        'hiv.new_deaths':     1.0,
+    }
+
+    # Make the calibration
+    calib = ss.Calibration(
+        calib_pars = calib_pars,
+        sim = sim,
+        data = data,
+        weights = weights,
+        total_trials = 8,
+        n_workers = 2,
+        die = True,
+        debug = False,
+    )
+
+    # Perform the calibration
+    sc.printcyan('\nPeforming calibration...')
+    calib.calibrate(confirm_fit=False)
+
+    # Confirm
+    sc.printcyan('\nConfirming fit...')
+    calib.confirm_fit()
+    print(f'Fit with original pars: {calib.before_fit:n}')
+    print(f'Fit with best-fit pars: {calib.after_fit:n}')
+    if calib.after_fit <= calib.before_fit:
+        print('✓ Calibration improved fit')
+    else:
+        print('✗ Calibration did not improve fit, but this sometimes happens stochastically and is not necessarily an error')
+
+    if do_plot:
+        calib.plot_sims()
+        calib.plot_trend()
+
+    return sim, calib
+
+
+#%% Run as a script
+if __name__ == '__main__':
+
+    T = sc.timer()
+    do_plot = True
+
+    sim, calib = test_calibration(do_plot=do_plot)
+
+    T.toc()
diff --git a/tests/test_demographics.py b/tests/test_demographics.py
index bdfdd3d..4e81a3d 100644
--- a/tests/test_demographics.py
+++ b/tests/test_demographics.py
@@ -1,8 +1,6 @@
 """
 Test demographic consistency
 """
-
-# %% Imports and settings
 import starsim as ss
 import pandas as pd
 import matplotlib.pyplot as plt
@@ -10,11 +8,11 @@ import numpy as np
 import sciris as sc
 import pytest
 
-
 sc.options(interactive=False) # Assume not running interactively
+datadir = ss.root / 'tests/test_data'
 
 
-def test_nigeria(which='births', dt=1, start=1995, n_years=15, do_plot=False):
+def test_nigeria(which='births', dt=1, start=1995, dur=15, do_plot=False):
     """
     Make a Nigeria sim with demographic modules
     Switch between which='births' or 'pregnancy' to determine which demographic module to use
@@ -25,36 +23,36 @@ def test_nigeria(which='births', dt=1, start=1995, n_years=15, do_plot=False):
     demographics = sc.autolist()
 
     if which == 'births':
-        birth_rates = pd.read_csv(ss.root / 'tests/test_data/nigeria_births.csv')
+        birth_rates = pd.read_csv(datadir/'nigeria_births.csv')
         births = ss.Births(pars={'birth_rate': birth_rates})
         demographics += births
 
     elif which == 'pregnancy':
-        fertility_rates = pd.read_csv(ss.root / 'tests/test_data/nigeria_asfr.csv')
+        fertility_rates = pd.read_csv(datadir/'nigeria_asfr.csv')
         pregnancy = ss.Pregnancy(pars={'fertility_rate': fertility_rates, 'rel_fertility': 1})  # 4/3
         demographics += pregnancy
 
-    death_rates = pd.read_csv(ss.root / 'tests/test_data/nigeria_deaths.csv')
-    death = ss.Deaths(pars={'death_rate': death_rates, 'units': 1})
+    death_rates = pd.read_csv(datadir/'nigeria_deaths.csv')
+    death = ss.Deaths(pars={'death_rate': death_rates, 'rate_units': 1})
     demographics += death
 
     # Make people
     n_agents = 5_000
     nga_pop_1995 = 106819805
-    age_data = pd.read_csv(ss.root / 'tests/test_data/nigeria_age.csv')
+    age_data = pd.read_csv(datadir/'nigeria_age.csv')
     ppl = ss.People(n_agents, age_data=age_data)
 
     sim = ss.Sim(
         dt=dt,
         total_pop=nga_pop_1995,
         start=start,
-        n_years=n_years,
+        dur=dur,
         people=ppl,
         demographics=demographics,
     )
 
     if do_plot:
-        sim.initialize()
+        sim.init()
         # Plot histograms of the age distributions - simulated vs data
         bins = np.arange(0, 101, 1)
         init_scale = nga_pop_1995 / n_agents
@@ -65,15 +63,15 @@ def test_nigeria(which='births', dt=1, start=1995, n_years=15, do_plot=False):
 
     sim.run()
 
-    end = start + n_years
-    nigeria_popsize = pd.read_csv(ss.root / 'tests/test_data/nigeria_popsize.csv')
-    data = nigeria_popsize[(nigeria_popsize.year >= start) & (nigeria_popsize.year <= end)]
+    stop = start + dur
+    nigeria_popsize = pd.read_csv(datadir/'nigeria_popsize.csv')
+    data = nigeria_popsize[(nigeria_popsize.year >= start) & (nigeria_popsize.year <= stop)]
 
-    nigeria_cbr = pd.read_csv(ss.root / 'tests/test_data/nigeria_births.csv')
-    cbr_data = nigeria_cbr[(nigeria_cbr.Year >= start) & (nigeria_cbr.Year <= end)]
+    nigeria_cbr = pd.read_csv(datadir/'nigeria_births.csv')
+    cbr_data = nigeria_cbr[(nigeria_cbr.Year >= start) & (nigeria_cbr.Year <= stop)]
 
-    nigeria_cmr = pd.read_csv(ss.root / 'tests/test_data/nigeria_cmr.csv')
-    cmr_data = nigeria_cmr[(nigeria_cmr.Year >= start) & (nigeria_cmr.Year <= end)]
+    nigeria_cmr = pd.read_csv(datadir/'nigeria_cmr.csv')
+    cmr_data = nigeria_cmr[(nigeria_cmr.Year >= start) & (nigeria_cmr.Year <= stop)]
 
     # Tests
     if which == 'pregnancy':
@@ -87,34 +85,36 @@ def test_nigeria(which='births', dt=1, start=1995, n_years=15, do_plot=False):
             assert np.array_equal(sim.results.pregnancy.pregnancies, sim.results.pregnancy.births)
             print('✓ (births == pregnancies)')
 
-    print("Check final pop size within 5% of data")
-    assert np.isclose(data.n_alive.values[-1], sim.results.n_alive[-1], rtol=0.05)
+    rtol = 0.05
+    print(f'Check final pop size within {rtol*100:n}% of data')
+    assert np.isclose(data.n_alive.values[-1], sim.results.n_alive[-1], rtol=rtol), f'Final population size not within {rtol*100:n}% of data'
     print(f'✓ (simulated/data={sim.results.n_alive[-1] / data.n_alive.values[-1]:.2f})')
 
     # Plots
     if do_plot:
+        tvec = sim.timevec
         fig, ax = plt.subplots(2, 2)
         ax = ax.ravel()
         ax[0].scatter(data.year, data.n_alive, alpha=0.5)
-        ax[0].plot(sim.yearvec, sim.results.n_alive, color='k')
+        ax[0].plot(tvec, sim.results.n_alive, color='k')
         ax[0].set_title('Population')
 
-        ax[1].plot(sim.yearvec, 1000 * sim.results.deaths.cmr / dt, label='Simulated CMR')
+        ax[1].plot(tvec, 1000 * sim.results.deaths.cmr, label='Simulated CMR')
         ax[1].scatter(cmr_data.Year, cmr_data.CMR, label='Data CMR')
         ax[1].set_title('CMR')
         ax[1].legend()
 
         if which == 'births':
-            ax[2].plot(sim.yearvec, sim.results.births.cbr / dt, label='Simulated CBR')
+            ax[2].plot(tvec, sim.results.births.cbr, label='Simulated CBR')
         elif which == 'pregnancy':
-            ax[2].plot(sim.yearvec, sim.results.pregnancy.cbr / dt, label='Simulated CBR')
+            ax[2].plot(tvec, sim.results.pregnancy.cbr, label='Simulated CBR')
         ax[2].scatter(cbr_data.Year, cbr_data.CBR, label='Data CBR')
         ax[2].set_title('CBR')
         ax[2].legend()
 
         if which == 'pregnancy':
-            ax[3].plot(sim.yearvec, sim.results.pregnancy.pregnancies / dt, label='Pregnancies')
-            ax[3].plot(sim.yearvec, sim.results.pregnancy.births / dt, label='Births')
+            ax[3].plot(tvec, sim.results.pregnancy.pregnancies, label='Pregnancies')
+            ax[3].plot(tvec, sim.results.pregnancy.births, label='Births')
             ax[3].set_title('Pregnancies and births')
             ax[3].legend()
 
@@ -126,7 +126,7 @@ def test_nigeria(which='births', dt=1, start=1995, n_years=15, do_plot=False):
 def test_constant_pop(do_plot=False):
     """ Test pars for constant pop size """
     sc.heading('Testing constant population size')
-    sim = ss.Sim(n_agents=10e3, birth_rate=10, death_rate=10/1010*1000, n_years=200, rand_seed=1).run()
+    sim = ss.Sim(n_agents=10e3, birth_rate=10, death_rate=10/1010*1000, dur=200, rand_seed=1).run()
     print("Check final pop size within 5% of starting pop")
     assert np.isclose(sim.results.n_alive[0], sim.results.n_alive[-1], rtol=0.05)
     print(f'✓ (final pop / starting pop={sim.results.n_alive[-1] / sim.results.n_alive[0]:.2f})')
@@ -143,7 +143,7 @@ def test_module_adding():
     births = ss.Births(pars={'birth_rate': 10})
     deaths = ss.Deaths(pars={'death_rate': 10})
     demographics = [births, deaths]
-    with pytest.raises(Exception): # CK: should be ValueError, but that fails for now, and this is OK
+    with pytest.raises(ValueError):
         ss.Sim(n_agents=1e3, demographics=demographics, birth_rate=10, death_rate=10).run()
     return demographics
 
@@ -152,27 +152,27 @@ def test_aging():
     """ Test that aging is configured properly """
     sc.heading('Testing aging')
     n_agents = int(1e3)
-    
+
     # With no demograhpics, people shouldn't age
-    s1 = ss.Sim(n_agents=n_agents).initialize()
+    s1 = ss.Sim(n_agents=n_agents).init()
     orig_ages = s1.people.age.raw.copy()
     orig_age = orig_ages.mean()
     s1.run()
     end_age = s1.people.age.mean()
     assert orig_age == end_age, f'By default there should be no aging, but {orig_age} != {end_age}'
-    
+
     # We should be able to manually turn on aging
     s2 = ss.Sim(n_agents=n_agents, use_aging=True).run()
     age2 = s2.people.age.mean()
     assert orig_age < age2, f'With aging, start age {orig_age} should be less than end age {age2}'
-    
+
     # Aging should turn on automatically if we add demographics
     s3 = ss.Sim(n_agents=n_agents, demographics=True).run()
     agent = s3.people.auids[0] # Find first alive agent
     orig_agent_age = orig_ages[agent]
     age3 = s3.people.age[ss.uids(agent)]
     assert orig_agent_age < age3, f'With demographics, original agent age {orig_agent_age} should be less than end age {age3}'
-    
+
     # ...but can be turned off manually
     s4 = ss.Sim(n_agents=n_agents, demographics=True, use_aging=False).run()
     agent = s4.people.auids[0] # Find first alive agent
diff --git a/tests/test_diseases.py b/tests/test_diseases.py
index c88579f..3ba2c4e 100644
--- a/tests/test_diseases.py
+++ b/tests/test_diseases.py
@@ -10,10 +10,12 @@ import matplotlib.pyplot as plt
 test_run = True
 n_agents = [10_000, 2_000][test_run]
 do_plot = False
-sc.options(interactive=False) # Assume not running interactively
+sc.options(interactive=do_plot) # Assume not running interactively
 
 
 def test_sir():
+    sc.heading('Testing SIR dynamics')
+
     ppl = ss.People(n_agents)
     network_pars = {
         'n_contacts': ss.poisson(4), # Contacts Poisson distributed with a mean of 4
@@ -26,7 +28,7 @@ def test_sir():
     sir = ss.SIR(sir_pars)
 
     # Change pars after creating the SIR instance
-    sir.pars.beta = {'random': 0.1}
+    sir.pars.beta = {'random': ss.rate(0.1)}
 
     # You can also change the parameters of the default lognormal distribution directly
     sir.pars.dur_inf.set(loc=5)
@@ -40,7 +42,7 @@ def test_sir():
     plt.figure()
     res = sim.results
     plt.stackplot(
-        sim.yearvec,
+        sim.timevec,
         res.sir.n_susceptible,
         res.sir.n_infected,
         res.sir.n_recovered,
@@ -54,7 +56,7 @@ def test_sir():
 
 def test_sir_epi():
     sc.heading('Test basic epi dynamics')
-    
+
     base_pars = dict(n_agents=n_agents, networks=dict(type='random'), diseases=dict(type='sir'))
 
     # Define the parameters to vary
@@ -103,6 +105,8 @@ def test_sir_epi():
 
 
 def test_sis(do_plot=do_plot):
+    sc.heading('Testing SIS dynamics')
+
     pars = dict(
         n_agents = n_agents,
         diseases = 'sis',
@@ -117,23 +121,27 @@ def test_sis(do_plot=do_plot):
 
 
 def test_ncd():
+    sc.heading('Testing NCDs')
+
     ppl = ss.People(n_agents)
-    ncd = ss.NCD()
+    ncd = ss.NCD(pars={'log':True})
     sim = ss.Sim(people=ppl, diseases=ncd, copy_inputs=False) # Since using ncd directly below
     sim.run()
 
     assert len(ncd.log.out_edges) == ncd.log.number_of_edges()
-    df = ncd.log.line_list  # Check generation of line-list
+    df = ncd.log.line_list()  # Check generation of line-list
     assert df.source.isna().all()
 
     plt.figure()
     plt.stackplot(
-        sim.yearvec,
+        sim.timevec,
         ncd.results.n_not_at_risk,
         ncd.results.n_at_risk - ncd.results.n_affected,
         ncd.results.n_affected,
         sim.results.new_deaths.cumsum(),
     )
+    assert ncd.results.n_not_at_risk.label == 'Not at risk'
+    assert ncd.results.n_affected.label == 'Affected'
     plt.legend(['Not at risk', 'At risk', 'Affected', 'Dead'])
     plt.xlabel('Year')
     plt.title('NCD')
@@ -141,6 +149,8 @@ def test_ncd():
 
 
 def test_gavi():
+    sc.heading('Testing GAVI diseases')
+
     sims = sc.autolist()
     for disease in ['cholera', 'measles', 'ebola']:
         pars = dict(
@@ -155,6 +165,8 @@ def test_gavi():
 
 
 def test_multidisease():
+    sc.heading('Testing simulating multiple diseases')
+
     ppl = ss.People(n_agents)
     sir1 = ss.SIR(name='sir1')
     sir2 = ss.SIR(name='sir2')
@@ -167,9 +179,9 @@ def test_multidisease():
     sim.run()
     return sim
 
+
 def test_mtct():
-    """ Test mother-to-child transmission routes """
-
+    sc.heading('Test mother-to-child transmission routes')
     ppl = ss.People(n_agents)
     sis = ss.SIS(beta={'random':[0.005, 0.001], 'prenatal':[0.1, 0], 'postnatal':[0.1, 0]})
     networks = [ss.RandomNet(), ss.PrenatalNet(), ss.PostnatalNet()]
@@ -178,7 +190,9 @@ def test_mtct():
     sim.run()
     return sim
 
+
 if __name__ == '__main__':
+    do_plot = True
     sc.options(interactive=do_plot)
     sir   = test_sir()
     s1,s2 = test_sir_epi()
diff --git a/tests/test_dist.py b/tests/test_dist.py
index eaedd01..aebb4b4 100644
--- a/tests/test_dist.py
+++ b/tests/test_dist.py
@@ -6,22 +6,23 @@ import numpy as np
 import sciris as sc
 import scipy.stats as sps
 import starsim as ss
-import matplotlib.pyplot as pl
+import matplotlib.pyplot as plt
 import pytest
 
 n = 1_000_000 # For testing statistical properties and performance of distributions
 m = 5 # For just testing that drawing works
+dpy = 365.25 # Number of days per year
 sc.options(interactive=False)
 
 
 def plot_rvs(rvs, times=None, nrows=None):
-    fig = pl.figure(figsize=(12,12))
+    fig = plt.figure(figsize=(12,12))
     nrows, ncols = sc.getrowscols(len(rvs), nrows=nrows)
     for i,name,r in rvs.enumitems():
-        pl.subplot(nrows, ncols, i+1)
-        pl.hist(r.astype(float))
+        plt.subplot(nrows, ncols, i+1)
+        plt.hist(r.astype(float))
         title = times[name] if times else name
-        pl.title(title)
+        plt.title(title)
         sc.commaticks()
     sc.figlayout()
     return fig
@@ -29,7 +30,7 @@ def plot_rvs(rvs, times=None, nrows=None):
 
 def make_sim():
     """ Make a tiny sim for initializing the distributions """
-    sim = ss.Sim(n_agents=100).initialize() # Need an empty sim to initialize properly
+    sim = ss.Sim(n_agents=100).init() # Need an empty sim to initialize properly
     return sim
 
 
@@ -38,39 +39,43 @@ def test_dist(m=m):
     """ Test the Dist class """
     sc.heading('Testing the basic Dist call')
     dist = ss.Dist(distname='random', name='test', strict=False)
-    dist.initialize()
+    dist.init()
     rvs = dist(m)
     print(rvs)
     assert 0 < rvs.min() < 1, 'Values should be between 0 and 1'
+
+    # Test other options
+    dist.show_state()
+    dist.plot_hist()
     return rvs
 
 
 def test_custom_dists(n=n, do_plot=False):
     """ Test all custom dists """
     sc.heading('Testing all custom distributions')
-    
+
     o     = sc.objdict()
     dists = sc.objdict()
     rvs   = sc.objdict()
     times = sc.objdict()
     for name in ss.dist_list:
-        func = getattr(ss, name)
-        dist = func(name='test', strict=False)
-        dist.initialize()
+        dist_class = getattr(ss, name)
+        dist = dist_class(name='test', strict=False)
+        dist.init()
         dists[name] = dist
         sc.tic()
         rvs[name] = dist.rvs(n)
         times[name] = sc.toc(name, unit='ms', output='message')
         print(f'{name:10s}: mean = {rvs[name].mean():n}')
-    
+
     if do_plot:
         plot_rvs(rvs, times=times, nrows=5)
-    
+
     o.dists = dists
     o.rvs = rvs
     o.times = times
     return o
-        
+
 
 def test_dists(n=n, do_plot=False):
     """ Test the Dists container """
@@ -79,14 +84,14 @@ def test_dists(n=n, do_plot=False):
 
     # Create the objects twice
     for i in range(2):
-        
+
         # Create a complex object containing various distributions
         obj = sc.prettyobj()
         obj.a = sc.objdict()
         obj.a.mylist = [ss.random(), ss.Dist(distname='uniform', low=2, high=3)]
         obj.b = dict(d3=ss.weibull(c=2), d4=ss.constant(v=0.3))
-        dists = ss.Dists(obj).initialize(sim=make_sim())
-        
+        dists = ss.Dists(obj).init(sim=make_sim())
+
         # Call each distribution twice
         for j in range(2):
             rvs = sc.objdict()
@@ -94,15 +99,15 @@ def test_dists(n=n, do_plot=False):
                 rvs[str(dist)] = dist(n)
                 dist.jump() # Reset
             testvals[i,j] = rvs[0][283] # Pick one of the random values and store it
-    
+
     # Check that results are as expected
     print(testvals)
     assert np.all(testvals[0,:] == testvals[1,:]), 'Newly initialized objects should match'
     assert np.all(testvals[:,0] != testvals[:,1]), 'After jumping, values should be different'
-            
+
     if do_plot:
         plot_rvs(rvs)
-    
+
     o = sc.objdict()
     o.dists = dists
     o.rvs = rvs
@@ -112,96 +117,101 @@ def test_dists(n=n, do_plot=False):
 def test_scipy(m=m):
     """ Test that SciPy distributions also work """
     sc.heading('Testing SciPy distributions')
-    
+
     # Make SciPy distributions in two different ways
-    dist1 = ss.Dist(dist=sps.expon, name='scipy', scale=2, strict=False).initialize() # Version 1: callable
-    dist2 = ss.Dist(dist=sps.expon(scale=2), name='scipy', strict=False).initialize() # Version 2: frozen
+    dist1 = ss.Dist(dist=sps.expon, name='scipy', scale=2, strict=False).init() # Version 1: callable
+    dist2 = ss.Dist(dist=sps.expon(scale=2), name='scipy', strict=False).init() # Version 2: frozen
     rvs1 = dist1(m)
     rvs2 = dist2(m)
-    
+
     # Check that they match
     print(rvs1)
     assert np.array_equal(rvs1, rvs2), 'Arrays should match'
-    
+
     return dist1, dist2
 
 
 def test_exceptions(m=m):
     """ Check that exceptions are being appropriately raised """
     sc.heading('Testing exceptions and strict')
-    
+
     # Create a strict distribution
     dist = ss.random(strict=True, auto=False)
     with pytest.raises(ss.distributions.DistNotInitializedError):
         dist(m) # Check that we can't call an uninitialized
-    
+
     # Initialize and check we can't call repeatedly
-    dist.initialize(trace='test', sim=make_sim())
+    dist.init(trace='test', sim=make_sim())
     rvs = dist(m)
     with pytest.raises(ss.distributions.DistNotReadyError):
         dist(m) # Check that we can't call an already-used distribution
-    
+
     # Check that we can with a non-strict Dist
     dist2 = ss.random(strict=False)
-    dist2.initialize(trace='test')
+    dist2.init(trace='test')
     rvs2 = sc.autolist()
     for i in range(2):
         rvs2 += dist2(m) # We should be able to call multiple times with no problem
-    
+
     print(rvs)
     print(rvs2)
     assert np.array_equal(rvs, rvs2[0]), 'Separate dists should match'
     assert not np.array_equal(rvs2[0], rvs2[1]), 'Multiple calls to the same dist should not match'
-    
+
     return dist, dist2
-    
+
 
 def test_reset(m=m):
     """ Check that reset works as expected """
     sc.heading('Testing reset')
-    
+
     # Create and draw two sets of random numbers
-    dist = ss.random(seed=533, strict=False).initialize()
+    dist = ss.random(seed=533, strict=False).init()
     r1 = dist.rvs(m)
     r2 = dist.rvs(m)
     assert all(r1 != r2)
-    
+
     # Reset to the most recent state
     dist.reset(-1)
     r3 = dist.rvs(m)
     assert all(r3 == r2)
-    
+
     # Reset to the initial state
     dist.reset(0)
     r4 = dist.rvs(m)
     assert all(r4 == r1)
-    
+
     for r in [r1, r2, r3, r4]:
         print(r)
-    
+
     return dist
 
 
-def test_callable(n=n):
-    """ Test callable parameters """
-    sc.heading('Testing a uniform distribution with callable parameters')
-    
-    # Define a fake people object
+def make_fake_sim(n=10):
+    """ Define a fake sim object for testing slots """
     sim = sc.prettyobj()
-    sim.n = 10
+    sim.n = n
     sim.people = sc.prettyobj()
     sim.people.uid = np.arange(sim.n)
     sim.people.slot = np.arange(sim.n)
-    sim.people.age = np.random.uniform(0, 90, size=sim.n)
+    sim.people.age = np.random.uniform(0, 100, size=sim.n)
+    return sim
+
+
+def test_callable(n=n):
+    """ Test callable parameters """
+    sc.heading('Testing a uniform distribution with callable parameters')
+
+    sim = make_fake_sim()
 
     # Define a parameter as a function
     def custom_loc(module, sim, uids):
         out = sim.people.age[uids]
         return out
-    
+
     scale = 1
-    d1 = ss.normal(name='callable', loc=custom_loc, scale=scale).initialize(sim=sim)
-    d2 = ss.lognorm_ex(name='callable', mean=custom_loc, stdev=scale).initialize(sim=sim)
+    d1 = ss.normal(name='callable', loc=custom_loc, scale=scale).init(sim=sim)
+    d2 = ss.lognorm_ex(name='callable', mean=custom_loc, std=scale).init(sim=sim)
 
     uids = np.array([1, 3, 7, 9])
     draws1 = d1.rvs(uids)
@@ -212,6 +222,7 @@ def test_callable(n=n):
     for draws in [draws1, draws2]:
         meandiff = np.abs(sim.people.age[uids] - draws).mean()
         assert meandiff < scale*3, 'Outputs should match ages'
+
     return d1
 
 
@@ -223,7 +234,7 @@ def test_array(n=n):
     low  = np.array([1, 100]) # Low
     high = np.array([3, 125]) # High
 
-    d = ss.uniform(low=low, high=high, strict=False).initialize(slots=np.arange(uids.max()+1))
+    d = ss.uniform(low=low, high=high, strict=False).init(slots=np.arange(uids.max()+1))
     draws = d.rvs(uids)
     print(f'Uniform sample for uids {uids} returned {draws}')
 
@@ -245,9 +256,9 @@ def test_repeat_slot():
     high = low + 1
 
     # Draw values
-    d = ss.uniform(low=low, high=high, strict=False).initialize(slots=slots)
+    d = ss.uniform(low=low, high=high, strict=False).init(slots=slots)
     draws = d.rvs(uids)
-    
+
     # Print and test
     print(f'Uniform sample for slots {slots} returned {draws}')
     assert len(draws) == len(slots)
@@ -261,14 +272,176 @@ def test_repeat_slot():
     return draws
 
 
+def test_timepar_dists():
+    """ Test interaction of distributions and timepars """
+    sc.heading('Test interaction of distributions and timepars')
+
+    # Set parameters
+    n = int(10e3)
+    u1 = 'day'
+    u2 = 'year'
+    dt_dur = 0.1
+    dt_rate = 20.0
+    ratio_dur  = ss.time_ratio(u1, 1.0, u2, dt_dur)
+    ratio_rate = ss.time_ratio(u2, 1.0, u1, dt_rate)
+
+    # Create time parameters
+    v = sc.objdict()
+    v.base = 30.0
+    v.dur = ss.dur(v.base, unit=u1, parent_unit=u2, parent_dt=dt_dur).init()
+    v.rate = ss.rate(v.base, unit=u2, parent_unit=u1, parent_dt=dt_rate).init() # Swap units
+
+    # Check distributions that scale linearly with time, with the parameter we'll set
+    print('Testing linear distributions ...')
+    linear_dists = dict(
+        constant   = 'v',
+        uniform    = 'high',
+        normal     = 'loc',
+        lognorm_ex = 'mean',
+        expon      = 'scale',
+        weibull    = 'scale',
+        gamma      = 'scale',
+    )
+
+    for name,par in linear_dists.items():
+        dist_class = getattr(ss, name)
+
+        # Create the dists, the first parameter of which should have time units
+        dists = sc.objdict()
+        for key,val in v.items():
+            pardict = {par:val} # Convert to a tiny dictionary to insert the correct name
+            dists[key] = dist_class(**pardict, name=key, strict=False).init()
+
+        # Create th erandom variates
+        rvs = sc.objdict()
+        for k,dist in dists.items():
+            rvs[k] = dist.rvs(n)
+
+        # Check that the distributions match
+        rtol = 0.1 # Be somewhat generous with the uncertainty
+        expected = rvs.base.mean()
+        expected_dur = expected*ratio_dur
+        expected_rate = expected/ratio_rate
+        actual_dur = rvs.dur.mean()
+        actual_rate = rvs.rate.mean()
+        assert np.isclose(expected_dur, actual_dur, rtol=rtol), f'Duration not close for {name}: {expected_dur:n} ≠ {actual_dur:n}'
+        assert np.isclose(expected_rate, actual_rate, rtol=rtol), f'Rate not close for {name}: {expected_rate:n} ≠ {actual_rate:n}'
+        sc.printgreen(f'✓ {name} passed: {expected_dur:n} ≈ {actual_dur:n}')
+
+    # Check that unitless distributions fail
+    print('Testing unitless distributions ...')
+    par = ss.dur(10)
+    unitless_dists = ['lognorm_im', 'randint', 'choice']
+    for name in unitless_dists:
+        dist_class = getattr(ss, name)
+        with pytest.raises(NotImplementedError):
+            dist = dist_class(par, name='notimplemented', strict=False).init()
+            dist.rvs(n)
+        sc.printgreen(f'✓ {name} passed: raised appropriate error')
+
+    # Check special distributions
+    print('Testing Poisson distribution ...')
+    lam1 = ss.rate(dpy, 'year', parent_unit='year').init()
+    lam2 = ss.rate(1,   'day',  parent_unit='year').init()
+    poi1 = ss.poisson(lam=lam1, strict=False).init()
+    poi2 = ss.poisson(lam=lam2, strict=False).init()
+    mean1 = poi1.rvs(n).mean()
+    mean2 = poi2.rvs(n).mean()
+    assert np.isclose(mean1, mean2, rtol=rtol), f'Poisson values do not match for {lam1} and {lam2}: {mean1:n} ≠ {mean2:n}'
+    sc.printgreen(f'✓ poisson passed: {mean1:n} ≈ {mean2:n}')
+
+    print('Testing Bernoulli distribution ...')
+    p1 = 0.1
+    p2 = ss.time_prob(0.01, parent_dt=10).init()
+    ber1 = ss.bernoulli(p=p1, strict=False).init()
+    ber2 = ss.bernoulli(p=p2, strict=False).init()
+    mean1 = ber1.rvs(n).mean()
+    mean2 = ber2.rvs(n).mean()
+    assert np.isclose(mean1, mean2, rtol=rtol), f'Bernoulli values do not match for {lam1} and {lam2}: {mean1:n} ≠ {mean2:n}'
+    sc.printgreen(f'✓ bernoulli passed: {mean1:n} ≈ {mean2:n}')
+
+    return ber2
+
+
+def test_timepar_callable():
+    sc.heading('Test that timepars work with (some) callable functions')
+
+    print('Testing callable parameters with regular-scaling distributions')
+    sim = make_fake_sim(n=10)
+    uids = np.array([1, 3, 7, 9])
+
+    def age_year(module, sim, uids):
+        """ Extract age as a year """
+        out = sim.people.age[uids].copy()
+        return out
+
+    def age_day(module, sim, uids):
+        """ Extract age as a day """
+        out = sim.people.age[uids].copy()
+        out *= dpy # Convert to days manually
+        return out
+
+    scale = 1e-3 # Set to a very small but nonzero scale
+    loc  = ss.dur(age_year, unit='year', parent_unit='day').init(update_values=False)
+    mean = ss.dur(age_day,  unit='day',  parent_unit='day').init(update_values=False)
+    d3 = ss.normal(name='callable', loc=loc, scale=scale).init(sim=sim)
+    d4 = ss.lognorm_ex(name='callable', mean=mean, std=scale).init(sim=sim)
+    draws3 = d3.rvs(uids)
+    draws4 = d4.rvs(uids)
+    age_in_days = sim.people.age[uids]*dpy
+    draw_diff = np.abs(draws3 - draws4).mean()
+    age_diff = np.abs(age_in_days - draws3).mean()
+    print(f'Input ages were:\n{sim.people.age[uids]}')
+    print(f'Output samples were:\n{sc.sigfiground(draws3)}\n{sc.sigfiground(draws4)}')
+    assert draw_diff < 1, 'Day and year outputs should match to the nearest day'
+    assert age_diff < 1, 'Distribution outputs should match ages to the nearest day'
+
+    print('Testing callable parameters with Bernoulli distributions')
+    n = 100_000
+    sim = make_fake_sim(n=n)
+    uids = np.random.choice(n, size=n//2, replace=False)
+    age = sim.people.age[uids]
+    mean = age.mean()
+    young = sc.findinds(age<=mean)
+    old = sc.findinds(age>mean)
+    p_young = 0.001
+    p_old = 0.010
+
+    def age_prob(module, sim, uids):
+        out = np.zeros_like(age)
+        out[young] = p_young
+        out[old]   = p_old
+        return out
+
+    parent_dt = 10
+    p1 = age_prob
+    p2 = ss.time_prob(age_prob, parent_dt=parent_dt).init(update_values=False)
+    ber1 = ss.bernoulli(name='base', p=p1).init(sim=sim)
+    ber2 = ss.bernoulli(name='time', p=p2).init(sim=sim)
+    brvs1 = ber1.rvs(uids)
+    brvs2 = ber2.rvs(uids)
+
+    rtol = 0.5 # We're dealing with order-of-magnitude differences but small numbers, so be generous to avoid random failures
+    sum1 = brvs1.sum()*parent_dt
+    sum2 = brvs2.sum()
+    assert np.isclose(sum1, sum2, rtol=rtol), f'Callable Bernoulli sums did not match: {sum1}  ≠  {sum2}'
+    sc.printgreen(f'✓ Callable Bernoulli sums matched: {sum1:n} ≈ {sum2:n}')
+    for key,expected,inds in zip(['young', 'old'], [p_young, p_old], [young, old]):
+        m1 = brvs1[inds].mean()
+        m2 = brvs2[inds].mean()/parent_dt
+        assert np.allclose([expected, m1], [expected, m2], rtol=rtol), f'Callable Bernoulli proportions did not match: {expected:n}  ≠  {m1:n}  ≠  {m2:n}'
+        sc.printgreen(f'✓ Callable Bernoulli proportions matched: {expected:n}  ≈  {m1:n}  ≈  {m2:n}')
+
+    return
+
 
 # %% Run as a script
 if __name__ == '__main__':
     do_plot = True
     sc.options(interactive=do_plot)
-    
+
     T = sc.timer()
-    
+
     o1 = test_dist()
     o2 = test_custom_dists(do_plot=do_plot)
     o3 = test_dists(do_plot=do_plot)
@@ -278,5 +451,7 @@ if __name__ == '__main__':
     o7 = test_callable()
     o8 = test_array()
     o9 = test_repeat_slot()
-    
+    o10 = test_timepar_dists()
+    o10 = test_timepar_callable()
+
     T.toc()
diff --git a/tests/test_interventions.py b/tests/test_interventions.py
index 1f7f05e..8a1abca 100644
--- a/tests/test_interventions.py
+++ b/tests/test_interventions.py
@@ -8,7 +8,7 @@ import numpy as np
 import starsim as ss
 
 
-def run_sir_vaccine(efficacy, leaky=True):
+def run_sir_vaccine(efficacy, leaky=True, do_plot=False):
     # parameters
     v_frac      = 0.5    # fraction of population vaccinated
     total_cases = 500    # total cases at which point we check results
@@ -16,32 +16,32 @@ def run_sir_vaccine(efficacy, leaky=True):
 
     # create a basic SIR sim
     sim = ss.Sim(
-        n_agents = 1000,     
+        n_agents = 1000,
         pars = dict(
-          networks = dict(     
-                type = 'random', 
-                n_contacts = 4    
+          networks = dict(
+                type = 'random',
+                n_contacts = 4
           ),
-          diseases = dict(      
-                type      = 'sir',     
-                init_prev = 0.01,  
-                dur_inf   = 0.1,
+          diseases = dict(
+                type      = 'sir',
+                init_prev = 0.01,
+                dur_inf   = ss.dur(10),
                 p_death   = 0,
-                beta      = 6,       
+                beta      = ss.beta(0.06),
           )
         ),
-        n_years = 10,
-        dt      = 0.01
+        dur = 10,
+        dt  = 0.01
     )
-    sim.initialize(verbose=False)
-    
+    sim.init(verbose=False)
+
     # work out who to vaccinate
     in_trial = sim.people.sir.susceptible.uids
     n_vac = round(len(in_trial) * v_frac)
     in_vac = np.random.choice(in_trial, n_vac, replace=False)
     in_pla = np.setdiff1d(in_trial, in_vac)
     uids = ss.uids(in_vac)
-    
+
     # create and apply the vaccination
     vac = ss.sir_vaccine(efficacy=efficacy, leaky=leaky)
     vac.init_pre(sim)
@@ -62,7 +62,7 @@ def run_sir_vaccine(efficacy, leaky=True):
     # run the simulation until sufficient cases
     old_cases = []
     for idx in range(1000):
-        sim.step()
+        sim.run_one_step()
         susc = sim.people.sir.susceptible.uids
         cases = np.setdiff1d(in_trial, susc)
         if len(cases) > total_cases:
@@ -84,20 +84,24 @@ def run_sir_vaccine(efficacy, leaky=True):
         assert len(np.intersect1d(vac_cases, in_vac[rel_susc[in_vac] == 1.0])) == len(vac_cases), 'Not all vaccine cases amongst vaccine failures (all or nothing)'
         assert len(np.intersect1d(vac_cases, in_vac[rel_susc[in_vac] == 0.0])) == 0, 'Vaccine cases amongst fully vaccincated (all or nothing)'
 
+    if do_plot:
+        sim.plot()
+
     return sim
 
 
-def test_sir_vaccine_leaky():
-    return run_sir_vaccine(0.3, False)
+def test_sir_vaccine_leaky(do_plot=False):
+    return run_sir_vaccine(0.3, False, do_plot=do_plot)
 
-def test_sir_vaccine_all_or_nothing():
-    return run_sir_vaccine(0.3, True)
+def test_sir_vaccine_all_or_nothing(do_plot=False):
+    return run_sir_vaccine(0.3, True, do_plot=do_plot)
 
 
 if __name__ == '__main__':
     T = sc.timer()
+    do_plot = True
 
-    sir_vaccine_leaky   = test_sir_vaccine_leaky(leaky=True)
-    sir_vaccine_a_or_n  = test_sir_vaccine_all_or_nothing(leaky=False)
+    leaky  = test_sir_vaccine_leaky(do_plot=do_plot)
+    a_or_n = test_sir_vaccine_all_or_nothing(do_plot=do_plot)
 
     T.toc()
diff --git a/tests/test_loop.py b/tests/test_loop.py
new file mode 100644
index 0000000..d438aba
--- /dev/null
+++ b/tests/test_loop.py
@@ -0,0 +1,55 @@
+"""
+Test the Loop class
+"""
+
+# %% Imports and settings
+import sciris as sc
+import starsim as ss
+
+sc.options(interactive=False) # Assume not running interactively
+
+pars = sc.objdict(
+    dur      = 20,
+    n_agents = 1000,
+    diseases = 'sis',
+    networks = 'random',
+)
+
+
+def test_run_options():
+    sc.heading('Testing run options...')
+    s1 = ss.Sim(pars).init()
+    s2 = ss.Sim(pars).init()
+
+    # Automatic run
+    s1.run()
+
+    # Manual run
+    while s2.loop.index < len(s2.loop):
+        s2.run_one_step()
+    s2.finalize()
+
+    assert s1.summary == s2.summary, 'Sims do not match'
+
+    return s2.loop
+
+
+def test_loop_plotting():
+    sc.heading('Testing loop plotting...')
+    sim = ss.Sim(pars).run()
+    sim.loop.plot()
+    sim.loop.plot_cpu()
+    return sim.loop
+
+
+# %% Run as a script
+if __name__ == '__main__':
+    do_plot = True
+    sc.options(interactive=do_plot)
+    T = sc.timer()
+
+    # Run tests
+    l1 = test_run_options()
+    l2 = test_loop_plotting()
+
+    T.toc()
\ No newline at end of file
diff --git a/tests/test_mixingpools.py b/tests/test_mixingpools.py
new file mode 100644
index 0000000..43792cb
--- /dev/null
+++ b/tests/test_mixingpools.py
@@ -0,0 +1,203 @@
+"""
+Test Sim API
+"""
+
+# %% Imports and settings
+import sys
+import numpy as np
+import sciris as sc
+import matplotlib.pyplot as plt
+import starsim as ss
+import pytest
+
+n_agents = 1_000
+do_plot = False
+sc.options(interactive=False) # Assume not running interactively
+
+
+def test_single_defaults(do_plot=do_plot):
+    """ Test a single MixingPool using defaults """
+    test_name = sys._getframe().f_code.co_name
+    sc.heading(f'Testing {test_name}...')
+    mp = ss.MixingPool()
+    sir = ss.SIR()
+    sim = ss.Sim(diseases=sir, networks=mp, label=test_name)
+    sim.run()
+
+    if do_plot: sim.plot()
+
+    assert(sim.results.sir['cum_infections'][-1] > sim.results.sir['cum_infections'][0]) # There were infections
+    return sim
+
+
+def test_single_uids(do_plot=do_plot):
+    """ Test a single MixingPool by UIDS, pre-initialization configuration """
+    test_name = sys._getframe().f_code.co_name
+    sc.heading(f'Testing {test_name}...')
+
+    n_agents = 10_000
+    k = n_agents // 2
+    mp = ss.MixingPool(
+        src = ss.uids(np.arange(k)),
+        dst = ss.uids(np.arange(k,n_agents))
+    )
+    sir = ss.SIR()
+    sim = ss.Sim(n_agents=n_agents, diseases=sir, networks=mp, label=test_name)
+    sim.run()
+
+    if do_plot: sim.plot()
+
+    assert sim.results.sir['cum_infections'][-1] > sim.results.sir['cum_infections'][0], 'There were no new infections in the simulation'
+    return sim
+
+
+def test_single_ncd():
+    """ Test a single MixingPool with a ncd """
+    test_name = sys._getframe().f_code.co_name
+    sc.heading(f'Testing {test_name}...')
+    mp_pars = {
+        'src': ss.AgeGroup(0, 15),
+        'dst': ss.AgeGroup(15, None),
+        'beta': ss.beta(0.15),
+        'contacts': ss.poisson(lam=5),
+        'diseases': 'ncd'
+    }
+    mp = ss.MixingPool(mp_pars)
+
+    ncd = ss.NCD()
+    sim = ss.Sim(diseases=ncd, networks=mp, label=test_name)
+    with pytest.raises(Exception):
+        sim.run()
+    return sim
+
+
+def test_single_missing_disease():
+    """ Test a single MixingPool with a missing disease """
+    test_name = sys._getframe().f_code.co_name
+    sc.heading(f'Testing {test_name}...')
+    mp_pars = {
+        'src': ss.AgeGroup(0, 15),
+        'dst': ss.AgeGroup(15, None),
+        'beta': ss.beta(0.15),
+        'contacts': ss.poisson(lam=5),
+        'diseases': 'hiv'
+    }
+    mp = ss.MixingPool(mp_pars)
+
+    sir = ss.SIR()
+    sim = ss.Sim(diseases=sir, networks=mp, label=test_name)
+    with pytest.raises(Exception):
+        sim.run()
+
+    return sim
+
+
+def test_single_age(do_plot=do_plot):
+    """ Test a single MixingPool by age """
+    # Incidence must decline because 0-15 --> 15+ transmission only
+    test_name = sys._getframe().f_code.co_name
+    sc.heading(f'Testing {test_name}...')
+    mp_pars = {
+        'src': ss.AgeGroup(0, 15),
+        'dst': ss.AgeGroup(15, None),
+        'beta': ss.beta(0.15),
+        'contacts': ss.poisson(lam=5),
+    }
+    mp = ss.MixingPool(mp_pars)
+
+    sir = ss.SIR()
+    sim = ss.Sim(diseases=sir, networks=mp, label=test_name)
+    sim.run()
+
+    if do_plot: sim.plot()
+
+    assert(sim.results.sir['cum_infections'][-1] > sim.results.sir['cum_infections'][0]) # There were infections
+    return sim
+
+
+def test_single_sex(do_plot=do_plot):
+    """ Test a single MixingPool by sex """
+    # Incidence must decline because M --> F transmission only
+    test_name = sys._getframe().f_code.co_name
+    sc.heading(f'Testing {test_name}...')
+    mp_pars = {
+        'src': lambda sim: sim.people.female, # female to male (only) transmission
+        'dst': lambda sim: sim.people.male,
+        'beta': ss.beta(0.2),
+        'contacts': ss.poisson(lam=4),
+    }
+    mp = ss.MixingPool(mp_pars)
+
+    sir = ss.SIR(init_prev=ss.bernoulli(p=lambda self, sim, uids: 0.05*sim.people.female)) # Seed 5% of the female population
+    sim = ss.Sim(diseases=sir, networks=mp, label=test_name)
+    sim.run()
+
+    if do_plot: sim.plot()
+
+    assert(sim.results.sir['cum_infections'][-1] > sim.results.sir['cum_infections'][0]) # There were infections
+    assert(sim.people.male[sim.diseases.sir.ti_infected>0].all()) # All new infections should be in men
+    return sim
+
+
+def test_multi_defaults(do_plot=do_plot):
+    """ Test MixingPools using defaults """
+    test_name = sys._getframe().f_code.co_name
+    sc.heading(f'Testing {test_name}...')
+    mps = ss.MixingPools(src={'all':None}, dst={'all':None}, contacts=[[1]])
+    sir = ss.SIR()
+    sim = ss.Sim(diseases=sir, networks=mps, label=test_name)
+    sim.run()
+
+    if do_plot: sim.plot()
+
+    assert(sim.results.sir['cum_infections'][-1] > sim.results.sir['cum_infections'][0]) # There were infections
+    return sim
+
+
+def test_multi(do_plot=do_plot):
+    """ Test MixingPools """
+    test_name = sys._getframe().f_code.co_name
+    sc.heading(f'Testing {test_name}...')
+
+    groups = {
+        'Female': lambda sim: sim.people.female,
+        'Male': lambda sim: sim.people.male,
+    }
+
+    mps_pars = dict(
+        contacts = np.array([[1.4, 0.5], [1.2, 0.7]]),
+        beta = ss.beta(0.2),
+        src = groups,
+        dst = groups,
+    )
+    mps = ss.MixingPools(mps_pars)
+
+    sir = ss.SIR()
+    sim = ss.Sim(diseases=sir, networks=mps, label=test_name)
+    sim.run()
+
+    if do_plot: sim.plot()
+
+    assert(sim.results.sir['cum_infections'][-1] > sim.results.sir['cum_infections'][0]) # There were infections
+    return sim
+
+
+if __name__ == '__main__':
+    do_plot = True
+    sc.options(interactive=do_plot)
+    T = sc.timer()
+
+    sim0 = test_single_defaults(do_plot)
+    sim1 = test_single_uids(do_plot)
+    sim2 = test_single_ncd()
+    sim3 = test_single_missing_disease()
+    sim4 = test_single_age(do_plot)
+    sim5 = test_single_sex(do_plot)
+
+    sim6 = test_multi_defaults(do_plot)
+    sim7 = test_multi(do_plot)
+
+    T.toc()
+
+    if do_plot:
+        plt.show()
diff --git a/tests/test_networks.py b/tests/test_networks.py
index 085866e..7a5813a 100644
--- a/tests/test_networks.py
+++ b/tests/test_networks.py
@@ -6,6 +6,7 @@ Test networks
 import sciris as sc
 import numpy as np
 import starsim as ss
+import scipy.stats as sps
 
 sc.options(interactive=False) # Assume not running interactively
 
@@ -27,11 +28,11 @@ def test_manual():
 
     # Create a maternal network
     sim = ss.Sim(n_agents=n_agents)
-    sim.initialize()
+    sim.init()
     nw2 = ss.MaternalNet()
     nw2.init_pre(sim)
     nw2.add_pairs(mother_inds=[1, 2, 3], unborn_inds=[100, 101, 102], dur=[1, 1, 1])
-    
+
     # Tidy
     o = sc.objdict(nw1=nw1, nw2=nw2)
     return o
@@ -42,62 +43,187 @@ def test_random():
 
     # Manual creation
     nw1 = ss.RandomNet()
-    ss.Sim(n_agents=small, networks=nw1, copy_inputs=False).initialize() # This initializes the network
-    
+    ss.Sim(n_agents=small, networks=nw1, copy_inputs=False).init() # This initializes the network
+
     # Automatic creation as part of sim
-    s2 = ss.Sim(n_agents=small, networks='random').initialize()
+    s2 = ss.Sim(n_agents=small, networks='random').init()
     nw2 = s2.networks[0]
-    
+
     # Increase the number of contacts
     nwdict = dict(type='random', n_contacts=20)
-    s3 = ss.Sim(n_agents=small, networks=nwdict).initialize()
+    s3 = ss.Sim(n_agents=small, networks=nwdict).init()
     nw3 = s3.networks[0]
-    
+
     # Checks
     assert np.array_equal(nw1.p2, nw2.p2), 'Implicit and explicit creation should give the same network'
     assert len(nw3) == len(nw2)*2, 'Doubling n_contacts should produce twice as many contacts'
-    
+
     # Tidy
     o = sc.objdict(nw1=nw1, nw2=nw2, nw3=nw3)
     return o
 
 
+def test_erdosrenyi():
+    sc.heading('Testing Erdos-Renyi network')
+
+    def test_ER(n, p, nw, alpha=0.01):
+        """
+        Because each edge exists i.i.d. with probability p, the degree
+        distribution of an Erdos-Renyi network should be Binomally distributed.
+        Here, we test if the observed degree distribution, f_obs, matches the
+        expected distribution, f_exp, which comes from the binomial probabiltiy
+        mass function from the scipy stats library.
+
+        Args:
+            n (int): number of agents
+            p (float): edge probability
+            nw (Network): The network to test
+            alpha (float): The test significance level
+
+        Returns:
+            Chi-Squared p-value and asserts if the statistical test fails,
+            indicating that the observed degree distribution is unlikely to come
+            from the the correct binomial.
+        """
+        p12 = np.concatenate([nw.edges['p1'], nw.edges['p2']]) # p1 and p2 are the UIDs of agents, used here to determine degree
+        upper = sps.binom.ppf(n=n-1, p=p, q=0.999) # Figure out the 99.9th percentile expected upper bound on the degree
+        bins = np.arange(upper+1) # Create bins
+        counts = np.histogram(p12, bins=np.arange(n+1))[0] # Count how many times each agent is connected
+        f_obs = np.histogram(counts, bins=bins)[0] # Form the degree distribution
+        pp = sps.binom.pmf(bins[:-1], n=n, p=p) # Computed the theoretical probability distribution
+        f_exp = f_obs.sum()*pp / pp.sum() # Scale
+        p_value = sps.chisquare(f_obs, f_exp).pvalue # Compute the X2 p-value
+        assert not p_value < alpha
+        return p_value
+
+    # Manual creation
+    p = 0.1
+    nw1 = ss.ErdosRenyiNet(p=p)
+    ss.Sim(n_agents=small, networks=nw1, copy_inputs=False).init() # This initializes the network
+    test_ER(small, p, nw1)
+
+    # Automatic creation as part of sim
+    s2 = ss.Sim(n_agents=small, networks='erdosrenyi').init()
+    nw2 = s2.networks[0]
+
+    # Larger example with higher p
+    p=0.6
+    nwdict = dict(type='erdosrenyi', p=p)
+    s3 = ss.Sim(n_agents=medium, networks=nwdict).init()
+    nw3 = s3.networks[0]
+    test_ER(medium, p, nw3)
+
+    # Checks
+    assert np.array_equal(nw1.p2, nw2.p2), 'Implicit and explicit creation should give the same network'
+
+    # Tidy
+    o = sc.objdict(nw1=nw1, nw2=nw2, nw3=nw3)
+    return o
+
+
+def test_disk():
+    sc.heading('Testing Disk network')
+
+    # Visualize the path of agents
+    nw1 = ss.DiskNet()
+    s1 = ss.Sim(n_agents=5, dur=50, networks=nw1, copy_inputs=False).init() # This initializes the network
+
+    if sc.options.interactive:
+        # Visualize motion:
+        import matplotlib.pyplot as plt
+        import matplotlib as mpl
+
+        fig, ax = plt.subplots()
+        vdt = nw1.pars.v * s1.pars.dt
+
+        cmap = mpl.colormaps['plasma']
+        colors = cmap(np.linspace(0, 1, s1.pars.n_agents))
+        ax.scatter(nw1.x, nw1.y, s=50, c=colors)
+        for i in range(s1.pars.dur):
+            ax.plot([0,1,1,0,0], [0,0,1,1,0], 'k-', lw=1)
+            ax.quiver(nw1.x, nw1.y, vdt * np.cos(nw1.theta), vdt * np.sin(nw1.theta), color=colors)
+            ax.set_aspect('equal', adjustable='box') #ax.set_xlim([0,1]); ax.set_ylim([0,1])
+            s1.run_one_step()
+
+    # Simulate SIR on a DiskNet
+    nw2 = ss.DiskNet(r=0.15, v=0.05)
+    s2 = ss.Sim(n_agents=small, networks=nw2, diseases='sir').init() # This initializes the network
+    s2.run()
+
+    if sc.options.interactive:
+        s2.plot()
+        plt.show()
+
+    return s1, s2
+
+
 def test_static():
     sc.heading('Testing static networks')
-    
+
     # Create with p
     p = 0.2
     n = 100
     nc = p*n
     nd1 = dict(type='static', p=p)
-    nw1 = ss.Sim(n_agents=n, networks=nd1).initialize().networks[0]
-    
+    nw1 = ss.Sim(n_agents=n, networks=nd1).init().networks[0]
+
     # Create with n_contacts
     nd2 = dict(type='static', n_contacts=nc)
-    nw2 = ss.Sim(n_agents=n, networks=nd2).initialize().networks[0]
-    
+    nw2 = ss.Sim(n_agents=n, networks=nd2).init().networks[0]
+
     # Check
     assert len(nw1) == len(nw2), 'Networks should be the same length'
     target = n*n*p/2
     assert target/2 < len(nw1) < target*2, f'Network should be approximately length {target}'
-    
+
     # Tidy
     o = sc.objdict(nw1=nw1, nw2=nw2)
     return o
 
 
+def test_null():
+    sc.heading('Testing NullNet...')
+    people = ss.People(n_agents=small)
+    network = ss.NullNet()
+    sir = ss.SIR(pars=dict(dur_inf=10, beta=0.1))
+    sim = ss.Sim(diseases=sir, people=people, networks=network)
+    sim.run()
+    return sim
+
+
+def test_other():
+    sc.heading('Other network tests...')
+
+    print('Testing MSM network')
+    msm = ss.MSMNet(participation=0.3)
+    sim = ss.Sim(diseases=dict(type='sis', beta=0.5), networks=msm, copy_inputs=False)
+    sim.run()
+
+    print('Testing other network methods')
+    msm.validate()
+    inds1 = msm.get_inds([0])
+    contacts = msm.find_contacts(inds1['p1'])
+    assert contacts[0] == inds1['p2']
+    inds2 = msm.pop_inds([0])
+    assert inds1 == inds2
+
+    return msm
+
+
+
 # %% Run as a script
 if __name__ == '__main__':
     do_plot = True
     sc.options(interactive=do_plot)
-
-    # Start timing
-    T = sc.tic()
+    T = sc.timer()
 
     # Run tests
-    man = test_manual()
-    rnd = test_random()
-    sta = test_static()
+    man  = test_manual()
+    rand = test_random()
+    stat = test_static()
+    erdo = test_erdosrenyi()
+    disk = test_disk()
+    null = test_null()
+    oth  = test_other()
 
-    sc.toc(T)
-    print('Done.')
\ No newline at end of file
+    T.toc()
\ No newline at end of file
diff --git a/tests/test_other.py b/tests/test_other.py
index 06f673a..b0a3e6a 100644
--- a/tests/test_other.py
+++ b/tests/test_other.py
@@ -1,12 +1,11 @@
 """
 Test Starsim features not covered by other test files
 """
-
-# %% Imports and settings
 import sciris as sc
 import numpy as np
 import starsim as ss
-import matplotlib.pyplot as pl
+import matplotlib.pyplot as plt
+import pytest
 
 sc.options(interactive=False) # Assume not running interactively
 
@@ -19,7 +18,7 @@ def test_people():
     sc.heading('Testing people object')
 
     # Base people contains only the states defined in base.base_states
-    ppl = ss.People(small)  # BasePeople
+    ppl = ss.People(small)
     del ppl
 
     # Possible to initialize people with extra states, e.g. a geolocation
@@ -51,20 +50,21 @@ def test_microsim(do_plot=False):
         people=ss.People(small),
         networks=[ss.MFNet(), ss.MaternalNet()],
         demographics=ss.Pregnancy(),
-        diseases=hiv
+        diseases=hiv,
+        copy_inputs = False, # So we can reuse hiv
     )
-    sim.initialize()
+    sim.init()
     sim.run()
 
     if do_plot:
-        pl.figure()
-        pl.plot(sim.tivec, sim.results.hiv.n_infected)
-        pl.title('HIV number of infections')
+        plt.figure()
+        plt.plot(hiv.timevec, hiv.results.n_infected)
+        plt.title('HIV number of infections')
 
     return sim
 
 
-def test_ppl_construction():
+def test_ppl_construction(do_plot=False):
     sc.heading('Test making people and providing them to a sim')
 
     def init_debut(module, sim, uids):
@@ -81,11 +81,12 @@ def test_ppl_construction():
     gon = ss.Gonorrhea(pars=gon_pars)
 
     sim = ss.Sim(pars=sim_pars, diseases=[gon])
-    sim.initialize()
+    sim.init()
     sim.run()
-    pl.figure()
-    pl.plot(sim.tivec, sim.results.gonorrhea.n_infected)
-    pl.title('Number of gonorrhea infections')
+    if do_plot:
+        plt.figure()
+        plt.plot(sim.timevec, sim.results.gonorrhea.n_infected)
+        plt.title('Number of gonorrhea infections')
 
     return sim
 
@@ -93,14 +94,14 @@ def test_ppl_construction():
 def test_arrs():
     sc.heading('Testing Arr objects')
     o = sc.objdict()
-    
+
     # Create a sim with only births
     pars = dict(n_agents=medium, diseases='sis', networks='random')
     p1 = sc.mergedicts(pars, birth_rate=10)
     p2 = sc.mergedicts(pars, death_rate=10)
     s1 = ss.Sim(pars=p1).run()
     s2 = ss.Sim(pars=p2).run()
-    
+
     # Tests
     assert len(s1.people.auids) > len(s2.people.auids), 'Should have more people with births'
     assert np.array_equal(s1.people.age, s1.people.age.raw[s1.people.auids]), 'Different ways of indexing age should match'
@@ -109,24 +110,25 @@ def test_arrs():
     assert not np.all(s2.people.alive.raw), 'Some agents should not be alive when indexed like this'
     assert np.array_equal(~s1.people.female, s1.people.male), 'Definition of men does not match'
     assert isinstance(s1.people.age < 5, ss.BoolArr), 'Performing logical operations should return a BoolArr'
-    
+
     o.s1 = s1
-    o.s2 = s2   
-    
+    o.s2 = s2
+
     return o
 
 
 def test_deepcopy():
+    sc.heading('Testing deepcopy')
     s1 = ss.Sim(pars=dict(diseases='sir', networks='embedding'), n_agents=small)
-    s1.initialize()
-    
+    s1.init()
+
     s2 = sc.dcp(s1)
 
     s1.run()
     s2.run()
     s1.plot()
     s2.plot()
-    
+
     ss.diff_sims(s1, s2, full=True)
     assert np.allclose(s1.summary[:], s2.summary[:], rtol=0, atol=0, equal_nan=True)
 
@@ -134,8 +136,9 @@ def test_deepcopy():
 
 
 def test_deepcopy_until():
-    s1 = ss.Sim(pars=dict(diseases='sir', networks='embedding'), n_agents=small)
-    s1.initialize()
+    sc.heading('Testing deepcopy with until')
+    s1 = ss.Sim(diseases='sir', networks='embedding', n_agents=small)
+    s1.init()
 
     s1.run(until=5)
 
@@ -151,6 +154,34 @@ def test_deepcopy_until():
     return s1, s2
 
 
+def test_results():
+    sc.heading('Testing results export and plotting')
+    sim = ss.Sim(diseases='sis', networks='random', n_agents=medium)
+    sim.run()
+
+    # Export to dataframe
+    sis = sim.results.sis
+    res = sis.new_infections
+    df = res.to_df()
+    dfs = sis.to_df()
+    assert df.value.sum() == dfs.cum_infections.values[-1] == sim.summary.sis_cum_infections
+
+    # Plot
+    res.plot()
+    sim.results.sis.plot()
+
+    return sim
+
+
+def test_check_reqiures():
+    sc.heading('Testing check_requires')
+    s1 = ss.Sim(diseases='sis', networks='random', n_agents=medium).init()
+    ss.check_requires(s1, 'sis')
+    ss.check_requires(s1, ss.SIS)
+    with pytest.raises(AttributeError):
+        ss.check_requires(s1, ss.SIR)
+    return s1
+
 
 # %% Run as a script
 if __name__ == '__main__':
@@ -163,11 +194,13 @@ if __name__ == '__main__':
     # Run tests
     ppl = test_people()
     sim1 = test_microsim(do_plot)
-    sim2 = test_ppl_construction()
+    sim2 = test_ppl_construction(do_plot)
     sims = test_arrs()
     sims2 = test_deepcopy()
     sims3 = test_deepcopy_until()
+    sim4 = test_results()
+    sim5 = test_check_reqiures()
 
     sc.toc(T)
-    pl.show()
+    plt.show()
     print('Done.')
\ No newline at end of file
diff --git a/tests/test_plugins.py b/tests/test_plugins.py
index fc94e5d..6632d50 100644
--- a/tests/test_plugins.py
+++ b/tests/test_plugins.py
@@ -4,7 +4,7 @@ Test connectors and custom interventions
 
 import sciris as sc
 import numpy as np
-import pylab as pl
+import matplotlib.pyplot as plt
 import starsim as ss
 
 sc.options(interactive=False) # Assume not running interactively
@@ -13,8 +13,9 @@ sc.options(interactive=False) # Assume not running interactively
 class hiv_syph(ss.Connector):
     """ Simple connector whereby rel_sus to NG doubles if CD4 count is <200"""
     def __init__(self, pars=None, **kwargs):
-        super().__init__(label='HIV-Syphilis', requires=[ss.HIV, ss.Syphilis])
-        self.default_pars(
+        super().__init__()
+        self.define_pars(
+            label = 'HIV-Syphilis',
             rel_sus_syph_hiv    = 2,   # People with HIV are 2x more likely to acquire syphilis
             rel_sus_syph_aids   = 5,   # People with AIDS are 5x more likely to acquire syphilis
             rel_trans_syph_hiv  = 1.5, # People with HIV are 1.5x more likely to transmit syphilis
@@ -25,13 +26,14 @@ class hiv_syph(ss.Connector):
         self.update_pars(pars, **kwargs)
         return
 
-    def update(self):
+    def step(self):
         """ Specify HIV-syphilis interactions """
+
         diseases = self.sim.diseases
         syph = diseases.syphilis
         hiv = diseases.hiv
         cd4 = self.sim.people.hiv.cd4
-        
+
         # People with HIV are more likely to acquire syphilis
         syph.rel_sus[cd4 < 500] = self.pars.rel_sus_syph_hiv
         syph.rel_sus[cd4 < 200] = self.pars.rel_sus_syph_aids
@@ -50,14 +52,15 @@ class hiv_syph(ss.Connector):
 
 class Penicillin(ss.Intervention):
     """ Create a penicillin (BPG) intervention for treating syphilis """
-    def __init__(self, year=2020, prob=0.5):
+    def __init__(self, year=2020, prob=0.8):
         super().__init__() # Initialize the intervention
         self.prob = prob # Store the probability of treatment
         self.year = year
         return
 
-    def apply(self, sim):
-        if sim.year > self.year:
+    def step(self):
+        sim = self.sim
+        if sim.now > self.year:
             syphilis = sim.diseases.syphilis
 
             # Define who is eligible for treatment
@@ -76,9 +79,9 @@ class Penicillin(ss.Intervention):
 
 def make_args():
     """ Make people, HIV, syphilis, and network """
-    pars = dict(n_agents=1000, verbose=0)
-    mf = ss.MFNet(duration=ss.lognorm_ex(mean=5, stdev=0.5))
-    hiv = ss.HIV(beta={'mf': [0.0008, 0.0004]}, init_prev=0.2)
+    pars = dict(n_agents=2000, verbose=0)
+    mf = ss.MFNet(duration=ss.lognorm_ex(mean=5, std=0.5)) # TODO: think about whether these should be ss.dur(); currently they are not since stored in natural units with -self.dt
+    hiv = ss.HIV(beta={'mf': [0.0008, 0.0004]}, init_prev=0.2) # TODO: beta should wrap the other way
     syph = ss.Syphilis(beta={'mf': [0.1, 0.05]}, init_prev=0.05)
     args = dict(pars=pars, networks=mf, diseases=[hiv, syph])
     return args
@@ -87,23 +90,23 @@ def make_args():
 def test_connectors(do_plot=False):
     """ Test connector example """
     sc.heading('Testing connectors')
-    
+
     # Make arguments
     args = make_args()
     sims = sc.objdict() # List of sims
-    
+
     # Make a sim with a connector, and run
     sims.con = ss.Sim(label='With connector', connectors=hiv_syph(), **args)
     sims.con.run()
-    
+
     # Make a sim without a connector, and run
     sims.nocon = ss.Sim(label='Without connector', **args)
     sims.nocon.run()
-    
+
     # Make a sim with a connector and syph treatment, and run
     sims.treat = ss.Sim(label='With treatment', connectors=hiv_syph(), interventions=Penicillin(), **args)
     sims.treat.run()
-    
+
     # Parse results
     results = sc.odict()
     diseases = ['syphilis', 'hiv']
@@ -114,35 +117,35 @@ def test_connectors(do_plot=False):
 
     # Plot
     if do_plot:
-        pl.figure()
-        
-        pl.subplot(2,1,1)
-        x = sims.con.yearvec
+        plt.figure()
+
+        plt.subplot(2,1,1)
+        x = sims.con.timevec
         for label,res in results.items():
-            pl.plot(x, res.syphilis, label=label)
-        pl.title('Syphilis infections')
-        pl.xlabel('Year')
-        pl.ylabel('Count')
-        pl.axvline(2020)
-        pl.legend()
-        
-        pl.subplot(2,1,2)
+            plt.plot(x, res.syphilis, label=label)
+        plt.title('Syphilis infections')
+        plt.xlabel('Year')
+        plt.ylabel('Count')
+        plt.axvline(2020)
+        plt.legend()
+
+        plt.subplot(2,1,2)
         for label,res in results.items():
-            pl.plot(x, res.hiv, label=label)
-        pl.title('HIV infections')
-        pl.xlabel('Year')
-        pl.ylabel('Count')
-        pl.axvline(2020)
-        pl.legend()
-        
+            plt.plot(x, res.hiv, label=label)
+        plt.title('HIV infections')
+        plt.xlabel('Year')
+        plt.ylabel('Count')
+        plt.axvline(2020)
+        plt.legend()
+
         sc.figlayout()
-        pl.show()
-    
+        plt.show()
+
     # Check results
     for disease in diseases:
         assert results[0][disease].sum() > results[1][disease].sum(), f'{disease.title()} infections should be higher with connector'
         assert results[0][disease].sum() > results[2][disease].sum(), f'{disease.title()} infections should be lower with treatment'
-   
+
     return sims
 
 
@@ -150,8 +153,8 @@ if __name__ == '__main__':
     do_plot = True
     sc.options(interactive=do_plot)
     T = sc.timer()
-    
+
     sims = test_connectors(do_plot=do_plot)
-    
+
     T.toc()
-    
\ No newline at end of file
+
diff --git a/tests/test_randomness.py b/tests/test_randomness.py
index 2b38f67..fba2c33 100644
--- a/tests/test_randomness.py
+++ b/tests/test_randomness.py
@@ -5,8 +5,9 @@ Test the Dists object from distributions.py
 # %% Imports and settings
 import numpy as np
 import sciris as sc
+import scipy.stats as sps
+import matplotlib.pyplot as plt
 import starsim as ss
-import matplotlib.pyplot as pl
 
 n = 5 # Default number of samples
 
@@ -17,10 +18,10 @@ def make_dist(name='test', **kwargs):
 
 def make_dists(**kwargs):
     """ Make a Dists object with two distributions in it """
-    sim = ss.Sim(n_agents=100).initialize() # Need an empty sim to initialize properly
+    sim = ss.Sim(n_agents=100).init() # Need an empty sim to initialize properly
     distlist = [make_dist(), make_dist()]
     dists = ss.Dists(distlist)
-    dists.initialize(sim=sim)
+    dists.init(sim=sim)
     return dists
 
 
@@ -29,7 +30,7 @@ def make_dists(**kwargs):
 def test_seed():
     """ Test assignment of seeds """
     sc.heading('Testing assignment of seeds')
-    
+
     # Create and initialize two distributions
     dists = make_dists()
     dist0, dist1 = dists.dists.values()
@@ -45,7 +46,7 @@ def test_reset(n=n):
     dists = make_dists()
     distlist = dists.dists.values()
 
-    # Reset via the container, but only 
+    # Reset via the container, but only
     before = sc.autolist()
     after = sc.autolist()
     for dist in distlist:
@@ -57,7 +58,7 @@ def test_reset(n=n):
     print(f'Initial sample:\n{before}')
     print(f'After reset sample:\n{after}')
     assert np.array_equal(before, after)
-    
+
     return before, after
 
 
@@ -79,7 +80,7 @@ def test_jump(n=n):
     print(f'Initial sample:\n{before}')
     print(f'After jump sample:\n{after}')
     assert not np.array_equal(before, after)
-    
+
     return before, after
 
 
@@ -92,9 +93,9 @@ def test_order(n=n):
     # Sample d0, d1
     before = d0(n)
     _ = d1(n)
-    
+
     dists.reset()
-    
+
     # Sample d1, d0
     _ = d1(n)
     after = d0(n)
@@ -111,39 +112,47 @@ def test_order(n=n):
 class CountInf(ss.Intervention):
     """ Store every infection state in a timepoints x people array """
     def init_pre(self, sim):
+        super().init_pre(sim)
         n_agents = len(sim.people)
-        self.arr = np.zeros((sim.npts, n_agents))
+        self.arr = np.zeros((len(sim), n_agents))
         self.n_agents = n_agents
         return
-    
-    def apply(self, sim):
-        self.arr[sim.ti, :] = np.array(sim.diseases.sir.infected)[:self.n_agents]
+
+    def step(self):
+        self.arr[self.sim.ti, :] = np.array(self.sim.diseases.sir.infected)[:self.n_agents]
         return
 
 
 class OneMore(ss.Intervention):
     """ Add one additional agent and infection """
+    def __init__(self, ti_apply=10):
+        super().__init__()
+        self.ti_apply = ti_apply
+        return
+
     def init_pre(self, sim):
+        super().init_pre(sim)
         one_birth = ss.Pregnancy(name='one_birth', rel_fertility=0) # Ensure no default births
         one_birth.init_pre(sim)
         self.one_birth = one_birth
         return
-    
-    def apply(self, sim, ti=10):
+
+    def step(self):
         """ Create an extra agent """
-        if sim.ti == ti:
+        sim = self.sim
+        if sim.ti == self.ti_apply:
             new_uids = self.one_birth.make_embryos(ss.uids(0)) # Assign 0th agent to be the "mother"
             sim.people.age[new_uids] = -100 # Set to a very low number to never reach debut age
-            
+
             # Infect that agent and immediately recover
             sir = sim.diseases.sir
             sir.set_prognoses(new_uids)
             sir.ti_recovered[new_uids] = sim.ti + 1 # Reset recovery time to next timestep
-            
+
             # Reset the random states
             p = sir.pars
             for dist in [p.dur_inf, p.p_death]:
-                dist.jump(sim.ti+1)
+                dist.jump_dt(force=True) # Already has correct dt value, but we need to force going back in time
 
         return
 
@@ -152,22 +161,22 @@ def plot_infs(s1, s2):
     """ Compare infection arrays from two sims """
     a1 = s1.interventions.countinf.arr
     a2 = s2.interventions.countinf.arr
-    
-    fig = pl.figure()
-    pl.subplot(1,3,1)
-    pl.pcolormesh(a1.T)
-    pl.xlabel('Timestep')
-    pl.ylabel('Person')
-    pl.title('Baseline')
-    
-    pl.subplot(1,3,2)
-    pl.pcolormesh(a2.T)
-    pl.title('OneMore')
-    
-    pl.subplot(1,3,3)
-    pl.pcolormesh(a2.T - a1.T)
-    pl.title('Difference')
-    
+
+    fig = plt.figure()
+    plt.subplot(1,3,1)
+    plt.pcolormesh(a1.T)
+    plt.xlabel('Timestep')
+    plt.ylabel('Person')
+    plt.title('Baseline')
+
+    plt.subplot(1,3,2)
+    plt.pcolormesh(a2.T)
+    plt.title('OneMore')
+
+    plt.subplot(1,3,3)
+    plt.pcolormesh(a2.T - a1.T)
+    plt.title('Difference')
+
     sc.figlayout()
     return fig
 
@@ -175,12 +184,12 @@ def plot_infs(s1, s2):
 def test_worlds(do_plot=False):
     """ Test that one extra birth leads to one extra infection """
     sc.heading('Testing worlds...')
-    
+
     res = sc.objdict()
-    
+
     pars = dict(
         start = 2000,
-        end = 2100,
+        stop = 2100,
         n_agents = 200,
         verbose = 0.05,
         diseases = dict(
@@ -197,20 +206,20 @@ def test_worlds(do_plot=False):
     )
     s1 = ss.Sim(pars=pars, interventions=CountInf())
     s2 = ss.Sim(pars=pars, interventions=[CountInf(), OneMore()])
-    
+
     s1.run()
     s2.run()
-    
+
     sum1 = s1.summarize()
     sum2 = s2.summarize()
     res.sum1 = sum1
     res.sum2 = sum2
-    
+
     if do_plot:
         s1.plot()
         plot_infs(s1, s2)
-        pl.show()
-    
+        plt.show()
+
     l1 = len(s1.people)
     l2 = len(s2.people)
     i1 = sum1.sir_cum_infections
@@ -220,14 +229,14 @@ def test_worlds(do_plot=False):
     assert l2 == l1 + 1, f'Expected one more person in s2 ({l2}) than s1 ({l1})'
     assert i2 == i1 + 1, f'Expected one more infection in s2 ({i2}) than s1 ({i1})'
     assert (a1 != a2).sum() == 0, f'Expected infection arrays to match:\n{a1}\n{a2}'
-        
+
     return res
 
 
 def test_independence(do_plot=False, thresh=0.1):
     """ Test that when variables are created, they are uncorrelated """
     sc.heading('Testing independence...')
-    
+
     # Create the sim and initialize (do not run)
     sim = ss.Sim(
         n_agents = 1000,
@@ -241,8 +250,8 @@ def test_independence(do_plot=False, thresh=0.1):
             dict(type='mf', debut=ss.constant(0), participation=0.5), # To avoid age correlations
         ]
     )
-    sim.initialize()
-    
+    sim.init()
+
     # Assemble measures
     st = sim.people.states
     arrs = sc.objdict()
@@ -256,7 +265,7 @@ def test_independence(do_plot=False, thresh=0.1):
             for uid in network.edges[p]:
                 data[uid] += 1 # Could also use a histogram
         arrs[key] = data
-    
+
     # Compute the correlations
     n = len(arrs)
     stats = np.zeros((n,n))
@@ -264,26 +273,49 @@ def test_independence(do_plot=False, thresh=0.1):
         for j,arr2 in arrs.enumvals():
             if i != j:
                 stats[i,j] = np.corrcoef(arr1, arr2)[0,1]
-                
+
     # Optionally plot
     if do_plot:
-        pl.figure()
-        pl.imshow(stats)
+        plt.figure()
+        plt.imshow(stats)
         ticks = np.arange(n)
         labels = arrs.keys()
-        pl.xticks(ticks, labels)
-        pl.yticks(ticks, labels)
-        pl.xticks(rotation=15)
-        pl.colorbar()
+        plt.xticks(ticks, labels)
+        plt.yticks(ticks, labels)
+        plt.xticks(rotation=15)
+        plt.colorbar()
         sc.figlayout()
-        pl.show()
-            
+        plt.show()
+
     # Test that everything is independent
     max_corr = abs(stats).max()
     assert max_corr < thresh, f'The maximum correlation between variables was {max_corr}, above the threshold {thresh}'
-    
+
     return sim
-    
+
+
+def test_combine_rands(do_plot=False):
+    n = int(1e6)
+    atol = 1e-3
+    target = 0.5
+    np.random.seed(2)
+    a = np.random.randint(np.iinfo(np.uint64).max, size=n, dtype=np.uint64)
+    b = np.random.randint(np.iinfo(np.uint64).max, size=n, dtype=np.uint64)
+    c = ss.utils.combine_rands(a, b)
+    if do_plot:
+        plt.figure()
+        for i,k,v in sc.objdict(a=a,b=b,combined=c).enumitems():
+            plt.subplot(3,1,i+1)
+            plt.hist(v)
+            plt.title(k)
+        sc.figlayout()
+        plt.show()
+
+    mean = c.mean()
+    assert np.isclose(mean, target, atol=atol), f'Expected value to be 0.5±{atol}, not {mean}'
+    ks = sps.kstest(c, sps.uniform(0,1).cdf)
+    assert ks.pvalue > 0.05, f'Distribution does not seem to be uniform, p={ks.pvalue}<0.05'
+    return c
 
 
 # %% Run as a script
@@ -297,6 +329,7 @@ if __name__ == '__main__':
     o4 = test_order(n)
     o5 = test_worlds(do_plot=do_plot)
     o6 = test_independence(do_plot=do_plot)
+    o7 = test_combine_rands(do_plot=do_plot)
 
     T.toc()
 
diff --git a/tests/test_run.py b/tests/test_run.py
new file mode 100644
index 0000000..2cc9d82
--- /dev/null
+++ b/tests/test_run.py
@@ -0,0 +1,111 @@
+"""
+Test run
+"""
+
+# %% Imports and settings
+import starsim as ss
+import sciris as sc
+import numpy as np
+import matplotlib.pyplot as plt
+
+n_agents = 1_000
+do_plot = False
+sc.options(interactive=False) # Assume not running interactively
+
+
+def make_sim_pars():
+    pars = sc.objdict(
+        n_agents = n_agents,
+        demographics = True,
+        networks = 'random',
+        diseases = sc.objdict(type='sir', beta=0.1), # To allow for modification later
+    )
+    return pars
+
+
+def test_parallel():
+    """ Test running two identical sims in parallel """
+    sc.heading('Testing parallel...')
+    pars = make_sim_pars()
+
+    # Check that two identical sims match
+    msim = ss.MultiSim([ss.Sim(pars, label='Sim1'), ss.Sim(pars, label='Sim2')])
+    msim.run(shrink=False)
+    s1, s2 = msim.sims
+    assert np.allclose(s1.summary[:], s2.summary[:], rtol=0, atol=0, equal_nan=True), "Sims don't match and should"
+
+    # Check that two non-identical sims don't match
+    pars2 = sc.dcp(pars)
+    pars2.diseases.beta *= 2
+    sims = ss.MultiSim([ss.Sim(pars, label='Sim1'), ss.Sim(pars2, label='Sim2')])
+    sims.run(shrink=False)
+    s1, s2 = sims.sims
+    assert not np.allclose(s1.summary[:], s2.summary[:], rtol=0, atol=0, equal_nan=True), "Sims do match and shouldn't"
+
+    return s1, s2
+
+
+def test_multisim():
+    """ Check MultiSim methods """
+    sc.heading('Testing MultiSim')
+    pars = make_sim_pars()
+    msim = ss.MultiSim(ss.Sim(pars))
+    msim.init_sims()
+    msim.run(n_runs=4)
+
+    # Plot individual sims
+    msim.plot()
+
+    # Reduce and plot mean
+    msim.mean()
+    msim.plot()
+
+    # Reduce and plot median
+    msim.median()
+    msim.plot()
+
+    # Other methods
+    msim.show()
+    msim.summarize()
+    msim.reset()
+
+    return msim
+
+
+def test_other():
+    """ Check other run options """
+    sc.heading('Testing other run options')
+    # Check parallel
+    pars = make_sim_pars()
+    pars2 = sc.dcp(pars)
+    pars2.diseases.beta *= 2
+    s1 = ss.Sim(pars)
+    s2 = ss.Sim(pars2)
+    ss.parallel(s1, s2, inplace=False)
+    assert not s1.initialized
+    ss.parallel(s1, s2, inplace=True)
+    assert not np.allclose(s1.summary[:], s2.summary[:], rtol=0, atol=0, equal_nan=True), "Sims do match and shouldn't"
+
+    # Check single run
+    s3 = ss.Sim(pars)
+    s4 = ss.Sim(pars)
+    s3 = ss.single_run(s3)
+    s4 = ss.single_run(s4, n_agents=2000)
+    assert not np.allclose(s3.summary[:], s4.summary[:], rtol=0, atol=0, equal_nan=True), "Sims do match and shouldn't"
+
+    return s3,s4
+
+
+if __name__ == '__main__':
+    do_plot = True
+    sc.options(interactive=do_plot)
+    T = sc.timer()
+
+    s1, s2 = test_parallel()
+    msim = test_multisim()
+    s3,s4 = test_other()
+
+    T.toc()
+
+    if do_plot:
+        plt.show()
diff --git a/tests/test_samples.py b/tests/test_samples.py
index 105662a..f39c737 100644
--- a/tests/test_samples.py
+++ b/tests/test_samples.py
@@ -14,9 +14,9 @@ def get_outputs(p_death):
         ppl = ss.People(1000)
         network = ss.RandomNet(n_contacts=ss.poisson(5))
         sir = ss.SIR(pars={'p_death':p_death})
-        sim = ss.Sim(people=ppl, networks=network, diseases=sir, rand_seed=0, n_years=5)
+        sim = ss.Sim(people=ppl, networks=network, diseases=sir, rand_seed=0, dur=5)
         sim.run(verbose=0)
-        df = sim.export_df()
+        df = sim.to_df()
         summary = {}
         summary['seed'] = sim.pars['rand_seed']
         summary['p_death'] = p_death
diff --git a/tests/test_sim.py b/tests/test_sim.py
index ae5d04c..9c8fef9 100644
--- a/tests/test_sim.py
+++ b/tests/test_sim.py
@@ -5,7 +5,6 @@ Test Sim API
 # %% Imports and settings
 import starsim as ss
 import sciris as sc
-import numpy as np
 import matplotlib.pyplot as plt
 import pytest
 
@@ -36,11 +35,11 @@ def test_demo(do_plot=do_plot):
     """ Test Starsim's demo run """
     sc.heading('Testing demo...')
     s1 = ss.demo(plot=do_plot)
-    
+
     # Test explicit demo
     s2 = ss.Sim(diseases='sir', networks='random').run()
-    
-    # Test explicit 
+
+    # Test explicit
     sir = ss.SIR()
     net = ss.RandomNet()
     s3 = ss.Sim(diseases=sir, networks=net).run()
@@ -71,57 +70,57 @@ def test_simple(do_plot=do_plot):
 def test_api():
     """ Test all different ways of creating a sim """
     sc.heading('Testing sim API...')
-    
+
     # Check different ways of specifying a sim
     s1 = ss.Sim(n_agents=n_agents, diseases='sir', networks='random').run() # Supply strings directly
     s2 = ss.Sim(pars=dict(n_agents=n_agents, diseases='sir', networks='random')).run() # Supply as parameters
     s3 = ss.Sim(n_agents=n_agents, diseases=ss.SIR(), networks=ss.RandomNet()).run() # Supply as objects
     ss.check_sims_match(s1, s2, s3), 'Sims should match'
-    
+
     # Check different ways of setting a distribution
     kw = dict(n_agents=n_agents, networks='random')
     d1 = ss.lognorm_ex(10) # Create a distribution with an argument
-    d2 = ss.lognorm_ex(mean=10, stdev=2) # Create a distribution with kwargs
+    d2 = ss.lognorm_ex(mean=10, std=2) # Create a distribution with kwargs
     d3 = ss.normal(loc=10) # Create a different type of distribution
-    
+
     # Check specifying dist with a scalar
     s4 = ss.Sim(diseases=dict(type='sir', dur_inf=10), **kw).run() # Supply values as a scalar
     s5 = ss.Sim(diseases=dict(type='sir', dur_inf=d1), **kw).run() # Supply as a distribution
     ss.check_sims_match(s4, s5), 'Sims should match'
-    
+
     # Check specifying dist with a list and dict
     s6 = ss.Sim(diseases=dict(type='sir', dur_inf=[10,2]), **kw).run() # Supply values as a list
-    s7 = ss.Sim(diseases=dict(type='sir', dur_inf=dict(mean=10, stdev=2)), **kw).run() # Supply values as a dict
+    s7 = ss.Sim(diseases=dict(type='sir', dur_inf=dict(mean=10, std=2)), **kw).run() # Supply values as a dict
     s8 = ss.Sim(diseases=dict(type='sir', dur_inf=d2), **kw).run() # Supply as a distribution
     ss.check_sims_match(s6, s7, s8), 'Sims should match'
-    
+
     # Check changing dist type
     s9  = ss.Sim(diseases=dict(type='sir', dur_inf=dict(type='normal', loc=10)), **kw).run() # Supply values as a dict
     s10 = ss.Sim(diseases=dict(type='sir', dur_inf=d3), **kw).run() # Supply values as a distribution
     ss.check_sims_match(s9, s10), 'Sims should match'
-    
+
     # Check that Bernoulli distributions can't be changed
     with pytest.raises(TypeError):
-        ss.Sim(diseases=dict(type='sir', init_prev=dict(type='normal', loc=10)), **kw).initialize()
-    
+        ss.Sim(diseases=dict(type='sir', init_prev=dict(type='normal', loc=10)), **kw).init()
+
     return s1
 
 
 def test_complex_api():
     """ Test that complex inputs can be parsed correctly """
     sc.heading('Testing complex API...')
-    
+
     def jump_age(sim):
         """ Arbitrary intervention to reduce people's ages in the simulation """
         if sim.ti == 20:
             sim.people.age[:] = sim.people.age[:] + 1000
-    
+
     # Specify parameters as a dictionary
-    p = dict(
+    pars1 = dict(
         n_agents = 1000,
         label = 'v1',
         verbose = 'brief',
-        end = 2020,
+        stop = 2020,
         networks = [
             ss.RandomNet(name='random1', n_contacts=6),
             dict(type='random', name='random2', n_contacts=4)
@@ -136,35 +135,35 @@ def test_complex_api():
         ],
         interventions = jump_age,
     )
-    
+
     # Test with explicit initialization
-    pars = ss.SimPars(n_agents=1000, label='v1', verbose='brief', end=2020)
-    
+    pars2 = ss.SimPars(n_agents=1000, label='v1', verbose='brief', stop=2020)
+
     net1 = ss.RandomNet(name='random1', n_contacts=6)
     net2 = ss.RandomNet(name='random2', n_contacts=4)
     networks = ss.ndict(net1, net2)
-    
+
     dis1 = ss.SIR(dur_inf=ss.expon(scale=6.0))
     dis2 = ss.SIS(beta=0.07, init_prev=ss.bernoulli(0.1))
     diseases = ss.ndict(dis1, dis2)
-    
+
     dem1 = ss.Births(birth_rate=20)
     dem2 = ss.Deaths(death_rate=20)
     demographics = ss.ndict(dem1, dem2)
-    
+
     int1 = ss.Intervention.from_func(jump_age)
     interventions = ss.ndict(int1)
 
     # Assemble
-    s1 = ss.Sim(p)
-    s2 = ss.Sim(pars=pars, networks=networks, diseases=diseases, demographics=demographics, interventions=interventions)
-    
+    s1 = ss.Sim(pars1)
+    s2 = ss.Sim(pars=pars2, networks=networks, diseases=diseases, demographics=demographics, interventions=interventions)
+
     # Run
     s1.run()
     s2.run()
-    
+
     assert ss.check_sims_match(s1, s2), 'Sims should match'
-    
+
     return s1
 
 
@@ -180,14 +179,14 @@ def test_simple_vax(do_plot=do_plot):
     intv = ss.routine_vx(start_year=2015, prob=0.2, product=my_vax)
     sim_intv = ss.Sim(pars=pars, interventions=intv)
     sim_intv.run()
-    
+
     assert sim_intv.summary.sir_cum_infections < sim_base.summary.sir_cum_infections, 'Vaccine should avert infections'
 
     # Check plots
     if do_plot:
         plt.figure()
-        plt.plot(sim_base.yearvec, sim_base.results.sir.prevalence, label='Baseline')
-        plt.plot(sim_intv.yearvec, sim_intv.results.sir.prevalence, label='Vax')
+        plt.plot(sim_base.timevec, sim_base.results.sir.prevalence, label='Baseline')
+        plt.plot(sim_intv.timevec, sim_intv.results.sir.prevalence, label='Vax')
         plt.axvline(x=2015, color='k', ls='--')
         plt.title('Prevalence')
         plt.legend()
@@ -198,12 +197,12 @@ def test_simple_vax(do_plot=do_plot):
 def test_shared_product(do_plot=do_plot):
     """ Check that multiple interventions can use the same product """
     sc.heading('Testing sharing a product across interventions...')
-    
+
     # Make interventions
     vax = ss.sir_vaccine(pars=dict(efficacy=0.5))
     routine1 = ss.routine_vx(name='early-small', start_year=2010, prob=0.05, product=vax)
     routine2 = ss.routine_vx(name='late-big', start_year=2020, prob=0.5, product=vax)
-    
+
     # Make and run sims
     pars = make_sim_pars()
     s1 = ss.Sim(pars, label='Baseline')
@@ -212,16 +211,16 @@ def test_shared_product(do_plot=do_plot):
     s1.run()
     s2.run()
     s3.run()
-    
+
     if do_plot:
         plt.figure()
         for sim in [s1, s2, s3]:
-            plt.plot(sim.yearvec, sim.results.sir.cum_infections, label=sim.label)
+            plt.plot(sim.timevec, sim.results.sir.cum_infections, label=sim.label)
         plt.legend()
         plt.title('Impact of vaccination')
         plt.xlabel('Year')
         plt.ylabel('Cumulative infections')
-        
+
     assert s2.summary.sir_cum_infections < s1.summary.sir_cum_infections, 'Vaccine should avert infections'
     assert s3.summary.sir_cum_infections < s2.summary.sir_cum_infections, 'Vaccine should avert infections'
     return s3
@@ -240,33 +239,39 @@ def test_components(do_plot=do_plot):
     return sim
 
 
-def test_parallel():
-    """ Test running two identical sims in parallel """
-    sc.heading('Testing parallel...')
-    pars = make_sim_pars()
+def test_save():
+    """ Test save and export """
+    sc.heading('Testing save and export...')
+    f = sc.objdict() # Filenames
+    f.sim  = 'temp.sim'
+    f.json = 'sim.json'
+    sim = ss.Sim(n_agents=n_agents, diseases='sis', networks='random').run()
 
-    # Check that two identical sims match
-    sims = ss.MultiSim([ss.Sim(pars, label='Sim1'), ss.Sim(pars, label='Sim2')])
-    sims.run(keep_people=True)
-    s1, s2 = sims.sims
-    assert np.allclose(s1.summary[:], s2.summary[:], rtol=0, atol=0, equal_nan=True)
+    # Run the methods
+    sim.save(filename=f.sim)
+    sim.to_json(filename=f.json)
+    json = sim.to_json()
 
-    # Check that two non-identical sims don't match
-    pars2 = sc.dcp(pars)
-    pars2.diseases.beta *= 2
-    sims = ss.MultiSim([ss.Sim(pars, label='Sim1'), ss.Sim(pars2, label='Sim2')])
-    sims.run(keep_people=True)
-    s1, s2 = sims.sims
-    assert not np.allclose(s1.summary[:], s2.summary[:], rtol=0, atol=0, equal_nan=True)
+    # Run methods
+    s2 = sc.load(f.sim)
+    json2 = sc.loadjson(f.json)
 
-    return s1, s2
+    # Run tests
+    assert sim.summary == s2.summary, 'Sims do not match'
+    assert sim.pars.n_agents == json2['pars']['n_agents'], 'Parameters do not match'
+    assert json == json2, 'Outputs do not match'
+
+    # Delete files
+    sc.rmpath(f.values())
+
+    return sim
 
 
 if __name__ == '__main__':
     do_plot = True
     sc.options(interactive=do_plot)
     T = sc.timer()
-    
+
     sim0 = test_demo(do_plot=do_plot)
     sim1 = test_default(do_plot=do_plot)
     sim2 = test_simple(do_plot=do_plot)
@@ -275,9 +280,9 @@ if __name__ == '__main__':
     sim5b, sim5i = test_simple_vax(do_plot=do_plot)
     sim6 = test_shared_product(do_plot=do_plot)
     sim7 = test_components(do_plot=do_plot)
-    sim8a, sim8b = test_parallel()
-    
+    sim8 = test_save()
+
     T.toc()
-    
+
     if do_plot:
         plt.show()
diff --git a/tests/test_syphilis.py b/tests/test_syphilis.py
index 731eaf9..f914cda 100644
--- a/tests/test_syphilis.py
+++ b/tests/test_syphilis.py
@@ -4,11 +4,13 @@ Run syphilis
 
 # %% Imports and settings
 import numpy as np
-import starsim as ss
 import pandas as pd
+import sciris as sc
+import starsim as ss
 import matplotlib.pyplot as plt
 
 quick_run = True
+datadir = ss.root / 'tests/test_data'
 
 
 def make_syph_sim(dt=1, n_agents=500):
@@ -18,14 +20,14 @@ def make_syph_sim(dt=1, n_agents=500):
     syph.pars.init_prev = ss.bernoulli(p=0.1)
 
     # Make demographic modules
-    fertility_rates = {'fertility_rate': pd.read_csv(ss.root / 'tests/test_data/nigeria_asfr.csv')}
+    fertility_rates = {'fertility_rate': pd.read_csv(datadir/'nigeria_asfr.csv')}
     pregnancy = ss.Pregnancy(pars=fertility_rates)
-    death_rates = {'death_rate': pd.read_csv(ss.root / 'tests/test_data/nigeria_deaths.csv'), 'units': 1}
+    death_rates = {'death_rate': pd.read_csv(datadir/'nigeria_deaths.csv'), 'rate_units': 1}
     death = ss.Deaths(death_rates)
 
     # Make people and networks
     ss.set_seed(1)
-    ppl = ss.People(n_agents, age_data=pd.read_csv(ss.root / 'tests/test_data/nigeria_age.csv'))
+    ppl = ss.People(n_agents, age_data=datadir/'nigeria_age.csv')
 
     # Marital
     mf = ss.MFNet(duration=1/24)
@@ -35,7 +37,7 @@ def make_syph_sim(dt=1, n_agents=500):
         dt=dt,
         total_pop=93963392,
         start=1990,
-        n_years=40,
+        dur=40,
         people=ppl,
         diseases=syph,
         networks=ss.ndict(mf, maternal),
@@ -54,13 +56,11 @@ class check_states(ss.Analyzer):
         self.okay = True
         return
 
-    def update_results(self, sim):
-        return self.apply(sim)
-
-    def apply(self, sim):
+    def step(self):
         """
         Checks states that should be mutually exlusive and collectively exhaustive
         """
+        sim = self.sim
         sppl = sim.diseases.syphilis
 
         # Infection states: people must be exactly one of these
@@ -79,11 +79,10 @@ class check_states(ss.Analyzer):
         checkall = np.array([s1a, s1b, s2a, s2b, s3])
         if not checkall.all():
             self.okay = False
-
         return
 
 
-def test_syph(dt=1, n_agents=500):
+def test_syph(dt=1, n_agents=500, do_plot=False):
 
     sim_kwargs = make_syph_sim(dt=dt, n_agents=n_agents)
     sim = ss.Sim(analyzers=check_states(), **sim_kwargs)
@@ -91,33 +90,36 @@ def test_syph(dt=1, n_agents=500):
 
     # Check plots
     burnin = 0
-    pi = int(burnin/sim.dt)
+    pi = int(burnin/dt)
 
-    fig, ax = plt.subplots(2, 2)
-    ax = ax.ravel()
-    ax[0].stackplot(
-        sim.yearvec[pi:],
-        # sim.results.syphilis.n_susceptible[pi:],
-        sim.results.syphilis.n_congenital[pi:],
-        sim.results.syphilis.n_exposed[pi:],
-        sim.results.syphilis.n_primary[pi:],
-        sim.results.syphilis.n_secondary[pi:],
-        (sim.results.syphilis.n_latent_temp[pi:]+sim.results.syphilis.n_latent_long[pi:]),
-        sim.results.syphilis.n_tertiary[pi:],
-    )
-    ax[0].legend(['Congenital', 'Exposed', 'Primary', 'Secondary', 'Latent', 'Tertiary'], loc='lower right')
+    if do_plot:
+        tvec = sim.timevec[pi:]
+        res = sim.results.syphilis
+        fig, ax = plt.subplots(2, 2)
+        ax = ax.ravel()
+        ax[0].stackplot(
+            tvec,
+            # res.n_susceptible[pi:],
+            res.n_congenital[pi:],
+            res.n_exposed[pi:],
+            res.n_primary[pi:],
+            res.n_secondary[pi:],
+            (res.n_latent_temp[pi:]+res.n_latent_long[pi:]),
+            res.n_tertiary[pi:],
+        )
+        ax[0].legend(['Congenital', 'Exposed', 'Primary', 'Secondary', 'Latent', 'Tertiary'], loc='lower right')
 
-    ax[1].plot(sim.yearvec[pi:], sim.results.syphilis.prevalence[pi:])
-    ax[1].set_title('Syphilis prevalence')
+        ax[1].plot(tvec, res.prevalence[pi:])
+        ax[1].set_title('Syphilis prevalence')
 
-    ax[2].plot(sim.yearvec[pi:], sim.results.n_alive[pi:])
-    ax[2].set_title('Population')
+        ax[2].plot(tvec, sim.results.n_alive[pi:])
+        ax[2].set_title('Population')
 
-    ax[3].plot(sim.yearvec[pi:], sim.results.syphilis.new_infections[pi:])
-    ax[3].set_title('New infections')
+        ax[3].plot(tvec, res.new_infections[pi:])
+        ax[3].set_title('New infections')
 
-    fig.tight_layout()
-    plt.show()
+        fig.tight_layout()
+        plt.show()
 
     return sim
 
@@ -126,7 +128,7 @@ def test_syph_intvs(dt=1, n_agents=500, do_plot=False):
 
     # Interventions
     # screen_eligible = lambda sim: sim.demographics.pregnancy.pregnant
-    screen_eligible = lambda sim: sim.networks.mf.active(sim.people)
+    screen_eligible = lambda sim: sim.networks.mfnet.active(sim.people)
     syph_screening = ss.syph_screening(
         product='rpr',
         prob=0.99,
@@ -135,7 +137,7 @@ def test_syph_intvs(dt=1, n_agents=500, do_plot=False):
         label='syph_screening',
     )
 
-    treat_eligible = lambda sim: ss.uids(sim.get_intervention('syph_screening').outcomes['positive'])
+    treat_eligible = lambda sim: ss.uids(sim.interventions['syph_screening'].outcomes['positive'])
     bpg = ss.syph_treatment(
         prob=0.9,
         product='bpg',
@@ -155,10 +157,12 @@ def test_syph_intvs(dt=1, n_agents=500, do_plot=False):
         sim_base.run()
 
         burnin = 10
-        pi = int(burnin/sim_base.dt)
+        syph_b = sim_base.diseases.syphilis
+        syph_i = sim_intv.diseases.syphilis
+        pi = int(burnin/syph_b.t.dt)
         plt.figure()
-        plt.plot(sim_base.yearvec[pi:], sim_base.results.syphilis.prevalence[pi:], label='Baseline')
-        plt.plot(sim_intv.yearvec[pi:], sim_intv.results.syphilis.prevalence[pi:], label='S&T')
+        plt.plot(syph_b.timevec[pi:], syph_b.results.prevalence[pi:], label='Baseline')
+        plt.plot(syph_i.timevec[pi:], syph_i.results.prevalence[pi:], label='S&T')
         plt.axvline(x=2020, color='k', ls='--')
         plt.title('Syphilis prevalence')
         plt.legend()
@@ -171,10 +175,14 @@ def test_syph_intvs(dt=1, n_agents=500, do_plot=False):
 
 
 if __name__ == '__main__':
+    T = sc.timer()
+    do_plot = True
 
     dt = [1/12, 1][quick_run]
     n_agents = [20e3, 500][quick_run]
 
-    sim = test_syph(dt=dt, n_agents=n_agents)
+    sim = test_syph(dt=dt, n_agents=n_agents, do_plot=do_plot)
     sim_base, sim_intv = test_syph_intvs(dt=dt, n_agents=n_agents, do_plot=True)
 
+    T.toc()
+
diff --git a/tests/test_time.py b/tests/test_time.py
new file mode 100644
index 0000000..18fd6d3
--- /dev/null
+++ b/tests/test_time.py
@@ -0,0 +1,248 @@
+"""
+Test different time units and timesteps
+"""
+
+import numpy as np
+import sciris as sc
+import starsim as ss
+
+small = 100
+medium = 1000
+sc.options(interactive=False)
+
+
+# %% Define the tests
+def test_ratio():
+    sc.heading('Test behavior of time_ratio()')
+
+    assert ss.time_ratio() == 1.0
+    assert ss.time_ratio(dt1=1.0, dt2=0.1) == 10.0
+    assert ss.time_ratio(dt1=0.5, dt2=5) == 0.1
+    assert ss.time_ratio(dt1=0.5, dt2=5) == 0.1
+
+    assert ss.time_ratio(unit1='year', unit2='day') == 365.25
+    assert ss.time_ratio(unit1='day', unit2='year') == 1/365.25
+
+    return
+
+
+def test_classes():
+    sc.heading('Test behavior of dur() and rate()')
+
+    # Test duration dt
+    d1 = ss.dur(2)
+    d2 = ss.dur(3)
+    d3 = ss.dur(2, parent_dt=0.1)
+    d4 = ss.dur(3, parent_dt=0.2)
+    for d in [d1,d2,d3,d4]: d.init()
+
+    assert d1 + d2 == 2+3
+    assert d3 + d4 == 2/0.1 + 3/0.2
+    assert d3 * 2 == 2/0.1*2
+    assert d3 / 2 == 2/0.1/2
+
+    # Test rate dt
+    r1 = ss.rate(2)
+    r2 = ss.rate(3)
+    r3 = ss.rate(2, parent_dt=0.1)
+    r4 = ss.rate(3, parent_dt=0.2)
+    for r in [r1,r2,r3,r4]: r.init()
+
+    assert r1 + r2 == 2 + 3
+    assert r3 + r4 == 2*0.1 + 3*0.2
+    assert r3 * 2 == 2*0.1*2
+    assert r3 / 2 == 2*0.1/2
+
+    # Test duration units
+    d5 = ss.dur(2, unit='year').init(parent_unit='day')
+    d6 = ss.dur(3, unit='day').init(parent_unit='day')
+    assert d5 + d6 == 2*365.25+3
+
+    # Test rate units
+    rval = 0.7
+    r5 = ss.rate(rval, unit='week').init(parent_unit='day')
+    r6 = ss.rate(rval).init(parent_dt=0.1)
+    assert np.isclose(r5.values, rval/7) # A limitation of this approach, not exact!
+    assert np.isclose(r6.values, rval/10)
+
+    # Test time_prob
+    tpval = 0.1
+    tp0 = ss.time_prob(tpval).init(parent_dt=1.0)
+    tp1 = ss.time_prob(tpval).init(parent_dt=0.5)
+    tp2 = ss.time_prob(tpval).init(parent_dt=2)
+    assert np.isclose(tp0.values, tpval)
+    assert np.isclose(tp1.values, tpval/2, rtol=0.1)
+    assert np.isclose(tp2.values, tpval*2, rtol=0.1)
+    assert tp1.values > tpval/2
+    assert tp2.values < tpval*2
+
+    return d3, d4, r3, r4, tp1
+
+
+def test_units(do_plot=False):
+    sc.heading('Test behavior of year vs day units')
+
+    sis = ss.SIS(
+        beta = ss.beta(0.05, 'day'),
+        init_prev = ss.bernoulli(p=0.1),
+        dur_inf = ss.lognorm_ex(mean=ss.dur(10, 'day')),
+        waning = ss.rate(0.05, 'day'),
+        imm_boost = 1.0,
+    )
+
+    rnet = ss.RandomNet(
+        n_contacts = 10,
+        dur = 0, # Note; network edge durations are required to have the same unit as the network
+    )
+
+    pars = dict(
+        diseases = sis,
+        networks = rnet,
+        n_agents = small,
+    )
+
+    sims = sc.objdict()
+    sims.y = ss.Sim(pars, unit='year', label='Year', start=2000, stop=2002, dt=1/365, verbose=0)
+    sims.d = ss.Sim(pars, unit='day', label='Day', start='2000-01-01', stop='2002-01-01', dt=1, verbose=0)
+
+    for sim in sims.values():
+        sim.run()
+        if do_plot:
+            sim.plot()
+
+    # Check that results match to within stochastic uncertainty
+    rtol = 0.05
+    vals = [sim.summary.sis_cum_infections for sim in [sims.y, sims.d]]
+    assert np.isclose(*vals, rtol=rtol), f'Values for cum_infections do not match ({vals})'
+
+    return sims
+
+
+def test_multi_timestep(do_plot=False):
+    sc.heading('Test behavior of different modules having different timesteps')
+
+    pars = dict(
+        diseases = ss.SIS(unit='day', dt=1.0, init_prev=0.1, beta=ss.beta(0.01)),
+        demographics = ss.Births(unit='year', dt=0.25),
+        networks = ss.RandomNet(unit='week'),
+        n_agents = small,
+        verbose = 0,
+    )
+
+    sim = ss.Sim(pars, unit='day', dt=2, start='2000-01-01', stop='2002-01-01')
+    sim.run()
+
+    twoyears = 366*2
+    quarters = 2/0.25
+    assert len(sim) == twoyears//2
+    assert len(sim.diseases.sis) == twoyears
+    assert len(sim.demographics.births) == quarters
+
+    if do_plot:
+        sim.plot()
+
+    return sim
+
+
+def test_mixed_timesteps():
+    sc.heading('Test behavior of different commbinations of timesteps')
+
+    siskw = dict(dur_inf=ss.dur(50, 'day'), beta=ss.beta(0.01, 'day'), waning=ss.rate(0.005, 'day'))
+    kw = dict(n_agents=1000, start='2001-01-01', stop='2001-07-01', networks='random', copy_inputs=False, verbose=0)
+
+    print('Year-year')
+    sis1 = ss.SIS(unit='year', dt=1/365, **sc.dcp(siskw))
+    sim1 = ss.Sim(unit='year', dt=1/365, diseases=sis1, label='year-year', **kw)
+
+    print('Day-day')
+    sis2 = ss.SIS(unit='day', dt=1.0, **sc.dcp(siskw))
+    sim2 = ss.Sim(unit='day', dt=1.0, diseases=sis2, label='day-day', **kw)
+
+    print('Day-year')
+    sis3 = ss.SIS(unit='day', dt=1.0, **sc.dcp(siskw))
+    sim3 = ss.Sim(unit='year', dt=1/365, diseases=sis3, label='day-year', **kw)
+
+    print('Year-day')
+    sis4 = ss.SIS(unit='year', dt=1/365, **sc.dcp(siskw))
+    sim4 = ss.Sim(unit='day', dt=1.0, diseases=sis4, label='year-day', **kw)
+
+    msim = ss.parallel(sim1, sim2, sim3, sim4)
+
+    # Check that al results are close
+    threshold = 0.01
+    summary = msim.summarize()
+    for key,res in summary.items():
+        if res.mean:
+            ratio = res.std/res.mean
+            assert ratio < threshold, f'Result {key} exceeds threshold: {ratio:n} > {threshold}'
+            print(f'✓ Result {key} within threshold: {ratio:n} < {threshold}')
+    return msim
+
+
+def test_time_class():
+    sc.heading('Test different instances of ss.Time')
+
+    def sim(start, stop, dt, unit):
+        """ Generate a fake sim """
+        sim = sc.prettyobj()
+        sim.t = ss.Time(start=start, stop=stop, dt=dt, unit=unit, sim=True)
+        return sim
+
+    print('Testing dates vs. numeric')
+    s1 = sim(start=2000, stop=2002, dt=0.1, unit='year')
+    t1 = ss.Time(start='2001-01-01', stop='2001-06-30', dt=2.0, unit='day')
+    t1.init(sim=s1)
+    assert np.array_equal(s1.t.timevec, s1.t.yearvec)
+    assert len(s1.t.timevec) == 21
+    assert t1.npts == sc.daydiff('2001-01-01', '2001-06-30')//2 + 1
+    assert sc.isnumber(s1.t.start)
+    assert isinstance(t1.start, ss.date)
+    assert s1.t.datevec[-1] == ss.date('2002-01-01')
+    assert t1.datevec[-1] == ss.date('2001-06-30')
+    assert t1.abstvec[0] == 1.0
+
+    print('Testing weeks vs. days')
+    s2 = sim(start='2000-06-01', stop='2001-05-01', dt=1, unit='day')
+    t2 = ss.Time(start='2000-06-01', stop='2001-05-01', dt=1, unit='week')
+    t2.init(sim=s2)
+    assert np.array_equal(s2.t.timevec, s2.t.datevec)
+    assert isinstance(s2.t.start, ss.date)
+    assert t2.npts*7 == s2.t.npts + 1
+    assert np.array_equal(t2.abstvec, s2.t.abstvec[::7])
+
+    print('Testing different units and dt')
+    s3 = sim(start='2001-01-01', stop='2003-01-01', dt=0.1, unit='year')
+    t3 = ss.Time(start='2001-01-01', stop='2003-01-01', dt=2.0, unit='day')
+    t3.init(sim=s3)
+    assert np.array_equal(s3.t.timevec, s3.t.datevec)
+    assert s3.t.datevec[-1] == ss.date('2003-01-01')
+    assert s3.t.npts == 21
+    assert np.isclose(s3.t.abstvec.mean(), t3.abstvec.mean(), atol=1e-3)
+
+    print('Testing unitless')
+    s4 = sim(start=0, stop=10, dt=1.0, unit='unitless')
+    t4 = ss.Time(start=2, stop=9, dt=0.1, unit='unitless')
+    t4.init(sim=s4)
+    assert np.array_equal(s4.t.timevec, s4.t.abstvec)
+    assert s4.t.datevec[0] == ss.date(ss.time.default_start_year)
+    assert len(s4.t) == 11
+    assert len(t4) == (9-2)/0.1+1
+
+    return [s1, t1, s2, t2]
+
+
+# %% Run as a script
+if __name__ == '__main__':
+    do_plot = True
+    sc.options(interactive=do_plot)
+
+    T = sc.timer()
+
+    o1 = test_ratio()
+    o2 = test_classes()
+    o3 = test_units(do_plot)
+    o4 = test_multi_timestep(do_plot)
+    o5 = test_mixed_timesteps()
+    o6 = test_time_class()
+
+    T.toc()
diff --git a/tests/update_baseline.py b/tests/update_baseline.py
index 67af0b8..39b8514 100755
--- a/tests/update_baseline.py
+++ b/tests/update_baseline.py
@@ -1,10 +1,9 @@
 #!/usr/bin/env python3
-
-'''
+"""
 Run this script to regenerate the baseline.
-'''
+"""
 
-import test_baselines as tb
+import test_baselines
 
-tb.save_baseline()
-tb.test_benchmark(do_save=True, repeats=5)
+test_baselines.save_baseline()
+test_baselines.test_benchmark(do_save=True, repeats=5)
